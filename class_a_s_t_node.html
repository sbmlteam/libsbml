<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>libSBML C++ API: ASTNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.20.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_a_s_t_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_a_s_t_node-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">ASTNode Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> Abstract Syntax Tree (AST) representation of a mathematical expression.</p>
<p style='color: #777; font-style: italic'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</p>
<p>Abstract Syntax Trees (ASTs) are a simple kind of data structure used in libSBML for storing mathematical expressions. The <a class="el" href="class_a_s_t_node.html">ASTNode</a> is the cornerstone of libSBML's AST representation. An AST "node" represents the most basic, indivisible part of a mathematical formula and come in many types. For instance, there are node types to represent numbers (with subtypes to distinguish integer, real, and rational numbers), names (e.g., constants or variables), simple mathematical operators, logical or relational operators and functions. LibSBML ASTs provide a canonical, in-memory representation for all mathematical formulas regardless of their original format (which might be MathML or might be text strings).</p>
<dl class="section user"><dt></dt><dd>An AST <em>node</em> in libSBML is a recursive tree structure; each node has a type, a pointer to a value, and a list of children nodes. Each <a class="el" href="class_a_s_t_node.html">ASTNode</a> node may have none, one, two, or more children depending on its type. There are node types to represent numbers (with subtypes to distinguish integer, real, and rational numbers), names (e.g., constants or variables), simple mathematical operators, logical or relational operators and functions. The following diagram illustrates an example of how the mathematical expression <code>"1 + 2"</code> is represented as an AST with one <em>plus</em> node having two <em>integer</em> children nodes for the numbers <code>1</code> and <code>2</code>. The figure also shows the corresponding MathML representation:</dd></dl>
<table border="0" class="centered text-table width80 normal-font" style="padding-bottom: 0.5em">
<caption class="top-caption">Example AST representation of a mathematical expression.</caption>
<tr>
<th width="50px">Infix</th>
<th>AST</th>
<th>MathML</th>
</tr>
<tr>
<td valign="middle" align="center">
<code>1 + 2</code>
</td>
<td valign="middle">
  <object type="image/svg+xml" data="simple-ast.svg" class="centered" width="140px"></object>
</td>
<td valign="middle">
<code>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;</code><br>
<code>&nbsp;&nbsp;&lt;apply&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;plus/&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 1 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 2 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&lt;/apply&gt;</code><br>
<code>&lt;/math&gt;</code>
</td>
</tr>
</table>
<p>The following are other noteworthy points about the AST representation in libSBML:</p>
<ul>
<li>A numerical value represented in MathML as a real number with an exponent is preserved as such in the AST node representation, even if the number could be stored in a <code>double</code> data type. This is done so that when an SBML model is read in and then written out again, the amount of change introduced by libSBML to the SBML during the round-trip activity is minimized.</li>
</ul>
<ul>
<li>Rational numbers are represented in an AST node using separate numerator and denominator values. These can be retrieved using the methods <a class="el" href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee" title="Returns the value of the numerator of this node if of type AST_RATIONAL, or the numerical value of th...">ASTNode::getNumerator()</a> and <a class="el" href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6" title="Returns the value of the denominator of this node.">ASTNode::getDenominator()</a>.</li>
</ul>
<ul>
<li>The children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> are other <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects. The list of children is empty for nodes that are leaf elements, such as numbers. For nodes that are actually roots of expression subtrees, the list of children points to the parsed objects that make up the rest of the expression.</li>
</ul>
<p>For many applications, the details of ASTs are irrelevant because libSBML provides text-string based translation functions such as <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a> and <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a>. If you find the complexity of using the AST representation of expressions too high for your purposes, perhaps the string-based functions will be more suitable.</p>
<h3><a class="anchor" id="ASTNodeType_t"></a> ASTNodeType_t</h3>
<dl class="section user"><dt></dt><dd>Every <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an associated type code to indicate whether, for example, it holds a number or stands for an arithmetic operator. The type is recorded as a value drawn from the enumeration <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode types.">ASTNodeType_t</a>. The list of possible types is quite long, because it covers all the mathematical functions that are permitted in SBML. The values are shown in the following table:</dd></dl>
<table border="0" class="centered text-table align-bottom borderless code">
<tr><td>AST_CONSTANT_E</td><td>         AST_FUNCTION_CSC</td><td>                       AST_LOGICAL_AND</td></tr>
<tr><td>AST_CONSTANT_FALSE</td><td>     AST_FUNCTION_CSCH</td><td>                      AST_LOGICAL_IMPLIES<sup>2</sup></td></tr>
<tr><td>AST_CONSTANT_PI</td><td>        AST_FUNCTION_DELAY</td><td>                     AST_LOGICAL_NOT</td></tr>
<tr><td>AST_CONSTANT_TRUE</td><td>      AST_FUNCTION_EXP</td><td>                       AST_LOGICAL_OR</td></tr>
<tr><td>AST_DIVIDE</td><td>             AST_FUNCTION_FACTORIAL</td><td>                 AST_LOGICAL_XOR</td></tr>
<tr><td>AST_FUNCTION</td><td>           AST_FUNCTION_FLOOR</td><td>                     AST_MINUS</td></tr>
<tr><td>AST_FUNCTION_ABS</td><td>       AST_FUNCTION_LN</td><td>                        AST_NAME</td></tr>
<tr><td>AST_FUNCTION_ARCCOS</td><td>    AST_FUNCTION_LOG</td><td>                       AST_NAME_AVOGADRO<sup>1</sup></td></tr>
<tr><td>AST_FUNCTION_ARCCOSH</td><td>   AST_FUNCTION_MAX<sup>2</sup></td><td>           AST_NAME_TIME</td></tr>
<tr><td>AST_FUNCTION_ARCCOT</td><td>    AST_FUNCTION_MIN<sup>2</sup></td><td>           AST_ORIGINATES_IN_PACKAGE<sup>2</sup></tr>
<tr><td>AST_FUNCTION_ARCCOTH</td><td>   AST_FUNCTION_PIECEWISE</td><td>                 AST_PLUS</td></tr>
<tr><td>AST_FUNCTION_ARCCSC</td><td>    AST_FUNCTION_POWER</td><td>                     AST_POWER</td></tr>
<tr><td>AST_FUNCTION_ARCCSCH</td><td>   AST_FUNCTION_QUOTIENT<sup>2</sup></td><td>      AST_RATIONAL</td></tr>
<tr><td>AST_FUNCTION_ARCSEC</td><td>    AST_FUNCTION_RATE_OF<sup>2</sup></td><td>       AST_REAL</td></tr>
<tr><td>AST_FUNCTION_ARCSECH</td><td>   AST_FUNCTION_REM<sup>2</sup></td><td>           AST_REAL_E</td></tr>
<tr><td>AST_FUNCTION_ARCSIN</td><td>    AST_FUNCTION_ROOT</td><td>                      AST_RELATIONAL_EQ</td></tr>
<tr><td>AST_FUNCTION_ARCSINH</td><td>   AST_FUNCTION_SEC</td><td>                       AST_RELATIONAL_GEQ</td></tr>
<tr><td>AST_FUNCTION_ARCTAN</td><td>    AST_FUNCTION_SECH</td><td>                      AST_RELATIONAL_GT</td></tr>
<tr><td>AST_FUNCTION_ARCTANH</td><td>   AST_FUNCTION_SIN</td><td>                       AST_RELATIONAL_LEQ</td></tr>
<tr><td>AST_FUNCTION_CEILING</td><td>   AST_FUNCTION_SINH</td><td>                      AST_RELATIONAL_LT</td></tr>
<tr><td>AST_FUNCTION_COS</td><td>       AST_FUNCTION_TAN</td><td>                       AST_RELATIONAL_NEQ</td></tr>
<tr><td>AST_FUNCTION_COSH</td><td>      AST_FUNCTION_TANH</td><td>                      AST_TIMES</td></tr>
<tr><td>AST_FUNCTION_COT</td><td>       AST_INTEGER</td><td>                            AST_UNKNOWN</td></tr>
<tr><td>AST_FUNCTION_COTH</td><td>      AST_LAMBDA</td></tr>
<tr><td><sup>1</sup> <span class='warning'><em>(Level&nbsp;3 only)</em></span><br/></td></tr>
<tr><td><sup>2</sup> <span class='warning'><em>(Level&nbsp;3 Version&nbsp;2+ only)</em></span></td></tr>
</table>


<p>The types have the following meanings:</p>
<ul>
<li>If the node is basic mathematical operator (e.g., <code>"+"</code>), then the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b5febe16514530ccf97536c0a26244d">AST_TIMES</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a11408698b7be79184ba65779128ef654">AST_DIVIDE</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203abfa0a5d49f1a260bab7663cf688e76a9">AST_POWER</a>, as appropriate.</li>
</ul>
<ul>
<li>If the node is a predefined function or operator from SBML Level&#160;1 (in the string-based formula syntax used in Level&#160;1) or SBML Level&#160;2 and&#160;3 (in the subset of MathML used in SBML Levels&#160;2 and&#160;3), then the node's type will be either <code style="margin-right: 0">AST_FUNCTION_</code><span class="placeholder-nospace">X</span>, <code style="margin-right: 0">AST_LOGICAL_</code><span class="placeholder-nospace">X</span>, or <code style="margin-right: 0">AST_RELATIONAL_</code><span class="placeholder-nospace">X</span>, as appropriate. (Examples: <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aee5ce31deca83c9d96a5888474bc0e4d">AST_FUNCTION_LOG</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aaa8b4b6cb64685254887b5a6fe81678f">AST_RELATIONAL_LEQ</a>.)</li>
</ul>
<ul>
<li>If the node refers to a user-defined function, the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> (because it holds the name of the function).</li>
</ul>
<ul>
<li>If the node is a lambda expression, its type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4703ee0d883714d334ee0d7b534f0ac9">AST_LAMBDA</a>.</li>
</ul>
<ul>
<li>If the node is a predefined constant (<code>"ExponentialE"</code>, <code>"Pi"</code>, <code>"True"</code> or <code>"False"</code>), then the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adb591fa008acf014bc037d95a6a89a69">AST_CONSTANT_E</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa94de3fb689270170a756ed428b253f6">AST_CONSTANT_PI</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ad571d2b80f4dcc08fc489960efdb2ab3">AST_CONSTANT_TRUE</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adc46a568eb6b891f72738b67da24347a">AST_CONSTANT_FALSE</a>.</li>
</ul>
<ul>
<li>(Levels&#160;2 and&#160;3 only) If the node is the special MathML csymbol <code>time</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a0358231b02f7964269ebb2e580defdf2">AST_NAME_TIME</a>. (Note, however, that the MathML csymbol <code>delay</code> is translated into a node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a1e338a4da69ff5894213bd14a3b46b91">AST_FUNCTION_DELAY</a>. The difference is due to the fact that <code>time</code> is a single variable, whereas <code>delay</code> is actually a function taking arguments.)</li>
</ul>
<ul>
<li>(Level&#160;3 only) If the node is the special MathML csymbol <code>avogadro</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a>.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is the special MathML csymbol <code>rateOf</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aedbf4bf10b748da0f71f05c1ea99080f">AST_FUNCTION_RATE_OF</a>.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is a MathML operator that originates in a package, it is included in the ASTNodeType_t list, but may not be legally used in an SBML document that does not include that package. This includes the node types from the 'Distributions' package (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a1fc325768aee9f59a93ef090eb7dc4c9">AST_DISTRIB_FUNCTION_NORMAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4ecce7aa854c8573fa6a4d5dc1a4701c">AST_DISTRIB_FUNCTION_UNIFORM</a>, etc.), and elements from MathML that were not included in core.</li>
</ul>
<ul>
<li>If the node contains a numerical value, its type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, as appropriate.</li>
</ul>
<h3><a class="anchor" id="math-convert"></a>Converting between ASTs and text strings</h3>
<p>The text-string form of mathematical formulas produced by <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a>, and read by <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> and <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> are in a simple C-inspired infix notation. A formula in this text-string form can be handed to a program that understands SBML mathematical expressions, or used as part of a translation system. The libSBML distribution comes with an example program in the <code>"examples"</code> subdirectory called <code>translateMath</code> that implements an interactive command-line demonstration of translating infix formulas into MathML and vice-versa.</p>
<p>The formula strings may contain operators, function calls, symbols, and white space characters. The allowable white space characters are tab and space. The following are illustrative examples of formulas expressed in the syntax:</p>
<pre class="fragment">0.10 * k4^2
</pre> <pre class="fragment">(vm * s1)/(km + s1)
</pre><p>The following table shows the precedence rules in this syntax. In the Class column, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the Precedence column show how the order of different types of operation are determined. For example, the expression <em>a * b + c</em> is evaluated as <em>(a * b) + c</em> because the <code>*</code> operator has higher precedence. The Associates column shows how the order of similar precedence operations is determined; for example, <em>a - b + c</em> is evaluated as <em>(a - b) + c</em> because the <code>+</code> and <code>-</code> operators are left-associative. The precedence and associativity rules are taken from the C programming language, except for the symbol <code>^</code>, which is used in C for a different purpose. (Exponentiation can be invoked using either <code>^</code> or the function <code>power</code>.)</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>A program parsing a formula in an SBML model should assume that names appearing in the formula are the identifiers of <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_function_definition.html">FunctionDefinition</a>, <a class="el" href="class_reaction.html">Reaction</a> (in SBML Levels&#160;2 and&#160;3), or <a class="el" href="class_species_reference.html">SpeciesReference</a> (in SBML Level&#160;3 only) objects defined in a model. When a function call is involved, the syntax consists of a function identifier, followed by optional white space, followed by an opening parenthesis, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis. There is an almost one-to-one mapping between the list of predefined functions available, and those defined in MathML. All of the MathML functions are recognized; this set is larger than the functions defined in SBML Level&#160;1. In the subset of functions that overlap between MathML and SBML Level&#160;1, there exist a few differences. The following table summarizes the differences between the predefined functions in SBML Level&#160;1 and the MathML equivalents in SBML Levels&#160;2 and &#160;3:</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Text string formula functions</th>
     <th align="left">MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3</th>
 </tr>
 <tr><td><code>acos</code></td><td><code>arccos</code></td></tr>
 <tr><td><code>asin</code></td><td><code>arcsin</code></td></tr>
 <tr><td><code>atan</code></td><td><code>arctan</code></td></tr>
 <tr><td><code>ceil</code></td><td><code>ceiling</code></td></tr>
 <tr><td><code>log</code></td><td><code>ln</code></td></tr>
 <tr><td><code>log10(x)</code></td><td><code>log(x)</code> or <code>log(10, x)</code></td></tr>
 <tr><td><code>pow(x, y)</code></td><td><code>power(x, y)</code></td></tr>
 <tr><td><code>sqr(x)</code></td><td><code>power(x, 2)</code></td></tr>
 <tr><td><code>sqrt(x)</code></td><td><code>root(x)</code> or <code>root(2, x)</code></td></tr>
<caption class="top-caption">Table comparing the names of certain
functions in the SBML text-string formula syntax and MathML.  The left
column shows the names of functions recognized by SBML_parseFormula(); the
right column shows their equivalent function names in MathML&nbsp;2.0, used
in SBML Levels&nbsp;2 and&nbsp;3.</caption>
</table>

<dl class="section note"><dt>Note</dt><dd>Callers using SBML Level&#160;3 are encouraged to use the facilities provided by libSBML's newer and more powerful Level&#160;3-oriented formula parser and formatter. The entry points to this second system are <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> and <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a>. The Level&#160;1-oriented system (i.e., what is provided by <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a>) is provided untouched for backwards compatibility.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> </dd>
<dd>
<a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> </dd>
<dd>
<a class="el" href="_l3_parser_8cpp.html#abb4e76b36ef84300c2901302ca5542f4" title="Parses a text string as a mathematical formula using a Model to resolve symbols, and returns an AST r...">SBML_parseL3FormulaWithModel()</a> </dd>
<dd>
<a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> </dd>
<dd>
<a class="el" href="_l3_formula_formatter_8h.html#af840d48b31961fd33c8f00a7740e49f0" title="Converts an AST to a text string representation of a formula, using specific formatter settings.">SBML_formulaToL3StringWithSettings()</a> </dd>
<dd>
<a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a> </dd>
<dd>
<a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> </dd>
<dd>
<a class="el" href="_l3_parser_8cpp.html#a1ec58150482a785c5b567d54d1c800b7" title="Returns a copy of the default Level&#160;3 (&quot;L3&quot;) formula parser settings.">SBML_getDefaultL3ParserSettings()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#_a33">createExampleSBML.cpp</a>, <a class="el" href="print_math_8cpp-example.html#_a1">printMath.cpp</a>, <a class="el" href="qual_example1_8cpp-example.html#_a46">qual_example1.cpp</a>, <a class="el" href="translate_l3_math_8cpp-example.html#_a14">translateL3Math.cpp</a>, and <a class="el" href="translate_math_8cpp-example.html#_a0">translateMath.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad699b88d62f54bce4edf94d6ffd110f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad699b88d62f54bce4edf94d6ffd110f1">addChild</a> (<a class="el" href="class_a_s_t_node.html">ASTNode</a> *disownedChild, bool inRead=false)</td></tr>
<tr class="memdesc:ad699b88d62f54bce4edf94d6ffd110f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given node as a child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#ad699b88d62f54bce4edf94d6ffd110f1">More...</a><br /></td></tr>
<tr class="separator:ad699b88d62f54bce4edf94d6ffd110f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ceb2801bb494e7581794e1ca17a71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a6e9ceb2801bb494e7581794e1ca17a71">addSemanticsAnnotation</a> (<a class="el" href="class_x_m_l_node.html">XMLNode</a> *disownedAnnotation)</td></tr>
<tr class="memdesc:a6e9ceb2801bb494e7581794e1ca17a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given <a class="el" href="class_x_m_l_node.html">XMLNode</a> as a MathML <code>&lt;semantics&gt;</code> element to this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a6e9ceb2801bb494e7581794e1ca17a71">More...</a><br /></td></tr>
<tr class="separator:a6e9ceb2801bb494e7581794e1ca17a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fe0566fc1a2483221424f4101ad06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a367fe0566fc1a2483221424f4101ad06">ASTNode</a> (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type=<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>)</td></tr>
<tr class="memdesc:a367fe0566fc1a2483221424f4101ad06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a367fe0566fc1a2483221424f4101ad06">More...</a><br /></td></tr>
<tr class="separator:a367fe0566fc1a2483221424f4101ad06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f23367254065f51fa2f2d2c74c47022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a5f23367254065f51fa2f2d2c74c47022">ASTNode</a> (const <a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;orig)</td></tr>
<tr class="memdesc:a5f23367254065f51fa2f2d2c74c47022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; creates a deep copy of the given <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a5f23367254065f51fa2f2d2c74c47022">More...</a><br /></td></tr>
<tr class="separator:a5f23367254065f51fa2f2d2c74c47022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e4e3ac084f7aa807c3d99663a76f32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a84e4e3ac084f7aa807c3d99663a76f32">ASTNode</a> (<a class="el" href="struct_token__t.html">Token_t</a> *token)</td></tr>
<tr class="memdesc:a84e4e3ac084f7aa807c3d99663a76f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_a_s_t_node.html">ASTNode</a> from the given Token.  <a href="class_a_s_t_node.html#a84e4e3ac084f7aa807c3d99663a76f32">More...</a><br /></td></tr>
<tr class="separator:a84e4e3ac084f7aa807c3d99663a76f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88091f57f7717247d0c72da41063ab1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a88091f57f7717247d0c72da41063ab1f">canonicalize</a> ()</td></tr>
<tr class="memdesc:a88091f57f7717247d0c72da41063ab1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to a canonical form and returns <code>true</code> if successful, <code>false</code> otherwise.  <a href="class_a_s_t_node.html#a88091f57f7717247d0c72da41063ab1f">More...</a><br /></td></tr>
<tr class="separator:a88091f57f7717247d0c72da41063ab1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1718696693db25031c132567b36ed1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad1718696693db25031c132567b36ed1b">decompose</a> ()</td></tr>
<tr class="memdesc:ad1718696693db25031c132567b36ed1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows decomposition of <a class="el" href="class_a_s_t_node.html">ASTNode</a> into components such that we reduce the need for brackets.  <a href="class_a_s_t_node.html#ad1718696693db25031c132567b36ed1b">More...</a><br /></td></tr>
<tr class="separator:ad1718696693db25031c132567b36ed1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e898544e22c7bb1651a63cad88e0188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a9e898544e22c7bb1651a63cad88e0188">deepCopy</a> () const</td></tr>
<tr class="memdesc:a9e898544e22c7bb1651a63cad88e0188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a recursive copy of this node and all its children.  <a href="class_a_s_t_node.html#a9e898544e22c7bb1651a63cad88e0188">More...</a><br /></td></tr>
<tr class="separator:a9e898544e22c7bb1651a63cad88e0188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc61b0ed965134978817150ef2e7036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#affc61b0ed965134978817150ef2e7036">derivative</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:affc61b0ed965134978817150ef2e7036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_a_s_t_node.html">ASTNode</a> representing the derivative of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> with respect to the given variable.  <a href="class_a_s_t_node.html#affc61b0ed965134978817150ef2e7036">More...</a><br /></td></tr>
<tr class="separator:affc61b0ed965134978817150ef2e7036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed1ea50a0c15bd65590d9e599e622f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a51ed1ea50a0c15bd65590d9e599e622f">exactlyEqual</a> (const <a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;rhs)</td></tr>
<tr class="memdesc:a51ed1ea50a0c15bd65590d9e599e622f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows two ASTNodes to be compared for exact equivilance.  <a href="class_a_s_t_node.html#a51ed1ea50a0c15bd65590d9e599e622f">More...</a><br /></td></tr>
<tr class="separator:a51ed1ea50a0c15bd65590d9e599e622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ae22da3c9e91336c6e5c40c3619148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a20ae22da3c9e91336c6e5c40c3619148">fillListOfNodes</a> (<a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a> predicate, <a class="el" href="class_list.html">List</a> *lst) const</td></tr>
<tr class="memdesc:a20ae22da3c9e91336c6e5c40c3619148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of nodes rooted at a given node and satisfying a given predicate.  <a href="class_a_s_t_node.html#a20ae22da3c9e91336c6e5c40c3619148">More...</a><br /></td></tr>
<tr class="separator:a20ae22da3c9e91336c6e5c40c3619148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e3154d02f10f3ad653529b6e4eefd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a23e3154d02f10f3ad653529b6e4eefd0">freeName</a> ()</td></tr>
<tr class="memdesc:a23e3154d02f10f3ad653529b6e4eefd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the name of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> and sets it to <code>NULL</code>.  <a href="class_a_s_t_node.html#a23e3154d02f10f3ad653529b6e4eefd0">More...</a><br /></td></tr>
<tr class="separator:a23e3154d02f10f3ad653529b6e4eefd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b9f8cbb32b029cbff6230104d45e4c"><td class="memItemLeft" align="right" valign="top">ASTBasePlugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad3b9f8cbb32b029cbff6230104d45e4c">getASTPlugin</a> (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type)</td></tr>
<tr class="memdesc:ad3b9f8cbb32b029cbff6230104d45e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package that defines the given <code>type</code>.  <a href="class_a_s_t_node.html#ad3b9f8cbb32b029cbff6230104d45e4c">More...</a><br /></td></tr>
<tr class="separator:ad3b9f8cbb32b029cbff6230104d45e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38115eb60ef56dd2bd64798bb4972792"><td class="memItemLeft" align="right" valign="top">const ASTBasePlugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a38115eb60ef56dd2bd64798bb4972792">getASTPlugin</a> (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type) const</td></tr>
<tr class="memdesc:a38115eb60ef56dd2bd64798bb4972792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package that defines the given <code>type</code>.  <a href="class_a_s_t_node.html#a38115eb60ef56dd2bd64798bb4972792">More...</a><br /></td></tr>
<tr class="separator:a38115eb60ef56dd2bd64798bb4972792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c550708c1852884fb7debbff2a4483"><td class="memItemLeft" align="right" valign="top">ASTBasePlugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a53c550708c1852884fb7debbff2a4483">getASTPlugin</a> (const <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *sbmlns)</td></tr>
<tr class="memdesc:a53c550708c1852884fb7debbff2a4483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given <code>sbmlns</code>.  <a href="class_a_s_t_node.html#a53c550708c1852884fb7debbff2a4483">More...</a><br /></td></tr>
<tr class="separator:a53c550708c1852884fb7debbff2a4483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b6fe68e3350d54fee8ac2c50a805ba"><td class="memItemLeft" align="right" valign="top">const ASTBasePlugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a24b6fe68e3350d54fee8ac2c50a805ba">getASTPlugin</a> (const <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *sbmlns) const</td></tr>
<tr class="memdesc:a24b6fe68e3350d54fee8ac2c50a805ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given <code>sbmlns</code>.  <a href="class_a_s_t_node.html#a24b6fe68e3350d54fee8ac2c50a805ba">More...</a><br /></td></tr>
<tr class="separator:a24b6fe68e3350d54fee8ac2c50a805ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ad630dda7184c47aa8d813ef9ec1f"><td class="memItemLeft" align="right" valign="top">ASTBasePlugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a7a1ad630dda7184c47aa8d813ef9ec1f">getASTPlugin</a> (const std::string &amp;name, bool isCsymbol=false, bool strCmpIsCaseSensitive=false)</td></tr>
<tr class="memdesc:a7a1ad630dda7184c47aa8d813ef9ec1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package with the given constraints.  <a href="class_a_s_t_node.html#a7a1ad630dda7184c47aa8d813ef9ec1f">More...</a><br /></td></tr>
<tr class="separator:a7a1ad630dda7184c47aa8d813ef9ec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0fd2d37140b14ac9b7b8e2b7ed7252"><td class="memItemLeft" align="right" valign="top">const ASTBasePlugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aaf0fd2d37140b14ac9b7b8e2b7ed7252">getASTPlugin</a> (const std::string &amp;name, bool isCsymbol=false, bool strCmpIsCaseSensitive=false) const</td></tr>
<tr class="memdesc:aaf0fd2d37140b14ac9b7b8e2b7ed7252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package with the given constraints.  <a href="class_a_s_t_node.html#aaf0fd2d37140b14ac9b7b8e2b7ed7252">More...</a><br /></td></tr>
<tr class="separator:aaf0fd2d37140b14ac9b7b8e2b7ed7252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119ca46b99dec97a70ae233172eb78e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af119ca46b99dec97a70ae233172eb78e">getCharacter</a> () const</td></tr>
<tr class="memdesc:af119ca46b99dec97a70ae233172eb78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of this node as a single character.  <a href="class_a_s_t_node.html#af119ca46b99dec97a70ae233172eb78e">More...</a><br /></td></tr>
<tr class="separator:af119ca46b99dec97a70ae233172eb78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8b40f63d8afb85bbe5f21b0108f53a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#afe8b40f63d8afb85bbe5f21b0108f53a">getChild</a> (unsigned int n) const</td></tr>
<tr class="memdesc:afe8b40f63d8afb85bbe5f21b0108f53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child at index n of this node.  <a href="class_a_s_t_node.html#afe8b40f63d8afb85bbe5f21b0108f53a">More...</a><br /></td></tr>
<tr class="separator:afe8b40f63d8afb85bbe5f21b0108f53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c88d603fc91ae01b519ef36a813940f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a3c88d603fc91ae01b519ef36a813940f">getClass</a> () const</td></tr>
<tr class="memdesc:a3c88d603fc91ae01b519ef36a813940f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML <code>class</code> attribute value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a3c88d603fc91ae01b519ef36a813940f">More...</a><br /></td></tr>
<tr class="separator:a3c88d603fc91ae01b519ef36a813940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04a842cd7e586cbb2ab055f111627ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab04a842cd7e586cbb2ab055f111627ba">getDefinitionURL</a> () const</td></tr>
<tr class="memdesc:ab04a842cd7e586cbb2ab055f111627ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML <code>definitionURL</code> attribute value.  <a href="class_a_s_t_node.html#ab04a842cd7e586cbb2ab055f111627ba">More...</a><br /></td></tr>
<tr class="separator:ab04a842cd7e586cbb2ab055f111627ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a712c5ac373e0ebd4de0235a96e129"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a36a712c5ac373e0ebd4de0235a96e129">getDefinitionURLString</a> () const</td></tr>
<tr class="memdesc:a36a712c5ac373e0ebd4de0235a96e129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML <code>definitionURL</code> attribute value as a string.  <a href="class_a_s_t_node.html#a36a712c5ac373e0ebd4de0235a96e129">More...</a><br /></td></tr>
<tr class="separator:a36a712c5ac373e0ebd4de0235a96e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620072b6b11a6c83943ecdfa4385f6d6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6">getDenominator</a> () const</td></tr>
<tr class="memdesc:a620072b6b11a6c83943ecdfa4385f6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the denominator of this node.  <a href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6">More...</a><br /></td></tr>
<tr class="separator:a620072b6b11a6c83943ecdfa4385f6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0466ef0434e4044c09bad81238c0f8b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ac0466ef0434e4044c09bad81238c0f8b">getExponent</a> () const</td></tr>
<tr class="memdesc:ac0466ef0434e4044c09bad81238c0f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponent value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#ac0466ef0434e4044c09bad81238c0f8b">More...</a><br /></td></tr>
<tr class="separator:ac0466ef0434e4044c09bad81238c0f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ad6caed2fcd8438ccb45af6dc8119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aaa3ad6caed2fcd8438ccb45af6dc8119">getId</a> () const</td></tr>
<tr class="memdesc:aaa3ad6caed2fcd8438ccb45af6dc8119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML <code>id</code> attribute value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#aaa3ad6caed2fcd8438ccb45af6dc8119">More...</a><br /></td></tr>
<tr class="separator:aaa3ad6caed2fcd8438ccb45af6dc8119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b0d75569f92141c9675b4791873785"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a85b0d75569f92141c9675b4791873785">getInteger</a> () const</td></tr>
<tr class="memdesc:a85b0d75569f92141c9675b4791873785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of this node as an integer.  <a href="class_a_s_t_node.html#a85b0d75569f92141c9675b4791873785">More...</a><br /></td></tr>
<tr class="separator:a85b0d75569f92141c9675b4791873785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564b600c952dce716797c1bd3c808211"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a564b600c952dce716797c1bd3c808211">getLeftChild</a> () const</td></tr>
<tr class="memdesc:a564b600c952dce716797c1bd3c808211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the left child of this node.  <a href="class_a_s_t_node.html#a564b600c952dce716797c1bd3c808211">More...</a><br /></td></tr>
<tr class="separator:a564b600c952dce716797c1bd3c808211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd4a7f16a2d38586a5829cc442b2b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a6cd4a7f16a2d38586a5829cc442b2b92">getListOfNodes</a> (<a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a> predicate) const</td></tr>
<tr class="memdesc:a6cd4a7f16a2d38586a5829cc442b2b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of nodes satisfying a given predicate.  <a href="class_a_s_t_node.html#a6cd4a7f16a2d38586a5829cc442b2b92">More...</a><br /></td></tr>
<tr class="separator:a6cd4a7f16a2d38586a5829cc442b2b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da51fb905d7460d7531893906a21a1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8da51fb905d7460d7531893906a21a1f">getMantissa</a> () const</td></tr>
<tr class="memdesc:a8da51fb905d7460d7531893906a21a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mantissa value of this node.  <a href="class_a_s_t_node.html#a8da51fb905d7460d7531893906a21a1f">More...</a><br /></td></tr>
<tr class="separator:a8da51fb905d7460d7531893906a21a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd99fd7074a2ed6e50ded3c406bfb14"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a1bd99fd7074a2ed6e50ded3c406bfb14">getName</a> () const</td></tr>
<tr class="memdesc:a1bd99fd7074a2ed6e50ded3c406bfb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of this node as a string.  <a href="class_a_s_t_node.html#a1bd99fd7074a2ed6e50ded3c406bfb14">More...</a><br /></td></tr>
<tr class="separator:a1bd99fd7074a2ed6e50ded3c406bfb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e708a632ae00f528106d413ad1cb2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2">getNumChildren</a> () const</td></tr>
<tr class="memdesc:a9c1e708a632ae00f528106d413ad1cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children of this node.  <a href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2">More...</a><br /></td></tr>
<tr class="separator:a9c1e708a632ae00f528106d413ad1cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a4868804e7e10a6cf79430723a4aee"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee">getNumerator</a> () const</td></tr>
<tr class="memdesc:a17a4868804e7e10a6cf79430723a4aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the numerator of this node if of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, or the numerical value of the node if of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>; <code>0</code> otherwise.  <a href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee">More...</a><br /></td></tr>
<tr class="separator:a17a4868804e7e10a6cf79430723a4aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51b93fa0ab9a7b5565f1a47f993f9ed"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab51b93fa0ab9a7b5565f1a47f993f9ed">getNumSemanticsAnnotations</a> () const</td></tr>
<tr class="memdesc:ab51b93fa0ab9a7b5565f1a47f993f9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of MathML <code>&lt;semantics&gt;</code> element elements on this node.  <a href="class_a_s_t_node.html#ab51b93fa0ab9a7b5565f1a47f993f9ed">More...</a><br /></td></tr>
<tr class="separator:ab51b93fa0ab9a7b5565f1a47f993f9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cd64f4d076f47b7d145cf6228c75d0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aa4cd64f4d076f47b7d145cf6228c75d0">getOperatorName</a> () const</td></tr>
<tr class="memdesc:aa4cd64f4d076f47b7d145cf6228c75d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of this operator node as a string.  <a href="class_a_s_t_node.html#aa4cd64f4d076f47b7d145cf6228c75d0">More...</a><br /></td></tr>
<tr class="separator:aa4cd64f4d076f47b7d145cf6228c75d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e12c3633f7d19f03523925ff845aa91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a3e12c3633f7d19f03523925ff845aa91">getParentSBMLObject</a> () const</td></tr>
<tr class="memdesc:a3e12c3633f7d19f03523925ff845aa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent SBML object.  <a href="class_a_s_t_node.html#a3e12c3633f7d19f03523925ff845aa91">More...</a><br /></td></tr>
<tr class="separator:a3e12c3633f7d19f03523925ff845aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc4d19ef98ca44c7520cc3a6d02debe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aafc4d19ef98ca44c7520cc3a6d02debe">getPrecedence</a> () const</td></tr>
<tr class="memdesc:aafc4d19ef98ca44c7520cc3a6d02debe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the precedence of this node in the infix math syntax of SBML Level&#160;1.  <a href="class_a_s_t_node.html#aafc4d19ef98ca44c7520cc3a6d02debe">More...</a><br /></td></tr>
<tr class="separator:aafc4d19ef98ca44c7520cc3a6d02debe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d737e799a7c6b9757fd03abed50b580"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a9d737e799a7c6b9757fd03abed50b580">getReal</a> () const</td></tr>
<tr class="memdesc:a9d737e799a7c6b9757fd03abed50b580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real-numbered value of this node.  <a href="class_a_s_t_node.html#a9d737e799a7c6b9757fd03abed50b580">More...</a><br /></td></tr>
<tr class="separator:a9d737e799a7c6b9757fd03abed50b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ece8fdb8c21f299c61f6c9f537b2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ac5ece8fdb8c21f299c61f6c9f537b2e1">getRightChild</a> () const</td></tr>
<tr class="memdesc:ac5ece8fdb8c21f299c61f6c9f537b2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right child of this node.  <a href="class_a_s_t_node.html#ac5ece8fdb8c21f299c61f6c9f537b2e1">More...</a><br /></td></tr>
<tr class="separator:ac5ece8fdb8c21f299c61f6c9f537b2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98550575c764a4617651d5f311cea65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ac98550575c764a4617651d5f311cea65">getSemanticsAnnotation</a> (unsigned int n) const</td></tr>
<tr class="memdesc:ac98550575c764a4617651d5f311cea65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth MathML <code>&lt;semantics&gt;</code> element on this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#ac98550575c764a4617651d5f311cea65">More...</a><br /></td></tr>
<tr class="separator:ac98550575c764a4617651d5f311cea65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154b2a892c2a843dbc31b593cbf35863"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a154b2a892c2a843dbc31b593cbf35863">getStyle</a> () const</td></tr>
<tr class="memdesc:a154b2a892c2a843dbc31b593cbf35863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MathML <code>style</code> attribute value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a154b2a892c2a843dbc31b593cbf35863">More...</a><br /></td></tr>
<tr class="separator:a154b2a892c2a843dbc31b593cbf35863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa934fcde1d07f0f1c061b9dd06f6afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb">getType</a> () const</td></tr>
<tr class="memdesc:aaa934fcde1d07f0f1c061b9dd06f6afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb">More...</a><br /></td></tr>
<tr class="separator:aaa934fcde1d07f0f1c061b9dd06f6afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45272cdd7ee4623d3818fe154b8926c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a45272cdd7ee4623d3818fe154b8926c4">getUnits</a> () const</td></tr>
<tr class="memdesc:a45272cdd7ee4623d3818fe154b8926c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a45272cdd7ee4623d3818fe154b8926c4">More...</a><br /></td></tr>
<tr class="separator:a45272cdd7ee4623d3818fe154b8926c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8763e789cfeb52b130c84567684b7af"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad8763e789cfeb52b130c84567684b7af">getUserData</a> () const</td></tr>
<tr class="memdesc:ad8763e789cfeb52b130c84567684b7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user data that has been previously set via <a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node.">setUserData()</a>.  <a href="class_a_s_t_node.html#ad8763e789cfeb52b130c84567684b7af">More...</a><br /></td></tr>
<tr class="separator:ad8763e789cfeb52b130c84567684b7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a3566e33b2144ce527c727ec9cdfa6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a51a3566e33b2144ce527c727ec9cdfa6">getValue</a> () const</td></tr>
<tr class="memdesc:a51a3566e33b2144ce527c727ec9cdfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a51a3566e33b2144ce527c727ec9cdfa6">More...</a><br /></td></tr>
<tr class="separator:a51a3566e33b2144ce527c727ec9cdfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0918a907b923f9cb179c9bfa5e5601b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a0918a907b923f9cb179c9bfa5e5601b8">hasCorrectNumberArguments</a> () const</td></tr>
<tr class="memdesc:a0918a907b923f9cb179c9bfa5e5601b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has the correct number of children for its type.  <a href="class_a_s_t_node.html#a0918a907b923f9cb179c9bfa5e5601b8">More...</a><br /></td></tr>
<tr class="separator:a0918a907b923f9cb179c9bfa5e5601b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849d09de351d5dea81c10e2fc1dad518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a849d09de351d5dea81c10e2fc1dad518">hasTypeAndNumChildren</a> (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type, unsigned int numchildren) const</td></tr>
<tr class="memdesc:a849d09de351d5dea81c10e2fc1dad518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node is of type <code>type</code> and has <code>numchildren</code> number of children.  <a href="class_a_s_t_node.html#a849d09de351d5dea81c10e2fc1dad518">More...</a><br /></td></tr>
<tr class="separator:a849d09de351d5dea81c10e2fc1dad518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb708bfee4e451fbbad004b49060969d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#abb708bfee4e451fbbad004b49060969d">hasUnits</a> () const</td></tr>
<tr class="memdesc:abb708bfee4e451fbbad004b49060969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node or any of its children nodes have the attribute <code>sbml:units</code>.  <a href="class_a_s_t_node.html#abb708bfee4e451fbbad004b49060969d">More...</a><br /></td></tr>
<tr class="separator:abb708bfee4e451fbbad004b49060969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb6b332df118a1dfd3576b84f1c6e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8ceb6b332df118a1dfd3576b84f1c6e4">insertChild</a> (unsigned int n, <a class="el" href="class_a_s_t_node.html">ASTNode</a> *disownedChild)</td></tr>
<tr class="memdesc:a8ceb6b332df118a1dfd3576b84f1c6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given <a class="el" href="class_a_s_t_node.html">ASTNode</a> at point n in the list of children of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a8ceb6b332df118a1dfd3576b84f1c6e4">More...</a><br /></td></tr>
<tr class="separator:a8ceb6b332df118a1dfd3576b84f1c6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f8d160f54baccda099f00d4c0925dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a91f8d160f54baccda099f00d4c0925dd">isAvogadro</a> () const</td></tr>
<tr class="memdesc:a91f8d160f54baccda099f00d4c0925dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node is the special symbol <code>avogadro</code>.  <a href="class_a_s_t_node.html#a91f8d160f54baccda099f00d4c0925dd">More...</a><br /></td></tr>
<tr class="separator:a91f8d160f54baccda099f00d4c0925dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53001b84f9ea746a3caa12e4346c5e07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a53001b84f9ea746a3caa12e4346c5e07">isBoolean</a> () const</td></tr>
<tr class="memdesc:a53001b84f9ea746a3caa12e4346c5e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node has a Boolean type.  <a href="class_a_s_t_node.html#a53001b84f9ea746a3caa12e4346c5e07">More...</a><br /></td></tr>
<tr class="separator:a53001b84f9ea746a3caa12e4346c5e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae100c13f6e5e073180fa8fa44752331d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ae100c13f6e5e073180fa8fa44752331d">isCiNumber</a> () const</td></tr>
<tr class="memdesc:ae100c13f6e5e073180fa8fa44752331d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a MathML ci element representing a value not a function (e.g., <code>true</code>, <code>Pi</code>).  <a href="class_a_s_t_node.html#ae100c13f6e5e073180fa8fa44752331d">More...</a><br /></td></tr>
<tr class="separator:ae100c13f6e5e073180fa8fa44752331d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b42abf93fc6056c53c31d77bfe05583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8b42abf93fc6056c53c31d77bfe05583">isConstant</a> () const</td></tr>
<tr class="memdesc:a8b42abf93fc6056c53c31d77bfe05583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a MathML constant (e.g., <code>true</code>, <code>Pi</code>).  <a href="class_a_s_t_node.html#a8b42abf93fc6056c53c31d77bfe05583">More...</a><br /></td></tr>
<tr class="separator:a8b42abf93fc6056c53c31d77bfe05583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f9924cbd69933cde0cdc8b4ec364ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a12f9924cbd69933cde0cdc8b4ec364ff">isConstantNumber</a> () const</td></tr>
<tr class="memdesc:a12f9924cbd69933cde0cdc8b4ec364ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a MathML constant with numeric value (e.g., <code>Pi</code>).  <a href="class_a_s_t_node.html#a12f9924cbd69933cde0cdc8b4ec364ff">More...</a><br /></td></tr>
<tr class="separator:a12f9924cbd69933cde0cdc8b4ec364ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f92f2725acc86d0d0552c946a50eb34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a6f92f2725acc86d0d0552c946a50eb34">isCSymbolFunction</a> () const</td></tr>
<tr class="memdesc:a6f92f2725acc86d0d0552c946a50eb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a MathML csymbol representing a function.  <a href="class_a_s_t_node.html#a6f92f2725acc86d0d0552c946a50eb34">More...</a><br /></td></tr>
<tr class="separator:a6f92f2725acc86d0d0552c946a50eb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3758a3436b2a65fc366db36f877b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a55a3758a3436b2a65fc366db36f877b7">isFunction</a> () const</td></tr>
<tr class="memdesc:a55a3758a3436b2a65fc366db36f877b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node represents a function.  <a href="class_a_s_t_node.html#a55a3758a3436b2a65fc366db36f877b7">More...</a><br /></td></tr>
<tr class="separator:a55a3758a3436b2a65fc366db36f877b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae990bb9bc7c1ee85435ea631c32fd090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ae990bb9bc7c1ee85435ea631c32fd090">isInfinity</a> () const</td></tr>
<tr class="memdesc:ae990bb9bc7c1ee85435ea631c32fd090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents the special IEEE 754 value infinity, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#ae990bb9bc7c1ee85435ea631c32fd090">More...</a><br /></td></tr>
<tr class="separator:ae990bb9bc7c1ee85435ea631c32fd090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc100c11710945c43c8c90f6cd95a3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a0dc100c11710945c43c8c90f6cd95a3a">isInteger</a> () const</td></tr>
<tr class="memdesc:a0dc100c11710945c43c8c90f6cd95a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node contains an integer value, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#a0dc100c11710945c43c8c90f6cd95a3a">More...</a><br /></td></tr>
<tr class="separator:a0dc100c11710945c43c8c90f6cd95a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985209cb471d6ab7de66e490b3951557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a985209cb471d6ab7de66e490b3951557">isLambda</a> () const</td></tr>
<tr class="memdesc:a985209cb471d6ab7de66e490b3951557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node is a MathML <code>&lt;lambda&gt;</code>, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#a985209cb471d6ab7de66e490b3951557">More...</a><br /></td></tr>
<tr class="separator:a985209cb471d6ab7de66e490b3951557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fc55100fe51edc783350bc748606aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a16fc55100fe51edc783350bc748606aa">isLog10</a> () const</td></tr>
<tr class="memdesc:a16fc55100fe51edc783350bc748606aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a <code>log10</code> function, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#a16fc55100fe51edc783350bc748606aa">More...</a><br /></td></tr>
<tr class="separator:a16fc55100fe51edc783350bc748606aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57abffc95ec4be0b303b2b7f35aa320f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a57abffc95ec4be0b303b2b7f35aa320f">isLogical</a> () const</td></tr>
<tr class="memdesc:a57abffc95ec4be0b303b2b7f35aa320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node is a MathML logical operator.  <a href="class_a_s_t_node.html#a57abffc95ec4be0b303b2b7f35aa320f">More...</a><br /></td></tr>
<tr class="separator:a57abffc95ec4be0b303b2b7f35aa320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1b8ddefb172315469f56761c0555bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a5e1b8ddefb172315469f56761c0555bc">isName</a> () const</td></tr>
<tr class="memdesc:a5e1b8ddefb172315469f56761c0555bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node is a user-defined variable name or the symbols for time or Avogadro's constant.  <a href="class_a_s_t_node.html#a5e1b8ddefb172315469f56761c0555bc">More...</a><br /></td></tr>
<tr class="separator:a5e1b8ddefb172315469f56761c0555bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2d44197245921e23ddb263c1050b96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#afa2d44197245921e23ddb263c1050b96">isNaN</a> () const</td></tr>
<tr class="memdesc:afa2d44197245921e23ddb263c1050b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents the special IEEE 754 value "not a number" (NaN), <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#afa2d44197245921e23ddb263c1050b96">More...</a><br /></td></tr>
<tr class="separator:afa2d44197245921e23ddb263c1050b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac750afc0c08e4bfc94c20de095ba909b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ac750afc0c08e4bfc94c20de095ba909b">isNegInfinity</a> () const</td></tr>
<tr class="memdesc:ac750afc0c08e4bfc94c20de095ba909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents the special IEEE 754 value "negative infinity", <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#ac750afc0c08e4bfc94c20de095ba909b">More...</a><br /></td></tr>
<tr class="separator:ac750afc0c08e4bfc94c20de095ba909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb9fc75b2bd81663512ebce1886e4da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aefb9fc75b2bd81663512ebce1886e4da">isNumber</a> () const</td></tr>
<tr class="memdesc:aefb9fc75b2bd81663512ebce1886e4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node contains a number, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#aefb9fc75b2bd81663512ebce1886e4da">More...</a><br /></td></tr>
<tr class="separator:aefb9fc75b2bd81663512ebce1886e4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d167168f1e9d062fd3f8f5f8cad951e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a7d167168f1e9d062fd3f8f5f8cad951e">isOperator</a> () const</td></tr>
<tr class="memdesc:a7d167168f1e9d062fd3f8f5f8cad951e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node is a mathematical operator.  <a href="class_a_s_t_node.html#a7d167168f1e9d062fd3f8f5f8cad951e">More...</a><br /></td></tr>
<tr class="separator:a7d167168f1e9d062fd3f8f5f8cad951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ea7bf8180435b1a3fdd260a3b0d886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a82ea7bf8180435b1a3fdd260a3b0d886">isPiecewise</a> () const</td></tr>
<tr class="memdesc:a82ea7bf8180435b1a3fdd260a3b0d886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node is the MathML <code>&lt;piecewise&gt;</code> construct.  <a href="class_a_s_t_node.html#a82ea7bf8180435b1a3fdd260a3b0d886">More...</a><br /></td></tr>
<tr class="separator:a82ea7bf8180435b1a3fdd260a3b0d886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08e12a04ae2c49ee0c107121dea136a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab08e12a04ae2c49ee0c107121dea136a">isRational</a> () const</td></tr>
<tr class="memdesc:ab08e12a04ae2c49ee0c107121dea136a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a rational number.  <a href="class_a_s_t_node.html#ab08e12a04ae2c49ee0c107121dea136a">More...</a><br /></td></tr>
<tr class="separator:ab08e12a04ae2c49ee0c107121dea136a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af089ab6a15a5749545471c57c717c5a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af089ab6a15a5749545471c57c717c5a3">isReal</a> () const</td></tr>
<tr class="memdesc:af089ab6a15a5749545471c57c717c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node can represent a real number, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#af089ab6a15a5749545471c57c717c5a3">More...</a><br /></td></tr>
<tr class="separator:af089ab6a15a5749545471c57c717c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e3de3540380c4f9af73bb8ccf7c79d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a75e3de3540380c4f9af73bb8ccf7c79d">isRelational</a> () const</td></tr>
<tr class="memdesc:a75e3de3540380c4f9af73bb8ccf7c79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node is a MathML relational operator.  <a href="class_a_s_t_node.html#a75e3de3540380c4f9af73bb8ccf7c79d">More...</a><br /></td></tr>
<tr class="separator:a75e3de3540380c4f9af73bb8ccf7c79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b025a12c1a5b30630a9c9ba3f555225"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a5b025a12c1a5b30630a9c9ba3f555225">isSetClass</a> () const</td></tr>
<tr class="memdesc:a5b025a12c1a5b30630a9c9ba3f555225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node has a value for the MathML attribute "class".  <a href="class_a_s_t_node.html#a5b025a12c1a5b30630a9c9ba3f555225">More...</a><br /></td></tr>
<tr class="separator:a5b025a12c1a5b30630a9c9ba3f555225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d7af6077c4c113057f82cd5c43c735"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a98d7af6077c4c113057f82cd5c43c735">isSetId</a> () const</td></tr>
<tr class="memdesc:a98d7af6077c4c113057f82cd5c43c735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node has a value for the MathML attribute "id".  <a href="class_a_s_t_node.html#a98d7af6077c4c113057f82cd5c43c735">More...</a><br /></td></tr>
<tr class="separator:a98d7af6077c4c113057f82cd5c43c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63be31576eef23de0a5f2e40b48b6aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a63be31576eef23de0a5f2e40b48b6aee">isSetParentSBMLObject</a> () const</td></tr>
<tr class="memdesc:a63be31576eef23de0a5f2e40b48b6aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node has a value for the parent SBML object.  <a href="class_a_s_t_node.html#a63be31576eef23de0a5f2e40b48b6aee">More...</a><br /></td></tr>
<tr class="separator:a63be31576eef23de0a5f2e40b48b6aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a21ef4d79d048d8cf13d5ac83cab562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a1a21ef4d79d048d8cf13d5ac83cab562">isSetStyle</a> () const</td></tr>
<tr class="memdesc:a1a21ef4d79d048d8cf13d5ac83cab562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node has a value for the MathML attribute "style".  <a href="class_a_s_t_node.html#a1a21ef4d79d048d8cf13d5ac83cab562">More...</a><br /></td></tr>
<tr class="separator:a1a21ef4d79d048d8cf13d5ac83cab562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00bda7e722f821e727176ef18ca4ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a9a00bda7e722f821e727176ef18ca4ae">isSetUnits</a> () const</td></tr>
<tr class="memdesc:a9a00bda7e722f821e727176ef18ca4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node has the attribute <code>sbml:units</code>.  <a href="class_a_s_t_node.html#a9a00bda7e722f821e727176ef18ca4ae">More...</a><br /></td></tr>
<tr class="separator:a9a00bda7e722f821e727176ef18ca4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a009ade5d3e0bcf0ccd9f7598708a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aa50a009ade5d3e0bcf0ccd9f7598708a">isSetUserData</a> () const</td></tr>
<tr class="memdesc:aa50a009ade5d3e0bcf0ccd9f7598708a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this node has a user data object.  <a href="class_a_s_t_node.html#aa50a009ade5d3e0bcf0ccd9f7598708a">More...</a><br /></td></tr>
<tr class="separator:aa50a009ade5d3e0bcf0ccd9f7598708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b4f4926633a26a8a028cd1b0715be9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a38b4f4926633a26a8a028cd1b0715be9">isSqrt</a> () const</td></tr>
<tr class="memdesc:a38b4f4926633a26a8a028cd1b0715be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a square root function, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#a38b4f4926633a26a8a028cd1b0715be9">More...</a><br /></td></tr>
<tr class="separator:a38b4f4926633a26a8a028cd1b0715be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3324f1e9873236c540bc1f930881db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a2b3324f1e9873236c540bc1f930881db">isUMinus</a> () const</td></tr>
<tr class="memdesc:a2b3324f1e9873236c540bc1f930881db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node is a unary minus operator, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#a2b3324f1e9873236c540bc1f930881db">More...</a><br /></td></tr>
<tr class="separator:a2b3324f1e9873236c540bc1f930881db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7868d8333ea7a206e128e5a928d8477e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a7868d8333ea7a206e128e5a928d8477e">isUnknown</a> () const</td></tr>
<tr class="memdesc:a7868d8333ea7a206e128e5a928d8477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node has an unknown type.  <a href="class_a_s_t_node.html#a7868d8333ea7a206e128e5a928d8477e">More...</a><br /></td></tr>
<tr class="separator:a7868d8333ea7a206e128e5a928d8477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b7ceefbd7e08edb1e598100766b218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af8b7ceefbd7e08edb1e598100766b218">isUPlus</a> () const</td></tr>
<tr class="memdesc:af8b7ceefbd7e08edb1e598100766b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node is a unary plus operator, <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#af8b7ceefbd7e08edb1e598100766b218">More...</a><br /></td></tr>
<tr class="separator:af8b7ceefbd7e08edb1e598100766b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78de5315974132247f9ddfd7a96d2124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a78de5315974132247f9ddfd7a96d2124">isUserFunction</a> () const</td></tr>
<tr class="memdesc:a78de5315974132247f9ddfd7a96d2124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node represents a MathML user-defined function.  <a href="class_a_s_t_node.html#a78de5315974132247f9ddfd7a96d2124">More...</a><br /></td></tr>
<tr class="separator:a78de5315974132247f9ddfd7a96d2124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cc27f060b99173529b20e6ba770b2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab6cc27f060b99173529b20e6ba770b2a">isWellFormedASTNode</a> () const</td></tr>
<tr class="memdesc:ab6cc27f060b99173529b20e6ba770b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> or <code>false</code> depending on whether this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is well-formed.  <a href="class_a_s_t_node.html#ab6cc27f060b99173529b20e6ba770b2a">More...</a><br /></td></tr>
<tr class="separator:ab6cc27f060b99173529b20e6ba770b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15cbd49549142db74fffa17555c5a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af15cbd49549142db74fffa17555c5a68">operator=</a> (const <a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;rhs)</td></tr>
<tr class="memdesc:af15cbd49549142db74fffa17555c5a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#af15cbd49549142db74fffa17555c5a68">More...</a><br /></td></tr>
<tr class="separator:af15cbd49549142db74fffa17555c5a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fec7e37689b7119846815c7f9108a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8">prependChild</a> (<a class="el" href="class_a_s_t_node.html">ASTNode</a> *disownedChild)</td></tr>
<tr class="memdesc:a27fec7e37689b7119846815c7f9108a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given node as a child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8">More...</a><br /></td></tr>
<tr class="separator:a27fec7e37689b7119846815c7f9108a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645bd2cc1e1f1be0620a6742e7828ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a645bd2cc1e1f1be0620a6742e7828ded">reduceToBinary</a> ()</td></tr>
<tr class="memdesc:a645bd2cc1e1f1be0620a6742e7828ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to a binary tree.  <a href="class_a_s_t_node.html#a645bd2cc1e1f1be0620a6742e7828ded">More...</a><br /></td></tr>
<tr class="separator:a645bd2cc1e1f1be0620a6742e7828ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f778795d2a475489457bbb1fd5a236f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a9f778795d2a475489457bbb1fd5a236f">refactor</a> ()</td></tr>
<tr class="memdesc:a9f778795d2a475489457bbb1fd5a236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function refactors an <a class="el" href="class_a_s_t_node.html">ASTNode</a> to facilitate the use of the algorithm to construct a reaction network from a set of ordinary differential equations.  <a href="class_a_s_t_node.html#a9f778795d2a475489457bbb1fd5a236f">More...</a><br /></td></tr>
<tr class="separator:a9f778795d2a475489457bbb1fd5a236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970e2b320c25a7a15877061e6a7b77c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a970e2b320c25a7a15877061e6a7b77c8">removeChild</a> (unsigned int n, bool delremoved=false)</td></tr>
<tr class="memdesc:a970e2b320c25a7a15877061e6a7b77c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object.  <a href="class_a_s_t_node.html#a970e2b320c25a7a15877061e6a7b77c8">More...</a><br /></td></tr>
<tr class="separator:a970e2b320c25a7a15877061e6a7b77c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aeed21872f18dfc11c3d2de1df88c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab7aeed21872f18dfc11c3d2de1df88c5">renameSIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="memdesc:ab7aeed21872f18dfc11c3d2de1df88c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames all the SIdRef attributes on this node and any child node.  <a href="class_a_s_t_node.html#ab7aeed21872f18dfc11c3d2de1df88c5">More...</a><br /></td></tr>
<tr class="separator:ab7aeed21872f18dfc11c3d2de1df88c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7055132d2fc71c9dd01dbe2ca1d968"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aef7055132d2fc71c9dd01dbe2ca1d968">renameUnitSIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="memdesc:aef7055132d2fc71c9dd01dbe2ca1d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames all the UnitSIdRef attributes on this node and any child node.  <a href="class_a_s_t_node.html#aef7055132d2fc71c9dd01dbe2ca1d968">More...</a><br /></td></tr>
<tr class="separator:aef7055132d2fc71c9dd01dbe2ca1d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93483fdf785bde427dfe0aadddd114d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad93483fdf785bde427dfe0aadddd114d">replaceArgument</a> (const std::string &amp;bvar, <a class="el" href="class_a_s_t_node.html">ASTNode</a> *arg)</td></tr>
<tr class="memdesc:ad93483fdf785bde427dfe0aadddd114d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences of a given name with a given <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#ad93483fdf785bde427dfe0aadddd114d">More...</a><br /></td></tr>
<tr class="separator:ad93483fdf785bde427dfe0aadddd114d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca4ad8fe4bf312d64872a9ebdc6334a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a3ca4ad8fe4bf312d64872a9ebdc6334a">replaceArguments</a> (const std::vector&lt; std::string &gt; &amp;bvars, std::vector&lt; <a class="el" href="class_a_s_t_node.html">ASTNode</a> * &gt; &amp;args)</td></tr>
<tr class="memdesc:a3ca4ad8fe4bf312d64872a9ebdc6334a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences of each given name with the corresponding <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a3ca4ad8fe4bf312d64872a9ebdc6334a">More...</a><br /></td></tr>
<tr class="separator:a3ca4ad8fe4bf312d64872a9ebdc6334a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c49267ec3f8d4d6f69126d89b7a9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a050c49267ec3f8d4d6f69126d89b7a9f">replaceChild</a> (unsigned int n, <a class="el" href="class_a_s_t_node.html">ASTNode</a> *disownedChild, bool delreplaced=false)</td></tr>
<tr class="memdesc:a050c49267ec3f8d4d6f69126d89b7a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces and optionally deletes the nth child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> with the given <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a050c49267ec3f8d4d6f69126d89b7a9f">More...</a><br /></td></tr>
<tr class="separator:a050c49267ec3f8d4d6f69126d89b7a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c15eabddaca79ab5b24d40014ae8710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a4c15eabddaca79ab5b24d40014ae8710">returnsBoolean</a> (const <a class="el" href="class_model.html">Model</a> *model=NULL) const</td></tr>
<tr class="memdesc:a4c15eabddaca79ab5b24d40014ae8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> (nonzero) if this node returns a Boolean type or <code>false</code> (zero) otherwise.  <a href="class_a_s_t_node.html#a4c15eabddaca79ab5b24d40014ae8710">More...</a><br /></td></tr>
<tr class="separator:a4c15eabddaca79ab5b24d40014ae8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494556fb0158d211598dd94d12ec05d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a5494556fb0158d211598dd94d12ec05d">setCharacter</a> (char value)</td></tr>
<tr class="memdesc:a5494556fb0158d211598dd94d12ec05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given character.  <a href="class_a_s_t_node.html#a5494556fb0158d211598dd94d12ec05d">More...</a><br /></td></tr>
<tr class="separator:a5494556fb0158d211598dd94d12ec05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fc605d22e1fb0fce89d7248ff84499"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af7fc605d22e1fb0fce89d7248ff84499">setClass</a> (const std::string &amp;className)</td></tr>
<tr class="memdesc:af7fc605d22e1fb0fce89d7248ff84499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML attribute <code>class</code> of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to <code>className</code>.  <a href="class_a_s_t_node.html#af7fc605d22e1fb0fce89d7248ff84499">More...</a><br /></td></tr>
<tr class="separator:af7fc605d22e1fb0fce89d7248ff84499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5715b8f4795e2b06c7264559d987d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a97e5715b8f4795e2b06c7264559d987d">setId</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a97e5715b8f4795e2b06c7264559d987d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML attribute <code>id</code> of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a97e5715b8f4795e2b06c7264559d987d">More...</a><br /></td></tr>
<tr class="separator:a97e5715b8f4795e2b06c7264559d987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b45c89bbe89ac83d7139653609c30ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8b45c89bbe89ac83d7139653609c30ba">setName</a> (const char *name)</td></tr>
<tr class="memdesc:a8b45c89bbe89ac83d7139653609c30ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given name.  <a href="class_a_s_t_node.html#a8b45c89bbe89ac83d7139653609c30ba">More...</a><br /></td></tr>
<tr class="separator:a8b45c89bbe89ac83d7139653609c30ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d61b07a24f76637ad58eeb70acf8dbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a2d61b07a24f76637ad58eeb70acf8dbc">setStyle</a> (const std::string &amp;style)</td></tr>
<tr class="memdesc:a2d61b07a24f76637ad58eeb70acf8dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MathML attribute <code>style</code> of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to style.  <a href="class_a_s_t_node.html#a2d61b07a24f76637ad58eeb70acf8dbc">More...</a><br /></td></tr>
<tr class="separator:a2d61b07a24f76637ad58eeb70acf8dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bad16b57e7c27da4f3110cffdc06ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a08bad16b57e7c27da4f3110cffdc06ff">setType</a> (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> type)</td></tr>
<tr class="memdesc:a08bad16b57e7c27da4f3110cffdc06ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given type code.  <a href="class_a_s_t_node.html#a08bad16b57e7c27da4f3110cffdc06ff">More...</a><br /></td></tr>
<tr class="separator:a08bad16b57e7c27da4f3110cffdc06ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e96aa0f6056f3749d401b6fb3bd4371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8e96aa0f6056f3749d401b6fb3bd4371">setUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:a8e96aa0f6056f3749d401b6fb3bd4371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to units.  <a href="class_a_s_t_node.html#a8e96aa0f6056f3749d401b6fb3bd4371">More...</a><br /></td></tr>
<tr class="separator:a8e96aa0f6056f3749d401b6fb3bd4371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae163e5a31a74d62c665db0b9704220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:adae163e5a31a74d62c665db0b9704220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the user data of this node.  <a href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220">More...</a><br /></td></tr>
<tr class="separator:adae163e5a31a74d62c665db0b9704220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad672b2de729eaf8aa813234d15e15efa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad672b2de729eaf8aa813234d15e15efa">setValue</a> (double mantissa, long exponent)</td></tr>
<tr class="memdesc:ad672b2de729eaf8aa813234d15e15efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given real (<code>double</code>) in two parts: the mantissa and the exponent.  <a href="class_a_s_t_node.html#ad672b2de729eaf8aa813234d15e15efa">More...</a><br /></td></tr>
<tr class="separator:ad672b2de729eaf8aa813234d15e15efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dad5ffb929e5f42955b57357902557"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a49dad5ffb929e5f42955b57357902557">setValue</a> (double value)</td></tr>
<tr class="memdesc:a49dad5ffb929e5f42955b57357902557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given real (<code>double</code>) and sets the node type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>.  <a href="class_a_s_t_node.html#a49dad5ffb929e5f42955b57357902557">More...</a><br /></td></tr>
<tr class="separator:a49dad5ffb929e5f42955b57357902557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69097fbcbc9e0771573472049e249784"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a69097fbcbc9e0771573472049e249784">setValue</a> (int value)</td></tr>
<tr class="memdesc:a69097fbcbc9e0771573472049e249784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given integer and sets the node type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>.  <a href="class_a_s_t_node.html#a69097fbcbc9e0771573472049e249784">More...</a><br /></td></tr>
<tr class="separator:a69097fbcbc9e0771573472049e249784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af450115d10253bc42acaf39801c5a173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af450115d10253bc42acaf39801c5a173">setValue</a> (long numerator, long denominator)</td></tr>
<tr class="memdesc:af450115d10253bc42acaf39801c5a173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given rational in two parts: the numerator and denominator.  <a href="class_a_s_t_node.html#af450115d10253bc42acaf39801c5a173">More...</a><br /></td></tr>
<tr class="separator:af450115d10253bc42acaf39801c5a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d4ced59cd23b76e0c332afe20ab0f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a38d4ced59cd23b76e0c332afe20ab0f3">setValue</a> (long value)</td></tr>
<tr class="memdesc:a38d4ced59cd23b76e0c332afe20ab0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given (<code>long</code>) integer and sets the node type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>.  <a href="class_a_s_t_node.html#a38d4ced59cd23b76e0c332afe20ab0f3">More...</a><br /></td></tr>
<tr class="separator:a38d4ced59cd23b76e0c332afe20ab0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15b06fa2fc77b84b05b26b5fdbebf23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aa15b06fa2fc77b84b05b26b5fdbebf23">swapChildren</a> (<a class="el" href="class_a_s_t_node.html">ASTNode</a> *that)</td></tr>
<tr class="memdesc:aa15b06fa2fc77b84b05b26b5fdbebf23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the children of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object with the children of the given <a class="el" href="class_a_s_t_node.html">ASTNode</a> object.  <a href="class_a_s_t_node.html#aa15b06fa2fc77b84b05b26b5fdbebf23">More...</a><br /></td></tr>
<tr class="separator:aa15b06fa2fc77b84b05b26b5fdbebf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e62030f74c9867ae6ddf2eab40b5ad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a1e62030f74c9867ae6ddf2eab40b5ad9">unsetClass</a> ()</td></tr>
<tr class="memdesc:a1e62030f74c9867ae6ddf2eab40b5ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the MathML <code>class</code> attribute of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a1e62030f74c9867ae6ddf2eab40b5ad9">More...</a><br /></td></tr>
<tr class="separator:a1e62030f74c9867ae6ddf2eab40b5ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38962e67843d2841404e68f87d77b722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a38962e67843d2841404e68f87d77b722">unsetId</a> ()</td></tr>
<tr class="memdesc:a38962e67843d2841404e68f87d77b722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the MathML <code>id</code> attribute of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a38962e67843d2841404e68f87d77b722">More...</a><br /></td></tr>
<tr class="separator:a38962e67843d2841404e68f87d77b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0713a2137fcbd3e9c4beb0e15276f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a2ba0713a2137fcbd3e9c4beb0e15276f">unsetParentSBMLObject</a> ()</td></tr>
<tr class="memdesc:a2ba0713a2137fcbd3e9c4beb0e15276f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the parent SBML object.  <a href="class_a_s_t_node.html#a2ba0713a2137fcbd3e9c4beb0e15276f">More...</a><br /></td></tr>
<tr class="separator:a2ba0713a2137fcbd3e9c4beb0e15276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2be455b1eacf4e6854d5d10e36ab99a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af2be455b1eacf4e6854d5d10e36ab99a">unsetStyle</a> ()</td></tr>
<tr class="memdesc:af2be455b1eacf4e6854d5d10e36ab99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the MathML <code>style</code> attribute of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#af2be455b1eacf4e6854d5d10e36ab99a">More...</a><br /></td></tr>
<tr class="separator:af2be455b1eacf4e6854d5d10e36ab99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e20dfaf0e5e299e906e2bc5e6966527"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8e20dfaf0e5e299e906e2bc5e6966527">unsetUnits</a> ()</td></tr>
<tr class="memdesc:a8e20dfaf0e5e299e906e2bc5e6966527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.  <a href="class_a_s_t_node.html#a8e20dfaf0e5e299e906e2bc5e6966527">More...</a><br /></td></tr>
<tr class="separator:a8e20dfaf0e5e299e906e2bc5e6966527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7f8301b10f3aed387a447473650ed5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a8d7f8301b10f3aed387a447473650ed5">unsetUserData</a> ()</td></tr>
<tr class="memdesc:a8d7f8301b10f3aed387a447473650ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the user data of this node.  <a href="class_a_s_t_node.html#a8d7f8301b10f3aed387a447473650ed5">More...</a><br /></td></tr>
<tr class="separator:a8d7f8301b10f3aed387a447473650ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a691f37fa038eb183280effeb8ba4e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a41a691f37fa038eb183280effeb8ba4e">~ASTNode</a> ()</td></tr>
<tr class="memdesc:a41a691f37fa038eb183280effeb8ba4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, including any child nodes.  <a href="class_a_s_t_node.html#a41a691f37fa038eb183280effeb8ba4e">More...</a><br /></td></tr>
<tr class="separator:a41a691f37fa038eb183280effeb8ba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab7d3a0bde9b440b5975c114e8b9bc65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab7d3a0bde9b440b5975c114e8b9bc65e">combineNumbers</a> (std::vector&lt; unsigned int &gt; &amp;numbers)</td></tr>
<tr class="separator:ab7d3a0bde9b440b5975c114e8b9bc65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e7487b49e4dcd80df4adbc8c614c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#abc1e7487b49e4dcd80df4adbc8c614c2">convertRootToPower</a> ()</td></tr>
<tr class="separator:abc1e7487b49e4dcd80df4adbc8c614c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01dd5932d3ac41680a6c4b5c75abf08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ab01dd5932d3ac41680a6c4b5c75abf08">createNonBinaryTree</a> ()</td></tr>
<tr class="separator:ab01dd5932d3ac41680a6c4b5c75abf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192c46526b6d01b77cbd2dfafdfed3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a192c46526b6d01b77cbd2dfafdfed3e9">createVectorOfChildTypes</a> (std::vector&lt; unsigned int &gt; &amp;numbers, std::vector&lt; unsigned int &gt; &amp;names, std::vector&lt; unsigned int &gt; &amp;others)</td></tr>
<tr class="separator:a192c46526b6d01b77cbd2dfafdfed3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaca4a724db6fe4ce368bd52bb4327a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#abaca4a724db6fe4ce368bd52bb4327a6">derivativeDivide</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:abaca4a724db6fe4ce368bd52bb4327a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86a05de26e77d2f8ddec8049899e89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ac86a05de26e77d2f8ddec8049899e89a">derivativeExp</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:ac86a05de26e77d2f8ddec8049899e89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cda50b40be6742337f12522fabc643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a64cda50b40be6742337f12522fabc643">derivativeLn</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:a64cda50b40be6742337f12522fabc643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006197b7b1cc60ed1ea590ab18af08d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a006197b7b1cc60ed1ea590ab18af08d1">derivativeLog</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:a006197b7b1cc60ed1ea590ab18af08d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96765821cbed88a23821766cdee7668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#af96765821cbed88a23821766cdee7668">derivativeMinus</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:af96765821cbed88a23821766cdee7668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f9918b995bedf90b75406974fffee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a43f9918b995bedf90b75406974fffee6">derivativePlus</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:a43f9918b995bedf90b75406974fffee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceea1cbe8a0d56541bae2cfaa70d64c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aceea1cbe8a0d56541bae2cfaa70d64c1">derivativePower</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:aceea1cbe8a0d56541bae2cfaa70d64c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1f08d8e8abe07309461ea3c299d32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a3ff1f08d8e8abe07309461ea3c299d32">derivativeTimes</a> (const std::string &amp;variable)</td></tr>
<tr class="separator:a3ff1f08d8e8abe07309461ea3c299d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44462bd3a2637da4176cdba9af0ccce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a44462bd3a2637da4176cdba9af0ccce0">encompassUnaryMinus</a> ()</td></tr>
<tr class="separator:a44462bd3a2637da4176cdba9af0ccce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca95716234ea68c1821d3bf0408dfa01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aca95716234ea68c1821d3bf0408dfa01">refactorNumbers</a> ()</td></tr>
<tr class="separator:aca95716234ea68c1821d3bf0408dfa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb3541962ad08944674c5731b802c99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#aefb3541962ad08944674c5731b802c99">reorderArguments</a> (unsigned int level=0)</td></tr>
<tr class="separator:aefb3541962ad08944674c5731b802c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4df9cba1deec746bf142f98aa79e150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#ad4df9cba1deec746bf142f98aa79e150">simplify</a> ()</td></tr>
<tr class="separator:ad4df9cba1deec746bf142f98aa79e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1c8e0078ffd86633281a0fe7bfa26883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a1c8e0078ffd86633281a0fe7bfa26883">clearPlugins</a> ()</td></tr>
<tr class="separator:a1c8e0078ffd86633281a0fe7bfa26883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a709a4cfd50fb2e3e4a9799fe7e43eb33"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_s_t_node.html#a709a4cfd50fb2e3e4a9799fe7e43eb33">SBMLRateRuleConverter</a></td></tr>
<tr class="separator:a709a4cfd50fb2e3e4a9799fe7e43eb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a367fe0566fc1a2483221424f4101ad06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367fe0566fc1a2483221424f4101ad06">&#9670;&nbsp;</a></span>ASTNode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTNode::ASTNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<p>Unless the argument <code>type</code> is given, the returned node will by default have a type of <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>. If the type isn't supplied when caling this constructor, the caller should set the node type to something else as soon as possible usingsetType().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>an optional <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode types.">ASTNodeType_t</a> code indicating the type of node to create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84e4e3ac084f7aa807c3d99663a76f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e4e3ac084f7aa807c3d99663a76f32">&#9670;&nbsp;</a></span>ASTNode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTNode::ASTNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_token__t.html">Token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_a_s_t_node.html">ASTNode</a> from the given Token. </p>
<p>The resulting <a class="el" href="class_a_s_t_node.html">ASTNode</a> will contain the same data as the <code>token</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the token to use as a starting point for creating the <a class="el" href="class_a_s_t_node.html">ASTNode</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f23367254065f51fa2f2d2c74c47022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f23367254065f51fa2f2d2c74c47022">&#9670;&nbsp;</a></span>ASTNode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTNode::ASTNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor; creates a deep copy of the given <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>the <a class="el" href="class_a_s_t_node.html">ASTNode</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41a691f37fa038eb183280effeb8ba4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a691f37fa038eb183280effeb8ba4e">&#9670;&nbsp;</a></span>~ASTNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ASTNode::~ASTNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, including any child nodes. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad699b88d62f54bce4edf94d6ffd110f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad699b88d62f54bce4edf94d6ffd110f1">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inRead</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given node as a child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<p>Child nodes are added in-order, from left to right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disownedChild</td><td>the <a class="el" href="class_a_s_t_node.html">ASTNode</a> instance to add. </td></tr>
    <tr><td class="paramname">inRead</td><td><code>false</code> by default; may be set to <code>true</code> when reading XML where there may be a lambda function with no bvar arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> object may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The methodASTNode::isWellFormedASTNode() may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8" title="Adds the given node as a child of this ASTNode.">prependChild(ASTNode* disownedChild)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a050c49267ec3f8d4d6f69126d89b7a9f" title="Replaces and optionally deletes the nth child of this ASTNode with the given ASTNode.">replaceChild(unsigned int n, ASTNode* disownedChild, bool delreplaced)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8ceb6b332df118a1dfd3576b84f1c6e4" title="Inserts the given ASTNode at point n in the list of children of this ASTNode.">insertChild(unsigned int n, ASTNode* disownedChild)</a> </dd>
<dd>
removeChild(unsigned int n) </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ab6cc27f060b99173529b20e6ba770b2a" title="Returns true or false depending on whether this ASTNode is well-formed.">isWellFormedASTNode()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a37">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6e9ceb2801bb494e7581794e1ca17a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9ceb2801bb494e7581794e1ca17a71">&#9670;&nbsp;</a></span>addSemanticsAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::addSemanticsAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>disownedAnnotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given <a class="el" href="class_x_m_l_node.html">XMLNode</a> as a MathML <code>&lt;semantics&gt;</code> element to this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
that can be used to associate additional information with a MathML
construct.  The construct can be used to decorate a MathML expressions with
a sequence of one or more <code>&lt;annotation&gt;</code> or
<code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
pair of items; the first is a symbol that acts as an attribute or key, and
the second is the value associated with the attribute or key.  Please refer
to the MathML&nbsp;2.0 documentation, particularly the <a target="_blank"
href="http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations">Section
5.2, Semantic Annotations</a> for more information about these constructs.
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disownedAnnotation</td><td>the annotation to add. Will become a child of the parent node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although SBML permits the use of the MathML <code>&lt;semantics&gt;</code> annotation construct, the truth is that this construct has so far (at this time of this writing, which is early 2014) seen very little use in SBML software. The full implications of using these annotations are still poorly understood. If you wish to use this construct, we urge you to discuss possible uses and applications on the SBML discussion lists, particularly <a href="http://sbml.org/Forums" target="_blank">sbml-discuss</a> and/or <a href="http://sbml.org/Forums" target="_blank">sbml-interoperability</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#ab51b93fa0ab9a7b5565f1a47f993f9ed" title="Returns the number of MathML &lt;semantics&gt; element elements on this node.">getNumSemanticsAnnotations()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ac98550575c764a4617651d5f311cea65" title="Returns the nth MathML &lt;semantics&gt; element on this ASTNode.">getSemanticsAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a88091f57f7717247d0c72da41063ab1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88091f57f7717247d0c72da41063ab1f">&#9670;&nbsp;</a></span>canonicalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::canonicalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to a canonical form and returns <code>true</code> if successful, <code>false</code> otherwise. </p>
<p>The rules determining the canonical form conversion are as follows:</p>
<ul>
<li>If the node type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> and the node name matches <code>"ExponentialE"</code>, <code>"Pi"</code>, <code>"True"</code> or <code>"False"</code> the node type is converted to the corresponding <code>AST_CONSTANT_</code><em><span class="placeholder">X</span></em> type.</li>
</ul>
<ul>
<li>If the node type is an <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> and the node name matches an SBML (MathML) function name, logical operator name, or relational operator name, the node is converted to the corresponding <code>AST_FUNCTION_</code><em><span class="placeholder">X</span></em> or <code>AST_LOGICAL_</code><em><span class="placeholder">X</span></em> type.</li>
</ul>
<p>SBML Level&#160;1 function names are searched first; thus, for example, canonicalizing <code>log</code> will result in a node type of <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a86257b8c9f202d2afbb7397b7def0d8e">AST_FUNCTION_LN</a>. (See the SBML Level&#160;1 Version&#160;2 Specification, Appendix C.)</p>
<p>Sometimes, canonicalization of a node results in a structural conversion of the node as a result of adding a child. For example, a node with the SBML Level&#160;1 function name <code>sqr</code> and a single child node (the argument) will be transformed to a node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b73ae9941e588add41be17a664284ab">AST_FUNCTION_POWER</a> with two children. The first child will remain unchanged, but the second child will be an <a class="el" href="class_a_s_t_node.html">ASTNode</a> of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> and a value of 2. The function names that result in structural changes are: <code>log10</code>, <code>sqr</code>, and <code>sqrt</code>. </p>

</div>
</div>
<a id="a1c8e0078ffd86633281a0fe7bfa26883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8e0078ffd86633281a0fe7bfa26883">&#9670;&nbsp;</a></span>clearPlugins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::clearPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7d3a0bde9b440b5975c114e8b9bc65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d3a0bde9b440b5975c114e8b9bc65e">&#9670;&nbsp;</a></span>combineNumbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::combineNumbers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>numbers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc1e7487b49e4dcd80df4adbc8c614c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1e7487b49e4dcd80df4adbc8c614c2">&#9670;&nbsp;</a></span>convertRootToPower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::convertRootToPower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab01dd5932d3ac41680a6c4b5c75abf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01dd5932d3ac41680a6c4b5c75abf08">&#9670;&nbsp;</a></span>createNonBinaryTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::createNonBinaryTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a192c46526b6d01b77cbd2dfafdfed3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192c46526b6d01b77cbd2dfafdfed3e9">&#9670;&nbsp;</a></span>createVectorOfChildTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::createVectorOfChildTypes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1718696693db25031c132567b36ed1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1718696693db25031c132567b36ed1b">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::decompose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows decomposition of <a class="el" href="class_a_s_t_node.html">ASTNode</a> into components such that we reduce the need for brackets. </p>
<p>Obviously an <a class="el" href="class_a_s_t_node.html">ASTNode</a> does not have brackets but when written as a string these would become necessary.</p>
<p>The decomposition used here is such that if the top level function is multiply or divide then the arguments to these functions do not contain a plus element.</p>
<p>for example</p>
<p>(a + B) * c becomes ac + Bc</p>
<p>(5 + 3)/(a-4) becomes 8/(a-4)</p>
<p>(a + 4)/4 becomes 1 + a/4 </p>

</div>
</div>
<a id="a9e898544e22c7bb1651a63cad88e0188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e898544e22c7bb1651a63cad88e0188">&#9670;&nbsp;</a></span>deepCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::deepCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a recursive copy of this node and all its children. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> and all its children. The caller owns the returned <a class="el" href="class_a_s_t_node.html">ASTNode</a> and is responsible for deleting it. </dd></dl>

</div>
</div>
<a id="affc61b0ed965134978817150ef2e7036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc61b0ed965134978817150ef2e7036">&#9670;&nbsp;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivative </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_a_s_t_node.html">ASTNode</a> representing the derivative of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> with respect to the given variable. </p>
<p>e.g. if we have an <a class="el" href="class_a_s_t_node.html">ASTNode</a> that represents 2*x^2 and we call the function derivative("x") on this node</p>
<p>this will return an <a class="el" href="class_a_s_t_node.html">ASTNode</a> representing 4 * x since d(2*x^2)/dx = 4*x </p>

</div>
</div>
<a id="abaca4a724db6fe4ce368bd52bb4327a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaca4a724db6fe4ce368bd52bb4327a6">&#9670;&nbsp;</a></span>derivativeDivide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativeDivide </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac86a05de26e77d2f8ddec8049899e89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86a05de26e77d2f8ddec8049899e89a">&#9670;&nbsp;</a></span>derivativeExp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativeExp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64cda50b40be6742337f12522fabc643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cda50b40be6742337f12522fabc643">&#9670;&nbsp;</a></span>derivativeLn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativeLn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a006197b7b1cc60ed1ea590ab18af08d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006197b7b1cc60ed1ea590ab18af08d1">&#9670;&nbsp;</a></span>derivativeLog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativeLog </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af96765821cbed88a23821766cdee7668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96765821cbed88a23821766cdee7668">&#9670;&nbsp;</a></span>derivativeMinus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativeMinus </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43f9918b995bedf90b75406974fffee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f9918b995bedf90b75406974fffee6">&#9670;&nbsp;</a></span>derivativePlus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativePlus </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aceea1cbe8a0d56541bae2cfaa70d64c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceea1cbe8a0d56541bae2cfaa70d64c1">&#9670;&nbsp;</a></span>derivativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativePower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff1f08d8e8abe07309461ea3c299d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff1f08d8e8abe07309461ea3c299d32">&#9670;&nbsp;</a></span>derivativeTimes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::derivativeTimes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44462bd3a2637da4176cdba9af0ccce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44462bd3a2637da4176cdba9af0ccce0">&#9670;&nbsp;</a></span>encompassUnaryMinus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::encompassUnaryMinus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51ed1ea50a0c15bd65590d9e599e622f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ed1ea50a0c15bd65590d9e599e622f">&#9670;&nbsp;</a></span>exactlyEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::exactlyEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows two ASTNodes to be compared for exact equivilance. </p>
<p>It returns a boolean - true if the ASTNodes are exactly the same, false otherwise.</p>
<p>Given that 'a+4' == 'a+4' this function will return true if two ASTNodes with PLUS as their operator and "a" as the left child and "4" as the right child are compared</p>
<p>Conversely 'a+4' != '4+a' i.e. the function will return false if the left and right children do not match. </p>

</div>
</div>
<a id="a20ae22da3c9e91336c6e5c40c3619148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ae22da3c9e91336c6e5c40c3619148">&#9670;&nbsp;</a></span>fillListOfNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::fillListOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a>&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a> *&#160;</td>
          <td class="paramname"><em>lst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of nodes rooted at a given node and satisfying a given predicate. </p>
<p>This method is identical to calling <a class="el" href="class_a_s_t_node.html#a6cd4a7f16a2d38586a5829cc442b2b92" title="Returns a list of nodes satisfying a given predicate.">getListOfNodes(ASTNodePredicate predicate) const</a>, except that instead of creating a new <a class="el" href="class_list.html">List</a> object, it uses the one passed in as argument <code>lst</code>. This method a depth-first search of the tree rooted at this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object, and adds to the list <code>lst</code> the nodes for which the given function <code>predicate(node)</code> returns <code>true</code> (nonzero).</p>
<p>For portability between different programming languages, the predicate is passed in as a pointer to a function. The function definition must have the type <a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate </a>, which is defined as </p><pre class="fragment">int (*ASTNodePredicate) (const ASTNode_t *node);
</pre><p> where a return value of nonzero represents <code>true</code> and zero represents <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>the predicate to use.</td></tr>
    <tr><td class="paramname">lst</td><td>the <a class="el" href="class_list.html">List</a> to which <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects should be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a6cd4a7f16a2d38586a5829cc442b2b92" title="Returns a list of nodes satisfying a given predicate.">getListOfNodes()</a> </dd></dl>

</div>
</div>
<a id="a23e3154d02f10f3ad653529b6e4eefd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e3154d02f10f3ad653529b6e4eefd0">&#9670;&nbsp;</a></span>freeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::freeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the name of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> and sets it to <code>NULL</code>. </p>
<p>This operation is only applicable to <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects corresponding to operators, numbers, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>. This method has no effect on other types of nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad3b9f8cbb32b029cbff6230104d45e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b9f8cbb32b029cbff6230104d45e4c">&#9670;&nbsp;</a></span>getASTPlugin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTBasePlugin* ASTNode::getASTPlugin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package that defines the given <code>type</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode types.">ASTNodeType_t</a> that is defined by the given plugin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension that defines the given <code>type</code>, or <code>NULL</code> if none exist. </dd></dl>

</div>
</div>
<a id="a38115eb60ef56dd2bd64798bb4972792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38115eb60ef56dd2bd64798bb4972792">&#9670;&nbsp;</a></span>getASTPlugin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ASTBasePlugin* ASTNode::getASTPlugin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package that defines the given <code>type</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode types.">ASTNodeType_t</a> that is defined by the given plugin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension that defines the given <code>type</code>, or <code>NULL</code> if none exist. </dd></dl>

</div>
</div>
<a id="a53c550708c1852884fb7debbff2a4483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c550708c1852884fb7debbff2a4483">&#9670;&nbsp;</a></span>getASTPlugin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTBasePlugin* ASTNode::getASTPlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given <code>sbmlns</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td>the namespace of the plugin to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension with the given package name or URI, or <code>NULL</code> if none exist. </dd></dl>

</div>
</div>
<a id="a24b6fe68e3350d54fee8ac2c50a805ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b6fe68e3350d54fee8ac2c50a805ba">&#9670;&nbsp;</a></span>getASTPlugin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ASTBasePlugin* ASTNode::getASTPlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given <code>sbmlns</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td>the namespace of the plugin to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension with the given package name or URI, or <code>NULL</code> if none exist. </dd></dl>

</div>
</div>
<a id="a7a1ad630dda7184c47aa8d813ef9ec1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1ad630dda7184c47aa8d813ef9ec1f">&#9670;&nbsp;</a></span>getASTPlugin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASTBasePlugin* ASTNode::getASTPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCsymbol</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strCmpIsCaseSensitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package with the given constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the type or csymbol defined by the returned plugin. </td></tr>
    <tr><td class="paramname">isCsymbol</td><td>Boolean indicator of whether the <code>name</code> is a csymbol (if <code>true</code>) or type (if <code>false</code>). </td></tr>
    <tr><td class="paramname">strCmpIsCaseSensitive</td><td>whether to search for the matching type or csymbol in case-sensitve manner (if <code>true</code>) or case-insensitive manner (if <code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension that defines the given <code>name</code>, or <code>NULL</code> if none exist. </dd></dl>

</div>
</div>
<a id="aaf0fd2d37140b14ac9b7b8e2b7ed7252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0fd2d37140b14ac9b7b8e2b7ed7252">&#9670;&nbsp;</a></span>getASTPlugin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ASTBasePlugin* ASTNode::getASTPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCsymbol</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strCmpIsCaseSensitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension for the package with the given constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the type or csymbol defined by the returned plugin. </td></tr>
    <tr><td class="paramname">isCsymbol</td><td>Boolean indicator of whether the <code>name</code> is a csymbol (if <code>true</code>) or type (if <code>false</code>). </td></tr>
    <tr><td class="paramname">strCmpIsCaseSensitive</td><td>whether to search for the matching type or csymbol in case-sensitve manner (if <code>true</code>) or case-insensitive manner (if <code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension that defines the given <code>name</code>, or <code>NULL</code> if none exist. </dd></dl>

</div>
</div>
<a id="af119ca46b99dec97a70ae233172eb78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af119ca46b99dec97a70ae233172eb78e">&#9670;&nbsp;</a></span>getCharacter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ASTNode::getCharacter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of this node as a single character. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b5febe16514530ccf97536c0a26244d">AST_TIMES</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a11408698b7be79184ba65779128ef654">AST_DIVIDE</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203abfa0a5d49f1a260bab7663cf688e76a9">AST_POWER</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> as a single character </dd></dl>

</div>
</div>
<a id="afe8b40f63d8afb85bbe5f21b0108f53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8b40f63d8afb85bbe5f21b0108f53a">&#9670;&nbsp;</a></span>getChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the child at index n of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the child to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> or <code>NULL</code> if this node has no nth child (<code>n &gt; </code> <a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2" title="Returns the number of children of this node.">getNumChildren()</a> <code>- 1</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2" title="Returns the number of children of this node.">getNumChildren()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a564b600c952dce716797c1bd3c808211" title="Returns the left child of this node.">getLeftChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ac5ece8fdb8c21f299c61f6c9f537b2e1" title="Returns the right child of this node.">getRightChild()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_math_8cpp-example.html#a7">printMath.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3c88d603fc91ae01b519ef36a813940f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c88d603fc91ae01b519ef36a813940f">&#9670;&nbsp;</a></span>getClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ASTNode::getClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML <code>class</code> attribute value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the MathML class of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or an empty string if it does not exist.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a5b025a12c1a5b30630a9c9ba3f555225" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;class&quot;.">isSetClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#af7fc605d22e1fb0fce89d7248ff84499" title="Sets the MathML attribute class of this ASTNode to className.">setClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a1e62030f74c9867ae6ddf2eab40b5ad9" title="Unsets the MathML class attribute of this ASTNode.">unsetClass()</a> </dd></dl>

</div>
</div>
<a id="ab04a842cd7e586cbb2ab055f111627ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04a842cd7e586cbb2ab055f111627ba">&#9670;&nbsp;</a></span>getDefinitionURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> * ASTNode::getDefinitionURL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML <code>definitionURL</code> attribute value. </p>
<dl class="section return"><dt>Returns</dt><dd>the value of the <code>definitionURL</code> attribute, in the form of a libSBML <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>setDefinitionURL(XMLAttributes url) </dd>
<dd>
setDefinitionURL(const std::string&amp; url) </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a36a712c5ac373e0ebd4de0235a96e129" title="Returns the MathML definitionURL attribute value as a string.">getDefinitionURLString()</a> </dd></dl>

</div>
</div>
<a id="a36a712c5ac373e0ebd4de0235a96e129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a712c5ac373e0ebd4de0235a96e129">&#9670;&nbsp;</a></span>getDefinitionURLString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ASTNode::getDefinitionURLString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML <code>definitionURL</code> attribute value as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>the value of the <code>definitionURL</code> attribute, as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#ab04a842cd7e586cbb2ab055f111627ba" title="Returns the MathML definitionURL attribute value.">getDefinitionURL()</a> </dd>
<dd>
setDefinitionURL(const std::string&amp; url) </dd>
<dd>
setDefinitionURL(XMLAttributes url) </dd></dl>

</div>
</div>
<a id="a620072b6b11a6c83943ecdfa4385f6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620072b6b11a6c83943ecdfa4385f6d6">&#9670;&nbsp;</a></span>getDenominator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode::getDenominator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the denominator of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>the value of the denominator of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or <code>1</code> (true) if this node is not of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only when <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>. It will return <code>1</code> if the node type is another type, but since <code>1</code> may be a valid value for the denominator of a rational number, it is important to be sure that the node type is the correct type in order to correctly interpret the returned value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee" title="Returns the value of the numerator of this node if of type AST_RATIONAL, or the numerical value of th...">getNumerator()</a> </dd></dl>

</div>
</div>
<a id="ac0466ef0434e4044c09bad81238c0f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0466ef0434e4044c09bad81238c0f8b">&#9670;&nbsp;</a></span>getExponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode::getExponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the exponent value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the value of the exponent of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or <code>0</code> if this is not a type of node that has an exponent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only when <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a>. It will return <code>0</code> if the node type is another type, but since <code>0</code> may be a valid value, it is important to be sure that the node type is the correct type in order to correctly interpret the returned value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a8da51fb905d7460d7531893906a21a1f" title="Returns the mantissa value of this node.">getMantissa()</a> </dd></dl>

</div>
</div>
<a id="aaa3ad6caed2fcd8438ccb45af6dc8119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3ad6caed2fcd8438ccb45af6dc8119">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ASTNode::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML <code>id</code> attribute value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the MathML id of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a98d7af6077c4c113057f82cd5c43c735" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;id&quot;.">isSetId()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a97e5715b8f4795e2b06c7264559d987d" title="Sets the MathML attribute id of this ASTNode.">setId(const std::string&amp; id)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a38962e67843d2841404e68f87d77b722" title="Unsets the MathML id attribute of this ASTNode.">unsetId()</a> </dd></dl>

</div>
</div>
<a id="a85b0d75569f92141c9675b4791873785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b0d75569f92141c9675b4791873785">&#9670;&nbsp;</a></span>getInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode::getInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of this node as an integer. </p>
<p>If this node type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, this method returns the value of the numerator.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> as a (<code>long</code>) integer if type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>; the numerator if type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, and <code>0</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only when <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>. It will return <code>0</code> if the node type is <em>not</em> one of these, but since <code>0</code> may be a valid value for integer, it is important to be sure that the node type is one of the expected types in order to understand if <code>0</code> is the actual value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee" title="Returns the value of the numerator of this node if of type AST_RATIONAL, or the numerical value of th...">getNumerator()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6" title="Returns the value of the denominator of this node.">getDenominator()</a> </dd></dl>

</div>
</div>
<a id="a564b600c952dce716797c1bd3c808211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564b600c952dce716797c1bd3c808211">&#9670;&nbsp;</a></span>getLeftChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::getLeftChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the left child of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>the left child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. This is equivalent to calling <a class="el" href="class_a_s_t_node.html#afe8b40f63d8afb85bbe5f21b0108f53a" title="Returns the child at index n of this node.">getChild()</a> with an argument of <code>0</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2" title="Returns the number of children of this node.">getNumChildren()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#afe8b40f63d8afb85bbe5f21b0108f53a" title="Returns the child at index n of this node.">getChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ac5ece8fdb8c21f299c61f6c9f537b2e1" title="Returns the right child of this node.">getRightChild()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a54">createExampleSBML.cpp</a>, and <a class="el" href="print_math_8cpp-example.html#a6">printMath.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6cd4a7f16a2d38586a5829cc442b2b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd4a7f16a2d38586a5829cc442b2b92">&#9670;&nbsp;</a></span>getListOfNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * ASTNode::getListOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a>&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of nodes satisfying a given predicate. </p>
<p>This performs a depth-first search of the tree rooted at this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object, and returns a <a class="el" href="class_list.html">List</a> of nodes for which the given function <code>predicate(node)</code> returns <code>true</code> (nonzero).</p>
<p>For portability between different programming languages, the predicate is passed in as a pointer to a function. The function definition must have the type <a class="el" href="_a_s_t_node_8h.html#a6faa792f81e0be497e904b2b2e273072">ASTNodePredicate</a>, which is defined as </p><pre class="fragment">int (*ASTNodePredicate) (const ASTNode *node);
</pre><p> where a return value of nonzero represents <code>true</code> and zero represents <code>false</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>the predicate to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of nodes for which the predicate returned <code>true</code> (nonzero). The <a class="el" href="class_list.html">List</a> returned is owned by the caller and should be deleted after the caller is done using it. The <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects in the list; however, are not owned by the caller (as they still belong to the tree itself), and therefore should not be deleted. </dd></dl>

</div>
</div>
<a id="a8da51fb905d7460d7531893906a21a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da51fb905d7460d7531893906a21a1f">&#9670;&nbsp;</a></span>getMantissa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ASTNode::getMantissa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mantissa value of this node. </p>
<p>If <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>, this method is identical to <a class="el" href="class_a_s_t_node.html#a9d737e799a7c6b9757fd03abed50b580" title="Returns the real-numbered value of this node.">ASTNode::getReal()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of the mantissa of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or <code>0</code> if this node is not a type that has a real-numbered value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only when <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a>. It will return <code>0</code> if the node type is another type, but since <code>0</code> may be a valid value, it is important to be sure that the node type is the correct type in order to correctly interpret the returned value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#ac0466ef0434e4044c09bad81238c0f8b" title="Returns the exponent value of this ASTNode.">getExponent()</a> </dd></dl>

</div>
</div>
<a id="a1bd99fd7074a2ed6e50ded3c406bfb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd99fd7074a2ed6e50ded3c406bfb14">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ASTNode::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of this node as a string. </p>
<p>This function may be called on nodes that (1) are not operators, i.e., nodes for which <a class="el" href="class_a_s_t_node.html#a7d167168f1e9d062fd3f8f5f8cad951e" title="Returns true if this node is a mathematical operator.">isOperator()</a> returns <code>false</code>, and (2) are not numbers, i.e., <a class="el" href="class_a_s_t_node.html#aefb9fc75b2bd81663512ebce1886e4da" title="Returns true (nonzero) if this node contains a number, false (zero) otherwise.">isNumber()</a> returns <code>NULL</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> as a string, or <code>NULL</code> if it is a node that does not have a name equivalent (e.g., if it is a number). </dd></dl>

</div>
</div>
<a id="a9c1e708a632ae00f528106d413ad1cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e708a632ae00f528106d413ad1cb2">&#9670;&nbsp;</a></span>getNumChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ASTNode::getNumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of children of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of children of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or 0 is this node has no children. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_math_8cpp-example.html#a5">printMath.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a17a4868804e7e10a6cf79430723a4aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a4868804e7e10a6cf79430723a4aee">&#9670;&nbsp;</a></span>getNumerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ASTNode::getNumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the numerator of this node if of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, or the numerical value of the node if of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>; <code>0</code> otherwise. </p>
<p>This function should be called only when <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb" title="Returns the type of this ASTNode.">getType()</a> returns <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>. It will return <code>0</code> if the node type is another type, but since <code>0</code> may be a valid value for the denominator of a rational number or of an integer, it is important to be sure that the node type is the correct type in order to correctly interpret the returned value.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of the numerator of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> if <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, the value if <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>, or <code>0</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6" title="Returns the value of the denominator of this node.">getDenominator()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a85b0d75569f92141c9675b4791873785" title="Returns the value of this node as an integer.">getInteger()</a> </dd></dl>

</div>
</div>
<a id="ab51b93fa0ab9a7b5565f1a47f993f9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51b93fa0ab9a7b5565f1a47f993f9ed">&#9670;&nbsp;</a></span>getNumSemanticsAnnotations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ASTNode::getNumSemanticsAnnotations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of MathML <code>&lt;semantics&gt;</code> element elements on this node. </p>
The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
that can be used to associate additional information with a MathML
construct.  The construct can be used to decorate a MathML expressions with
a sequence of one or more <code>&lt;annotation&gt;</code> or
<code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
pair of items; the first is a symbol that acts as an attribute or key, and
the second is the value associated with the attribute or key.  Please refer
to the MathML&nbsp;2.0 documentation, particularly the <a target="_blank"
href="http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations">Section
5.2, Semantic Annotations</a> for more information about these constructs.
<dl class="section return"><dt>Returns</dt><dd>the number of annotations of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although SBML permits the use of the MathML <code>&lt;semantics&gt;</code> annotation construct, the truth is that this construct has so far (at this time of this writing, which is early 2014) seen very little use in SBML software. The full implications of using these annotations are still poorly understood. If you wish to use this construct, we urge you to discuss possible uses and applications on the SBML discussion lists, particularly <a href="http://sbml.org/Forums" target="_blank">sbml-discuss</a> and/or <a href="http://sbml.org/Forums" target="_blank">sbml-interoperability</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a6e9ceb2801bb494e7581794e1ca17a71" title="Adds the given XMLNode as a MathML &lt;semantics&gt; element to this ASTNode.">addSemanticsAnnotation()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ac98550575c764a4617651d5f311cea65" title="Returns the nth MathML &lt;semantics&gt; element on this ASTNode.">getSemanticsAnnotation()</a> </dd></dl>

</div>
</div>
<a id="aa4cd64f4d076f47b7d145cf6228c75d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cd64f4d076f47b7d145cf6228c75d0">&#9670;&nbsp;</a></span>getOperatorName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ASTNode::getOperatorName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of this operator node as a string. </p>
<p>This function may be called on nodes that are operators, i.e., nodes for which <a class="el" href="class_a_s_t_node.html#a7d167168f1e9d062fd3f8f5f8cad951e" title="Returns true if this node is a mathematical operator.">isOperator()</a> returns <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this operator <a class="el" href="class_a_s_t_node.html">ASTNode</a> as a string (or <code>NULL</code> if not an operator). </dd></dl>

</div>
</div>
<a id="a3e12c3633f7d19f03523925ff845aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e12c3633f7d19f03523925ff845aa91">&#9670;&nbsp;</a></span>getParentSBMLObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * ASTNode::getParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parent SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the parent SBML object of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a63be31576eef23de0a5f2e40b48b6aee" title="Returns true if this node has a value for the parent SBML object.">isSetParentSBMLObject()</a> </dd>
<dd>
setParentSBMLObject() </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a2ba0713a2137fcbd3e9c4beb0e15276f" title="Unsets the parent SBML object.">unsetParentSBMLObject()</a> </dd></dl>

</div>
</div>
<a id="aafc4d19ef98ca44c7520cc3a6d02debe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc4d19ef98ca44c7520cc3a6d02debe">&#9670;&nbsp;</a></span>getPrecedence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::getPrecedence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the precedence of this node in the infix math syntax of SBML Level&#160;1. </p>
<p>For more information about the infix syntax, see the discussion about <a href="#math-convert">text string formulas</a> at the top of the documentation for <a class="el" href="class_a_s_t_node.html">ASTNode</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an integer indicating the precedence of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> </dd></dl>

</div>
</div>
<a id="a9d737e799a7c6b9757fd03abed50b580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d737e799a7c6b9757fd03abed50b580">&#9670;&nbsp;</a></span>getReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ASTNode::getReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the real-numbered value of this node. </p>
<p>This function performs the necessary arithmetic if the node type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a> (<em>mantissa * 10<sup>exponent</sup></em>) or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a> (<em>numerator / denominator</em>).</p>
<dl class="section return"><dt>Returns</dt><dd>the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> as a real (double), or <code>0</code> if this is not a node that holds a number.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called only when this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has a numerical value type. It will return <code>0</code> if the node type is another type, but since <code>0</code> may be a valid value, it is important to be sure that the node type is the correct type in order to correctly interpret the returned value. </dd></dl>

</div>
</div>
<a id="ac5ece8fdb8c21f299c61f6c9f537b2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ece8fdb8c21f299c61f6c9f537b2e1">&#9670;&nbsp;</a></span>getRightChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> * ASTNode::getRightChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the right child of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>the right child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or <code>NULL</code> if this node has no right child. If <a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2" title="Returns the number of children of this node.">getNumChildren()</a> <code>&gt; 1</code>, then this is equivalent to: <pre class="fragment">getChild( getNumChildren() - 1 );
</pre></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2" title="Returns the number of children of this node.">getNumChildren()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a564b600c952dce716797c1bd3c808211" title="Returns the left child of this node.">getLeftChild()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#afe8b40f63d8afb85bbe5f21b0108f53a" title="Returns the child at index n of this node.">getChild()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a55">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac98550575c764a4617651d5f311cea65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98550575c764a4617651d5f311cea65">&#9670;&nbsp;</a></span>getSemanticsAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * ASTNode::getSemanticsAnnotation </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nth MathML <code>&lt;semantics&gt;</code> element on this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
The <code>&lt;semantics&gt;</code> element is a MathML&nbsp;2.0 construct
that can be used to associate additional information with a MathML
construct.  The construct can be used to decorate a MathML expressions with
a sequence of one or more <code>&lt;annotation&gt;</code> or
<code>&lt;annotation-xml&gt;</code> elements.  Each such element contains a
pair of items; the first is a symbol that acts as an attribute or key, and
the second is the value associated with the attribute or key.  Please refer
to the MathML&nbsp;2.0 documentation, particularly the <a target="_blank"
href="http://www.w3.org/TR/2007/WD-MathML3-20071005/chapter5.html#mixing.semantic.annotations">Section
5.2, Semantic Annotations</a> for more information about these constructs.
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the annotation to return. Callers should use <a class="el" href="class_a_s_t_node.html#ab51b93fa0ab9a7b5565f1a47f993f9ed" title="Returns the number of MathML &lt;semantics&gt; element elements on this node.">ASTNode::getNumSemanticsAnnotations()</a> to first find out how many annotations there are.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth annotation inside this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or <code>NULL</code> if this node has no nth annotation (<code>n &gt;</code> <a class="el" href="class_a_s_t_node.html#ab51b93fa0ab9a7b5565f1a47f993f9ed" title="Returns the number of MathML &lt;semantics&gt; element elements on this node.">getNumSemanticsAnnotations()</a> <code>- 1</code>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although SBML permits the use of the MathML <code>&lt;semantics&gt;</code> annotation construct, the truth is that this construct has so far (at this time of this writing, which is early 2014) seen very little use in SBML software. The full implications of using these annotations are still poorly understood. If you wish to use this construct, we urge you to discuss possible uses and applications on the SBML discussion lists, particularly <a href="http://sbml.org/Forums" target="_blank">sbml-discuss</a> and/or <a href="http://sbml.org/Forums" target="_blank">sbml-interoperability</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#ab51b93fa0ab9a7b5565f1a47f993f9ed" title="Returns the number of MathML &lt;semantics&gt; element elements on this node.">getNumSemanticsAnnotations()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a6e9ceb2801bb494e7581794e1ca17a71" title="Adds the given XMLNode as a MathML &lt;semantics&gt; element to this ASTNode.">addSemanticsAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a154b2a892c2a843dbc31b593cbf35863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154b2a892c2a843dbc31b593cbf35863">&#9670;&nbsp;</a></span>getStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ASTNode::getStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MathML <code>style</code> attribute value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the MathML style of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or an empty string if it does not exist.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a1a21ef4d79d048d8cf13d5ac83cab562" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;style&quot;.">isSetStyle()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a2d61b07a24f76637ad58eeb70acf8dbc" title="Sets the MathML attribute style of this ASTNode to style.">setStyle(const std::string&amp; id)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#af2be455b1eacf4e6854d5d10e36ab99a" title="Unsets the MathML style attribute of this ASTNode.">unsetStyle()</a> </dd></dl>

</div>
</div>
<a id="aaa934fcde1d07f0f1c061b9dd06f6afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa934fcde1d07f0f1c061b9dd06f6afb">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a> ASTNode::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<p>The value returned is one of the Core AST type codes such as <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4703ee0d883714d334ee0d7b534f0ac9">AST_LAMBDA</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a>, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </dd></dl>

</div>
</div>
<a id="a45272cdd7ee4623d3818fe154b8926c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45272cdd7ee4623d3818fe154b8926c4">&#9670;&nbsp;</a></span>getUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ASTNode::getUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="section return"><dt>Returns</dt><dd>the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a id="ad8763e789cfeb52b130c84567684b7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8763e789cfeb52b130c84567684b7af">&#9670;&nbsp;</a></span>getUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ASTNode::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user data that has been previously set via <a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node.">setUserData()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the user data of this node, or <code>NULL</code> if no user data has been set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#aa50a009ade5d3e0bcf0ccd9f7598708a" title="Returns true if this node has a user data object.">isSetUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node.">setUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8d7f8301b10f3aed387a447473650ed5" title="Unsets the user data of this node.">unsetUserData()</a> </dd></dl>

</div>
</div>
<a id="a51a3566e33b2144ce527c727ec9cdfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a3566e33b2144ce527c727ec9cdfa6">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ASTNode::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the numerical value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the numerical value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>, or <code>NaN</code> if this is not a type of node that has a numerical value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will return a numerical value (as a double) for any ASTNode_t that represents a number, a constant such as <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa94de3fb689270170a756ed428b253f6">AST_CONSTANT_PI</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adb591fa008acf014bc037d95a6a89a69">AST_CONSTANT_E</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a>, or <code>1</code> for nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ad571d2b80f4dcc08fc489960efdb2ab3">AST_CONSTANT_TRUE</a> and <code>0</code> for nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adc46a568eb6b891f72738b67da24347a">AST_CONSTANT_FALSE</a>. It does not evaluate the node in any way so, for example, it will not return the value of a named ASTNode_t or attempt to evaluate a function. This includes a node representing <code>time</code> i.e. nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a0358231b02f7964269ebb2e580defdf2">AST_NAME_TIME</a>. </dd></dl>

</div>
</div>
<a id="a0918a907b923f9cb179c9bfa5e5601b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0918a907b923f9cb179c9bfa5e5601b8">&#9670;&nbsp;</a></span>hasCorrectNumberArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::hasCorrectNumberArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has the correct number of children for its type. </p>
<p>For example, an <a class="el" href="class_a_s_t_node.html">ASTNode</a> with type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a> expects 1 or 2 child nodes.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has the appropriate number of children for its type, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function performs a check on the top-level node only. Child nodes are not checked.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#ab6cc27f060b99173529b20e6ba770b2a" title="Returns true or false depending on whether this ASTNode is well-formed.">isWellFormedASTNode()</a> </dd></dl>

</div>
</div>
<a id="a849d09de351d5dea81c10e2fc1dad518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849d09de351d5dea81c10e2fc1dad518">&#9670;&nbsp;</a></span>hasTypeAndNumChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::hasTypeAndNumChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numchildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node is of type <code>type</code> and has <code>numchildren</code> number of children. </p>
<p>Designed for use in cases where it is useful to discover if the node is a unary not or unary minus, or a times node with no children, etc.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is has the specified type and number of children, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="abb708bfee4e451fbbad004b49060969d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb708bfee4e451fbbad004b49060969d">&#9670;&nbsp;</a></span>hasUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::hasUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node or any of its children nodes have the attribute <code>sbml:units</code>. </p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> or its children has units associated with it, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a9a00bda7e722f821e727176ef18ca4ae" title="Returns true (nonzero) if this node has the attribute sbml:units.">isSetUnits()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8e96aa0f6056f3749d401b6fb3bd4371" title="Sets the units of this ASTNode to units.">setUnits(const std::string&amp; units)</a> </dd></dl>

</div>
</div>
<a id="a8ceb6b332df118a1dfd3576b84f1c6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ceb6b332df118a1dfd3576b84f1c6e4">&#9670;&nbsp;</a></span>insertChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::insertChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given <a class="el" href="class_a_s_t_node.html">ASTNode</a> at point n in the list of children of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>unsigned int the index of the <a class="el" href="class_a_s_t_node.html">ASTNode</a> being added. </td></tr>
    <tr><td class="paramname">disownedChild</td><td><a class="el" href="class_a_s_t_node.html">ASTNode</a> to insert as the nth child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> object may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The methodASTNode::isWellFormedASTNode() may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>addChild(ASTNode* disownedChild) </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8" title="Adds the given node as a child of this ASTNode.">prependChild(ASTNode* disownedChild)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a050c49267ec3f8d4d6f69126d89b7a9f" title="Replaces and optionally deletes the nth child of this ASTNode with the given ASTNode.">replaceChild(unsigned int n, ASTNode* disownedChild, bool delreplaced)</a> </dd>
<dd>
removeChild(unsigned int n) </dd></dl>

</div>
</div>
<a id="a91f8d160f54baccda099f00d4c0925dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f8d160f54baccda099f00d4c0925dd">&#9670;&nbsp;</a></span>isAvogadro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isAvogadro </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node is the special symbol <code>avogadro</code>. </p>
<p>The predicate returns <code>false</code> (zero) otherwise.</p>
<p>SBML Level&#160;3 introduced a predefined MathML <code>&lt;csymbol&gt;</code> for the value of Avogadro's constant. LibSBML stores this internally as a node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a>. This method returns <code>true</code> if this node has that type.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is the special symbol avogadro, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a id="a53001b84f9ea746a3caa12e4346c5e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53001b84f9ea746a3caa12e4346c5e07">&#9670;&nbsp;</a></span>isBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isBoolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node has a Boolean type. </p>
<p>The <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects that have Boolean types are the logical operators, relational operators, and the constants <code>true</code> or <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has a Boolean type, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae100c13f6e5e073180fa8fa44752331d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae100c13f6e5e073180fa8fa44752331d">&#9670;&nbsp;</a></span>isCiNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isCiNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a MathML ci element representing a value not a function (e.g., <code>true</code>, <code>Pi</code>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML ci element, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8b42abf93fc6056c53c31d77bfe05583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b42abf93fc6056c53c31d77bfe05583">&#9670;&nbsp;</a></span>isConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a MathML constant (e.g., <code>true</code>, <code>Pi</code>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML constant, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function will also return <code>true</code> for nodes of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> in SBML Level&#160;3. </dd></dl>

</div>
</div>
<a id="a12f9924cbd69933cde0cdc8b4ec364ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f9924cbd69933cde0cdc8b4ec364ff">&#9670;&nbsp;</a></span>isConstantNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isConstantNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a MathML constant with numeric value (e.g., <code>Pi</code>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML constant, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function will also return <code>true</code> for <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> in SBML Level&#160;3. </dd></dl>

</div>
</div>
<a id="a6f92f2725acc86d0d0552c946a50eb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f92f2725acc86d0d0552c946a50eb34">&#9670;&nbsp;</a></span>isCSymbolFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isCSymbolFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a MathML csymbol representing a function. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML csymbol function, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a55a3758a3436b2a65fc366db36f877b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3758a3436b2a65fc366db36f877b7">&#9670;&nbsp;</a></span>isFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node represents a function. </p>
<p>The three types of functions in SBML are MathML functions (e.g., <code>abs()</code>), SBML Level&#160;1 functions (in the SBML Level&#160;1 math syntax), and user-defined functions (using <a class="el" href="class_function_definition.html">FunctionDefinition</a> in SBML Level&#160;2 and&#160;3).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a function, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae990bb9bc7c1ee85435ea631c32fd090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae990bb9bc7c1ee85435ea631c32fd090">&#9670;&nbsp;</a></span>isInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isInfinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents the special IEEE 754 value infinity, <code>false</code> (zero) otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is the special IEEE 754 value infinity, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0dc100c11710945c43c8c90f6cd95a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc100c11710945c43c8c90f6cd95a3a">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node contains an integer value, <code>false</code> (zero) otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a985209cb471d6ab7de66e490b3951557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985209cb471d6ab7de66e490b3951557">&#9670;&nbsp;</a></span>isLambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isLambda </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node is a MathML <code>&lt;lambda&gt;</code>, <code>false</code> (zero) otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4703ee0d883714d334ee0d7b534f0ac9">AST_LAMBDA</a>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a16fc55100fe51edc783350bc748606aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fc55100fe51edc783350bc748606aa">&#9670;&nbsp;</a></span>isLog10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isLog10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a <code>log10</code> function, <code>false</code> (zero) otherwise. </p>
<p>More precisely, this predicate returns <code>true</code> if the node type is <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aee5ce31deca83c9d96a5888474bc0e4d">AST_FUNCTION_LOG</a> with two children, the first of which is an <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> equal to 10.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given <a class="el" href="class_a_s_t_node.html">ASTNode</a> represents a log10() function, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a id="a57abffc95ec4be0b303b2b7f35aa320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57abffc95ec4be0b303b2b7f35aa320f">&#9670;&nbsp;</a></span>isLogical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isLogical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node is a MathML logical operator. </p>
<p>The possible MathML logical operators in SBML core are <code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>, and (as of SBML Level&#160;3 Version&#160;2) <code>implies</code>. If the node represents a logical operator defined in a Level&#160;3 package, it will also return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML logical operator, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5e1b8ddefb172315469f56761c0555bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1b8ddefb172315469f56761c0555bc">&#9670;&nbsp;</a></span>isName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node is a user-defined variable name or the symbols for time or Avogadro's constant. </p>
<p>SBML Levels&#160;2 and&#160;3 provides <code>&lt;csymbol&gt;</code> definitions for "time" and "avogadro", which can be used to represent simulation time and Avogadro's constant in MathML. Note that this method does <em>not</em> return <code>true</code> for the other <code>csymbol</code> values defined by SBML, "delay", because the "delay" is a function and not a constant or variable. Similarly, this function returns <code>false</code> for the csymbol functions added by the 'Distributions' package.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a user-defined variable name in SBML or the special symbols for time or Avogadro's constant. It returns <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="afa2d44197245921e23ddb263c1050b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2d44197245921e23ddb263c1050b96">&#9670;&nbsp;</a></span>isNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents the special IEEE 754 value "not a number" (NaN), <code>false</code> (zero) otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is the special IEEE 754 NaN, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac750afc0c08e4bfc94c20de095ba909b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac750afc0c08e4bfc94c20de095ba909b">&#9670;&nbsp;</a></span>isNegInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isNegInfinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents the special IEEE 754 value "negative infinity", <code>false</code> (zero) otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is the special IEEE 754 value negative infinity, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aefb9fc75b2bd81663512ebce1886e4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb9fc75b2bd81663512ebce1886e4da">&#9670;&nbsp;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node contains a number, <code>false</code> (zero) otherwise. </p>
<p>This is functionally equivalent to the following code: </p><pre class="fragment">isInteger() || isReal()
</pre><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a number, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7d167168f1e9d062fd3f8f5f8cad951e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d167168f1e9d062fd3f8f5f8cad951e">&#9670;&nbsp;</a></span>isOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isOperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node is a mathematical operator. </p>
<p>The possible mathematical operators in the MathML syntax supported by SBML are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>^</code> (power).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is an operator, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a82ea7bf8180435b1a3fdd260a3b0d886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ea7bf8180435b1a3fdd260a3b0d886">&#9670;&nbsp;</a></span>isPiecewise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isPiecewise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node is the MathML <code>&lt;piecewise&gt;</code> construct. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML <code>piecewise</code> function, <code>false</code> (zero) otherwise. </dd></dl>

</div>
</div>
<a id="ab08e12a04ae2c49ee0c107121dea136a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08e12a04ae2c49ee0c107121dea136a">&#9670;&nbsp;</a></span>isRational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isRational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a rational number. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, <code>false</code> (zero) otherwise. </dd></dl>

</div>
</div>
<a id="af089ab6a15a5749545471c57c717c5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af089ab6a15a5749545471c57c717c5a3">&#9670;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node can represent a real number, <code>false</code> (zero) otherwise. </p>
<p>More precisely, this node must be of one of the following types: <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> can represented as a real number, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a75e3de3540380c4f9af73bb8ccf7c79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e3de3540380c4f9af73bb8ccf7c79d">&#9670;&nbsp;</a></span>isRelational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isRelational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node is a MathML relational operator. </p>
<p>The MathML relational operators are <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a MathML relational operator, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a5b025a12c1a5b30630a9c9ba3f555225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b025a12c1a5b30630a9c9ba3f555225">&#9670;&nbsp;</a></span>isSetClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSetClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node has a value for the MathML attribute "class". </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an attribute class, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a98d7af6077c4c113057f82cd5c43c735" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;id&quot;.">isSetId()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a1a21ef4d79d048d8cf13d5ac83cab562" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;style&quot;.">isSetStyle()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#af7fc605d22e1fb0fce89d7248ff84499" title="Sets the MathML attribute class of this ASTNode to className.">setClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a1e62030f74c9867ae6ddf2eab40b5ad9" title="Unsets the MathML class attribute of this ASTNode.">unsetClass()</a> </dd></dl>

</div>
</div>
<a id="a98d7af6077c4c113057f82cd5c43c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d7af6077c4c113057f82cd5c43c735">&#9670;&nbsp;</a></span>isSetId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node has a value for the MathML attribute "id". </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an attribute id, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a5b025a12c1a5b30630a9c9ba3f555225" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;class&quot;.">isSetClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a1a21ef4d79d048d8cf13d5ac83cab562" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;style&quot;.">isSetStyle()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a97e5715b8f4795e2b06c7264559d987d" title="Sets the MathML attribute id of this ASTNode.">setId(const std::string&amp; id)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a38962e67843d2841404e68f87d77b722" title="Unsets the MathML id attribute of this ASTNode.">unsetId()</a> </dd></dl>

</div>
</div>
<a id="a63be31576eef23de0a5f2e40b48b6aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63be31576eef23de0a5f2e40b48b6aee">&#9670;&nbsp;</a></span>isSetParentSBMLObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSetParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node has a value for the parent SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an parent SBML object set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a3e12c3633f7d19f03523925ff845aa91" title="Returns the parent SBML object.">getParentSBMLObject()</a> </dd>
<dd>
setParentSBMLObject() </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a2ba0713a2137fcbd3e9c4beb0e15276f" title="Unsets the parent SBML object.">unsetParentSBMLObject()</a> </dd></dl>

</div>
</div>
<a id="a1a21ef4d79d048d8cf13d5ac83cab562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a21ef4d79d048d8cf13d5ac83cab562">&#9670;&nbsp;</a></span>isSetStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSetStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node has a value for the MathML attribute "style". </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an attribute style, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a5b025a12c1a5b30630a9c9ba3f555225" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;class&quot;.">isSetClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a98d7af6077c4c113057f82cd5c43c735" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;id&quot;.">isSetId()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a2d61b07a24f76637ad58eeb70acf8dbc" title="Sets the MathML attribute style of this ASTNode to style.">setStyle(const std::string&amp; id)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#af2be455b1eacf4e6854d5d10e36ab99a" title="Unsets the MathML style attribute of this ASTNode.">unsetStyle()</a> </dd></dl>

</div>
</div>
<a id="a9a00bda7e722f821e727176ef18ca4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a00bda7e722f821e727176ef18ca4ae">&#9670;&nbsp;</a></span>isSetUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSetUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node has the attribute <code>sbml:units</code>. </p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has units associated with it, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#abb708bfee4e451fbbad004b49060969d" title="Returns true (nonzero) if this node or any of its children nodes have the attribute sbml:units.">hasUnits()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8e96aa0f6056f3749d401b6fb3bd4371" title="Sets the units of this ASTNode to units.">setUnits(const std::string&amp; units)</a> </dd></dl>

</div>
</div>
<a id="aa50a009ade5d3e0bcf0ccd9f7598708a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50a009ade5d3e0bcf0ccd9f7598708a">&#9670;&nbsp;</a></span>isSetUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this node has a user data object. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> has a user data object set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node.">setUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ad8763e789cfeb52b130c84567684b7af" title="Returns the user data that has been previously set via setUserData().">getUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8d7f8301b10f3aed387a447473650ed5" title="Unsets the user data of this node.">unsetUserData()</a> </dd></dl>

</div>
</div>
<a id="a38b4f4926633a26a8a028cd1b0715be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b4f4926633a26a8a028cd1b0715be9">&#9670;&nbsp;</a></span>isSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isSqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a square root function, <code>false</code> (zero) otherwise. </p>
<p>More precisely, the node type must be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a676272161183a845f1fb3cdcf02fea63">AST_FUNCTION_ROOT</a> with two children, the first of which is an <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a> node having value equal to 2.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given <a class="el" href="class_a_s_t_node.html">ASTNode</a> represents a sqrt() function, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2b3324f1e9873236c540bc1f930881db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3324f1e9873236c540bc1f930881db">&#9670;&nbsp;</a></span>isUMinus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isUMinus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node is a unary minus operator, <code>false</code> (zero) otherwise. </p>
<p>A node is defined as a unary minus node if it is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a> and has exactly one child.</p>
<p>For numbers, unary minus nodes can be "collapsed" by negating the number. In fact, <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> does this during its parsing process, and <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> has a configuration option that allows this behavior to be turned on or off. However, unary minus nodes for symbols (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a>) cannot be "collapsed", so this predicate function is necessary.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a unary minus, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> </dd></dl>

</div>
</div>
<a id="a7868d8333ea7a206e128e5a928d8477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7868d8333ea7a206e128e5a928d8477e">&#9670;&nbsp;</a></span>isUnknown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isUnknown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node has an unknown type. </p>
<p>"Unknown" nodes have the type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>. Nodes with unknown types will not appear in an <a class="el" href="class_a_s_t_node.html">ASTNode</a> tree returned by libSBML based upon valid SBML input; the only situation in which a node with type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a> may appear is immediately after having create a new, untyped node using the <a class="el" href="class_a_s_t_node.html">ASTNode</a> constructor. Callers creating nodes should endeavor to set the type to a valid node type as soon as possible after creating new nodes.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af8b7ceefbd7e08edb1e598100766b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b7ceefbd7e08edb1e598100766b218">&#9670;&nbsp;</a></span>isUPlus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isUPlus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node is a unary plus operator, <code>false</code> (zero) otherwise. </p>
<p>A node is defined as a unary minus node if it is of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a> and has exactly one child.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a unary plus, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a78de5315974132247f9ddfd7a96d2124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78de5315974132247f9ddfd7a96d2124">&#9670;&nbsp;</a></span>isUserFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isUserFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node represents a MathML user-defined function. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is a user-defined function, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab6cc27f060b99173529b20e6ba770b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cc27f060b99173529b20e6ba770b2a">&#9670;&nbsp;</a></span>isWellFormedASTNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::isWellFormedASTNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> or <code>false</code> depending on whether this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is well-formed. </p>
<dl class="section note"><dt>Note</dt><dd>An <a class="el" href="class_a_s_t_node.html">ASTNode</a> may be well-formed, with each node and its children having the appropriate number of children for the given type, but may still be invalid in the context of its use within an SBML model.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is well-formed, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a0918a907b923f9cb179c9bfa5e5601b8" title="Returns true if this ASTNode has the correct number of children for its type.">hasCorrectNumberArguments()</a> </dd></dl>

</div>
</div>
<a id="af15cbd49549142db74fffa17555c5a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15cbd49549142db74fffa17555c5a68">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp; ASTNode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node.html">ASTNode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the object whose values are used as the basis of the assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27fec7e37689b7119846815c7f9108a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fec7e37689b7119846815c7f9108a8">&#9670;&nbsp;</a></span>prependChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::prependChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given node as a child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<p>This method adds child nodes from right to left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disownedChild</td><td>the <a class="el" href="class_a_s_t_node.html">ASTNode</a> instance to add. Will become a child of the parent node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> object may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The methodASTNode::isWellFormedASTNode() may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>addChild(ASTNode* disownedChild) </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a050c49267ec3f8d4d6f69126d89b7a9f" title="Replaces and optionally deletes the nth child of this ASTNode with the given ASTNode.">replaceChild(unsigned int n, ASTNode* disownedChild, bool delreplaced)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8ceb6b332df118a1dfd3576b84f1c6e4" title="Inserts the given ASTNode at point n in the list of children of this ASTNode.">insertChild(unsigned int n, ASTNode* disownedChild)</a> </dd>
<dd>
removeChild(unsigned int n) </dd></dl>

</div>
</div>
<a id="a645bd2cc1e1f1be0620a6742e7828ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645bd2cc1e1f1be0620a6742e7828ded">&#9670;&nbsp;</a></span>reduceToBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::reduceToBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to a binary tree. </p>
<p>Example: if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is <code>and(x, y, z)</code>, then the formula of the reduced node is <code>and(and(x, y), z)</code>. The operation replaces the formula stored in the current <a class="el" href="class_a_s_t_node.html">ASTNode</a> object. </p>

</div>
</div>
<a id="a9f778795d2a475489457bbb1fd5a236f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f778795d2a475489457bbb1fd5a236f">&#9670;&nbsp;</a></span>refactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::refactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function refactors an <a class="el" href="class_a_s_t_node.html">ASTNode</a> to facilitate the use of the algorithm to construct a reaction network from a set of ordinary differential equations. </p>
<p>It performs the following actions:</p>
<p>refactors any numerical ASTNodes so that any operation involving 2 or more numerical nodes is performed and becomes a single node eg (4 + 1 x 2) becomes (6)</p>
<p>encompases a unary minus into the numerical value of a node eg a node representing minus with a single child node representing 2 becomes a single node representing -2</p>
<p>refactors binary nodes, which are the default, into a non-binary representation eg a node representing plus with 2 children which each represent a plus with two numerical children will become a node representing plus with four numerical children</p>
<p>reorders the arguments of any operation so that numerical arguments come first, followed by nodes representing variables, followed by nodes representing functions eg a node (sin(a + 2) - 3 + b) becomes (-3 + b + sin(2 + a)) </p>

</div>
</div>
<a id="aca95716234ea68c1821d3bf0408dfa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca95716234ea68c1821d3bf0408dfa01">&#9670;&nbsp;</a></span>refactorNumbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::refactorNumbers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a970e2b320c25a7a15877061e6a7b77c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970e2b320c25a7a15877061e6a7b77c8">&#9670;&nbsp;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delremoved</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>unsigned int the index of the child to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> object may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The methodASTNode::isWellFormedASTNode() may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>addChild(ASTNode* disownedChild) </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8" title="Adds the given node as a child of this ASTNode.">prependChild(ASTNode* disownedChild)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a050c49267ec3f8d4d6f69126d89b7a9f" title="Replaces and optionally deletes the nth child of this ASTNode with the given ASTNode.">replaceChild(unsigned int n, ASTNode* disownedChild, bool delreplaced)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8ceb6b332df118a1dfd3576b84f1c6e4" title="Inserts the given ASTNode at point n in the list of children of this ASTNode.">insertChild(unsigned int n, ASTNode* disownedChild)</a> </dd></dl>

</div>
</div>
<a id="ab7aeed21872f18dfc11c3d2de1df88c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7aeed21872f18dfc11c3d2de1df88c5">&#9670;&nbsp;</a></span>renameSIdRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::renameSIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames all the SIdRef attributes on this node and any child node. </p>

</div>
</div>
<a id="aef7055132d2fc71c9dd01dbe2ca1d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7055132d2fc71c9dd01dbe2ca1d968">&#9670;&nbsp;</a></span>renameUnitSIdRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::renameUnitSIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames all the UnitSIdRef attributes on this node and any child node. </p>
<p>The only place UnitSIDRefs appear is in MathML <code>&lt;cn&gt;</code> elements, so the effects of this method are limited to that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefb3541962ad08944674c5731b802c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb3541962ad08944674c5731b802c99">&#9670;&nbsp;</a></span>reorderArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::reorderArguments </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93483fdf785bde427dfe0aadddd114d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93483fdf785bde427dfe0aadddd114d">&#9670;&nbsp;</a></span>replaceArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::replaceArgument </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences of a given name with a given <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<p>For example, if the formula in this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is <code>x + y</code>, and the function is called with <code>bvar</code> = <code>"x"</code> and <code>arg</code> = an <a class="el" href="class_a_s_t_node.html">ASTNode</a> representing the real value <code>3</code>. This method would substitute <code>3</code> for <code>x</code> within this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object, resulting in the formula <code>3 + y</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvar</td><td>a string representing the variable name to be substituted. </td></tr>
    <tr><td class="paramname">arg</td><td>an <a class="el" href="class_a_s_t_node.html">ASTNode</a> representing the name/value/formula to use as a replacement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ca4ad8fe4bf312d64872a9ebdc6334a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca4ad8fe4bf312d64872a9ebdc6334a">&#9670;&nbsp;</a></span>replaceArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::replaceArguments </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>bvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_a_s_t_node.html">ASTNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences of each given name with the corresponding <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<p>For example, if the formula in this <a class="el" href="class_a_s_t_node.html">ASTNode</a> is <code>x - y</code>, and the function is called with bvars = {"x", "y"} and args = ASTNodes representing objects with names {"y", "x"}, the result would be <code>y - x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bvars</td><td>a vector of strings representing the variable names to be substituted. </td></tr>
    <tr><td class="paramname">args</td><td>a vector of ASTNodes representing the name/value/formula to use as a replacement for each variable name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a050c49267ec3f8d4d6f69126d89b7a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050c49267ec3f8d4d6f69126d89b7a9f">&#9670;&nbsp;</a></span>replaceChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::replaceChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>disownedChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delreplaced</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces and optionally deletes the nth child of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> with the given <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>unsigned int the index of the child to replace. </td></tr>
    <tr><td class="paramname">disownedChild</td><td><a class="el" href="class_a_s_t_node.html">ASTNode</a> to replace the nth child. Will become a child of the parent node. </td></tr>
    <tr><td class="paramname">delreplaced</td><td>Boolean indicating whether to delete the replaced child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicitly adding, removing or replacing children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> object may change the structure of the mathematical formula it represents, and may even render the representation invalid. Callers need to be careful to use this method in the context of other operations to create complete and correct formulas. The methodASTNode::isWellFormedASTNode() may also be useful for checking the results of node modifications.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>addChild(ASTNode* disownedChild) </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8" title="Adds the given node as a child of this ASTNode.">prependChild(ASTNode* disownedChild)</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8ceb6b332df118a1dfd3576b84f1c6e4" title="Inserts the given ASTNode at point n in the list of children of this ASTNode.">insertChild(unsigned int n, ASTNode* disownedChild)</a> </dd>
<dd>
removeChild(unsigned int n) </dd></dl>

</div>
</div>
<a id="a4c15eabddaca79ab5b24d40014ae8710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c15eabddaca79ab5b24d40014ae8710">&#9670;&nbsp;</a></span>returnsBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ASTNode::returnsBoolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em> = <code>NULL</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> (nonzero) if this node returns a Boolean type or <code>false</code> (zero) otherwise. </p>
<p>This function looks at the whole <a class="el" href="class_a_s_t_node.html">ASTNode</a> rather than just the top level of the <a class="el" href="class_a_s_t_node.html">ASTNode</a>. Thus it will consider return values from piecewise statements. In addition, if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> uses a function call, the return value of the functionDefinition will be determined. Note that this is only possible where the <a class="el" href="class_a_s_t_node.html">ASTNode</a> can trace its parent <a class="el" href="class_model.html">Model</a>, that is, the <a class="el" href="class_a_s_t_node.html">ASTNode</a> must represent the <code>&lt;math&gt;</code> element of some SBML object that has already been added to an instance of an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a>. If this is not the case, this function will return <code>false</code> unless <a class="el" href="class_a_s_t_node.html#a53001b84f9ea746a3caa12e4346c5e07" title="Returns true if this node has a Boolean type.">isBoolean()</a> returns <code>true</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a53001b84f9ea746a3caa12e4346c5e07" title="Returns true if this node has a Boolean type.">isBoolean()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> returns a Boolean, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5494556fb0158d211598dd94d12ec05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5494556fb0158d211598dd94d12ec05d">&#9670;&nbsp;</a></span>setCharacter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setCharacter </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given character. </p>
<p>If character is one of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> or <code>^</code>, the node type will be set accordingly. For all other characters, the node type will be set to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the character value to which the node's value should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af7fc605d22e1fb0fce89d7248ff84499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fc605d22e1fb0fce89d7248ff84499">&#9670;&nbsp;</a></span>setClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setClass </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>className</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML attribute <code>class</code> of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to <code>className</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">className</td><td><code>string</code> representing the MathML class for this node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a5b025a12c1a5b30630a9c9ba3f555225" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;class&quot;.">isSetClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a3c88d603fc91ae01b519ef36a813940f" title="Returns the MathML class attribute value of this ASTNode.">getClass()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a1e62030f74c9867ae6ddf2eab40b5ad9" title="Unsets the MathML class attribute of this ASTNode.">unsetClass()</a> </dd></dl>

</div>
</div>
<a id="a97e5715b8f4795e2b06c7264559d987d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5715b8f4795e2b06c7264559d987d">&#9670;&nbsp;</a></span>setId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML attribute <code>id</code> of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td><code>string</code> representing the identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a98d7af6077c4c113057f82cd5c43c735" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;id&quot;.">isSetId()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#aaa3ad6caed2fcd8438ccb45af6dc8119" title="Returns the MathML id attribute value of this ASTNode.">getId()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a38962e67843d2841404e68f87d77b722" title="Unsets the MathML id attribute of this ASTNode.">unsetId()</a> </dd></dl>

</div>
</div>
<a id="a8b45c89bbe89ac83d7139653609c30ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b45c89bbe89ac83d7139653609c30ba">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given name. </p>
<p>As a side effect, this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object's type will be reset to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> if (and <em>only if</em>) the <a class="el" href="class_a_s_t_node.html">ASTNode</a> was previously an operator ( <a class="el" href="class_a_s_t_node.html#a7d167168f1e9d062fd3f8f5f8cad951e" title="Returns true if this node is a mathematical operator.">isOperator()</a> <code>== true</code>), number ( <a class="el" href="class_a_s_t_node.html#aefb9fc75b2bd81663512ebce1886e4da" title="Returns true (nonzero) if this node contains a number, false (zero) otherwise.">isNumber()</a> <code>== true</code>), or unknown. This allows names to be set for <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> nodes and the like.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the string containing the name to which this node's value should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a35">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2d61b07a24f76637ad58eeb70acf8dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d61b07a24f76637ad58eeb70acf8dbc">&#9670;&nbsp;</a></span>setStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setStyle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MathML attribute <code>style</code> of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td><code>string</code> representing the identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a1a21ef4d79d048d8cf13d5ac83cab562" title="Returns true (nonzero) if this node has a value for the MathML attribute &quot;style&quot;.">isSetStyle()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a154b2a892c2a843dbc31b593cbf35863" title="Returns the MathML style attribute value of this ASTNode.">getStyle()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#af2be455b1eacf4e6854d5d10e36ab99a" title="Unsets the MathML style attribute of this ASTNode.">unsetStyle()</a> </dd></dl>

</div>
</div>
<a id="a08bad16b57e7c27da4f3110cffdc06ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bad16b57e7c27da4f3110cffdc06ff">&#9670;&nbsp;</a></span>setType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203">ASTNodeType_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given type code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type to which this node should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A side-effect of doing this is that any numerical values previously stored in this node are reset to zero. </dd></dl>

</div>
</div>
<a id="a8e96aa0f6056f3749d401b6fb3bd4371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e96aa0f6056f3749d401b6fb3bd4371">&#9670;&nbsp;</a></span>setUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to units. </p>
<p>The units will be set <em>only</em> if this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object represents a MathML <code>&lt;cn&gt;</code> element, i.e., represents a number. Callers may use <a class="el" href="class_a_s_t_node.html#aefb9fc75b2bd81663512ebce1886e4da" title="Returns true (nonzero) if this node contains a number, false (zero) otherwise.">isNumber()</a> to inquire whether the node is of that type.</p>
SBML Level&nbsp;3 Version&nbsp;1 introduced the ability to include an
attribute <code>sbml:units</code> on MathML <code>cn</code> elements
appearing in SBML mathematical formulas.  The value of this attribute can
be used to indicate the unit of measurement to be associated with the
number in the content of the <code>cn</code> element.  The value of this
attribute must be the identifier of a unit of measurement defined by SBML
or the enclosing Model.  Here, the <code>sbml</code> portion is an XML
namespace prefix that must be associated with the SBML namespace for SBML
Level&nbsp;3.  The following example illustrates how this attribute can be
used to define a number with value <code>10</code> and unit of measurement
<code>second</code>:
<pre class="fragment">&lt;math xmlns="http://www.w3.org/1998/Math/MathML"
      xmlns:sbml="http://www.sbml.org/sbml/level3/version1/core"&gt;
        &lt;cn type="integer" sbml:units="second"&gt; 10 &lt;/cn&gt;
&lt;/math&gt;
</pre>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td><code>string</code> representing the unit identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sbml:units</code> attribute is only available in SBML Level&#160;3. It may not be used in Levels 1&ndash;2 of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a9a00bda7e722f821e727176ef18ca4ae" title="Returns true (nonzero) if this node has the attribute sbml:units.">isSetUnits()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#abb708bfee4e451fbbad004b49060969d" title="Returns true (nonzero) if this node or any of its children nodes have the attribute sbml:units.">hasUnits()</a> </dd></dl>

</div>
</div>
<a id="adae163e5a31a74d62c665db0b9704220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae163e5a31a74d62c665db0b9704220">&#9670;&nbsp;</a></span>setUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the user data of this node. </p>
<p>The user data can be used by the application developer to attach custom information to the node. In case of a deep copy, this attribute will passed as it is. The attribute will be never interpreted by this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>specifies the new user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#aa50a009ade5d3e0bcf0ccd9f7598708a" title="Returns true if this node has a user data object.">isSetUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ad8763e789cfeb52b130c84567684b7af" title="Returns the user data that has been previously set via setUserData().">getUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a8d7f8301b10f3aed387a447473650ed5" title="Unsets the user data of this node.">unsetUserData()</a> </dd></dl>

</div>
</div>
<a id="ad672b2de729eaf8aa813234d15e15efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad672b2de729eaf8aa813234d15e15efa">&#9670;&nbsp;</a></span>setValue() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mantissa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given real (<code>double</code>) in two parts: the mantissa and the exponent. </p>
<p>The node type is set to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mantissa</td><td>the mantissa of this node's real-numbered value. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent of this node's real-numbered value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a49dad5ffb929e5f42955b57357902557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dad5ffb929e5f42955b57357902557">&#9670;&nbsp;</a></span>setValue() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given real (<code>double</code>) and sets the node type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>. </p>
<p>This is functionally equivalent to: </p><pre class="fragment">setValue(value, 0);
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the <code>double</code> format number to which this node's value should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a69097fbcbc9e0771573472049e249784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69097fbcbc9e0771573472049e249784">&#9670;&nbsp;</a></span>setValue() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given integer and sets the node type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to which this node's value should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af450115d10253bc42acaf39801c5a173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af450115d10253bc42acaf39801c5a173">&#9670;&nbsp;</a></span>setValue() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setValue </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given rational in two parts: the numerator and denominator. </p>
<p>The node type is set to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numerator</td><td>the numerator value of the rational. </td></tr>
    <tr><td class="paramname">denominator</td><td>the denominator value of the rational.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a38d4ced59cd23b76e0c332afe20ab0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d4ced59cd23b76e0c332afe20ab0f3">&#9670;&nbsp;</a></span>setValue() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::setValue </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given (<code>long</code>) integer and sets the node type to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to which this node's value should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad4df9cba1deec746bf142f98aa79e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4df9cba1deec746bf142f98aa79e150">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ASTNode::simplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa15b06fa2fc77b84b05b26b5fdbebf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15b06fa2fc77b84b05b26b5fdbebf23">&#9670;&nbsp;</a></span>swapChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::swapChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the children of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> object with the children of the given <a class="el" href="class_a_s_t_node.html">ASTNode</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>the other node whose children should be used to replace <em>this</em> node's children.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1e62030f74c9867ae6ddf2eab40b5ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e62030f74c9867ae6ddf2eab40b5ad9">&#9670;&nbsp;</a></span>unsetClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::unsetClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the MathML <code>class</code> attribute of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a38962e67843d2841404e68f87d77b722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38962e67843d2841404e68f87d77b722">&#9670;&nbsp;</a></span>unsetId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::unsetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the MathML <code>id</code> attribute of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2ba0713a2137fcbd3e9c4beb0e15276f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba0713a2137fcbd3e9c4beb0e15276f">&#9670;&nbsp;</a></span>unsetParentSBMLObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::unsetParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the parent SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#a63be31576eef23de0a5f2e40b48b6aee" title="Returns true if this node has a value for the parent SBML object.">isSetParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#a3e12c3633f7d19f03523925ff845aa91" title="Returns the parent SBML object.">getParentSBMLObject()</a> </dd>
<dd>
setParentSBMLObject() </dd></dl>

</div>
</div>
<a id="af2be455b1eacf4e6854d5d10e36ab99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2be455b1eacf4e6854d5d10e36ab99a">&#9670;&nbsp;</a></span>unsetStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::unsetStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the MathML <code>style</code> attribute of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8e20dfaf0e5e299e906e2bc5e6966527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e20dfaf0e5e299e906e2bc5e6966527">&#9670;&nbsp;</a></span>unsetUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::unsetUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the units of this <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8d7f8301b10f3aed387a447473650ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7f8301b10f3aed387a447473650ed5">&#9670;&nbsp;</a></span>unsetUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ASTNode::unsetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the user data of this node. </p>
<p>The user data can be used by the application developer to attach custom information to the node. In case of a deep copy, this attribute will passed as it is. The attribute will be never interpreted by this class.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node.">setUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#ad8763e789cfeb52b130c84567684b7af" title="Returns the user data that has been previously set via setUserData().">getUserData()</a> </dd>
<dd>
<a class="el" href="class_a_s_t_node.html#aa50a009ade5d3e0bcf0ccd9f7598708a" title="Returns true if this node has a user data object.">isSetUserData()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a709a4cfd50fb2e3e4a9799fe7e43eb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709a4cfd50fb2e3e4a9799fe7e43eb33">&#9670;&nbsp;</a></span>SBMLRateRuleConverter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_s_b_m_l_rate_rule_converter.html">SBMLRateRuleConverter</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
