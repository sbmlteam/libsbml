<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>libSBML C++ API: XMLNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.20.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_x_m_l_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_x_m_l_node-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">XMLNode Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for XMLNode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_x_m_l_node__inherit__graph.svg" width="98" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> A node in libSBML's XML document tree.</p>
<p>LibSBML implements an XML abstraction layer. This layer presents a uniform XML interface to calling programs regardless of which underlying XML parser libSBML has actually been configured to use. The basic data object in the XML abstraction is a <em>node</em>, represented by <a class="el" href="class_x_m_l_node.html">XMLNode</a>.</p>
<p>An <a class="el" href="class_x_m_l_node.html">XMLNode</a> can contain any number of children. Each child is another <a class="el" href="class_x_m_l_node.html">XMLNode</a>, thereby forming a tree. The methods <a class="el" href="class_x_m_l_node.html#a44be07ab2c8661102741f79d6fcc7b93" title="Returns the number of children for this XMLNode.">XMLNode::getNumChildren()</a> and <a class="el" href="class_x_m_l_node.html#a02d5d8c64c480eacf80941ad851deacd" title="Returns the nth child of this XMLNode.">XMLNode::getChild()</a> can be used to access the tree structure starting from a given node.</p>
<p>Each <a class="el" href="class_x_m_l_node.html">XMLNode</a> is subclassed from <a class="el" href="class_x_m_l_token.html">XMLToken</a>, and thus has the same methods available as <a class="el" href="class_x_m_l_token.html">XMLToken</a>. These methods include <a class="el" href="class_x_m_l_token.html#acf4ac2b2be53e5ef56632c9ec3bf0c25" title="Returns the XML namespaces declared for this token.">XMLToken::getNamespaces()</a>, <a class="el" href="class_x_m_l_token.html#aed5b4fbfad7ebd29e94feb092771ccf9" title="Returns the XML namespace prefix of token.">XMLToken::getPrefix()</a>, <a class="el" href="class_x_m_l_token.html#ab3a3f9fb7e0c88444ed43633bb18ec2f" title="Returns the (unqualified) name of token.">XMLToken::getName()</a>, <a class="el" href="class_x_m_l_token.html#a2b2c321b3c628fefb5c87c31e4d8dd9b" title="Returns the XML namespace URI of token.">XMLToken::getURI()</a>, and <a class="el" href="class_x_m_l_token.html#a25eb82b0e44aa0bad9af110041b319cf" title="Returns the attributes of the XML element represented by this token.">XMLToken::getAttributes()</a>.</p>
<h1><a class="anchor" id="xmlnode-str2xmlnode"></a>
Conversion between an XML string and an XMLNode</h1>
<p>LibSBML provides the following utility functions for converting an XML string (e.g., <code>&lt;annotation&gt;...&lt;/annotation&gt;</code>) to/from an <a class="el" href="class_x_m_l_node.html">XMLNode</a> object.</p>
<ul>
<li><a class="el" href="class_x_m_l_node.html#a9431852ad49f526a4bf3c9afdc95fe62" title="Returns a string representation of this XMLNode.">XMLNode::toXMLString()</a> returns a string representation of the <a class="el" href="class_x_m_l_node.html">XMLNode</a> object.</li>
</ul>
<ul>
<li><a class="el" href="class_x_m_l_node.html#a3b018589d7d8e2fdeff43b9c0045ea55" title="Returns a string representation of a given XMLNode.">XMLNode::convertXMLNodeToString()</a> (static function) returns a string representation of the given <a class="el" href="class_x_m_l_node.html">XMLNode</a> object.</li>
</ul>
<ul>
<li><a class="el" href="class_x_m_l_node.html#abe475aad26e52c716bb171ebfab85c39" title="Returns an XMLNode which is derived from a string containing XML content.">XMLNode::convertStringToXMLNode()</a> (static function) returns an <a class="el" href="class_x_m_l_node.html">XMLNode</a> object converted from the given XML string.</li>
</ul>
<p>The returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> object by <a class="el" href="class_x_m_l_node.html#abe475aad26e52c716bb171ebfab85c39" title="Returns an XMLNode which is derived from a string containing XML content.">XMLNode::convertStringToXMLNode()</a> is a dummy root (container) <a class="el" href="class_x_m_l_node.html">XMLNode</a> if the given XML string has two or more top-level elements (e.g., &quot;<code>&lt;p&gt;...&lt;/p&gt;&lt;p&gt;...&lt;/p&gt;</code>&quot;). In the dummy root node, each top-level element in the given XML string is contained as a child <a class="el" href="class_x_m_l_node.html">XMLNode</a>. <a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230" title="Returns true if this token is an end of file marker.">XMLToken::isEOF()</a> can be used to identify if the returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> object is a dummy node or not. Here is an example: </p><div class="fragment"><div class="line"><span class="comment">// Checks if the XMLNode object returned by XMLNode::convertStringToXMLNode()</span></div>
<div class="line"><span class="comment">// is a dummy root node:</span></div>
<div class="line"> </div>
<div class="line">std::string str = <span class="stringliteral">&quot;...&quot;</span>;</div>
<div class="line"><a class="code" href="class_x_m_l_node.html">XMLNode</a>* xn = <a class="code" href="class_x_m_l_node.html#abe475aad26e52c716bb171ebfab85c39">XMLNode::convertStringToXMLNode</a>(str);</div>
<div class="line"><span class="keywordflow">if</span> ( xn == NULL )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// returned value is null (error)</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ( xn-&gt;<a class="code" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230">isEOF</a>() )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Root node is a dummy node.</span></div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; xn-&gt;<a class="code" href="class_x_m_l_node.html#a44be07ab2c8661102741f79d6fcc7b93">getNumChildren</a>(); i++ )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// access to each child node of the dummy node.</span></div>
<div class="line">    <a class="code" href="class_x_m_l_node.html">XMLNode</a>&amp; xnChild = xn-&gt;<a class="code" href="class_x_m_l_node.html#a02d5d8c64c480eacf80941ad851deacd">getChild</a>(i);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Root node is NOT a dummy node.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclass_x_m_l_node_html"><div class="ttname"><a href="class_x_m_l_node.html">XMLNode</a></div><div class="ttdef"><b>Definition:</b> XMLNode.h:178</div></div>
<div class="ttc" id="aclass_x_m_l_node_html_a02d5d8c64c480eacf80941ad851deacd"><div class="ttname"><a href="class_x_m_l_node.html#a02d5d8c64c480eacf80941ad851deacd">XMLNode::getChild</a></div><div class="ttdeci">XMLNode &amp; getChild(unsigned int n)</div><div class="ttdoc">Returns the nth child of this XMLNode.</div><div class="ttdef"><b>Definition:</b> XMLNode.cpp:329</div></div>
<div class="ttc" id="aclass_x_m_l_node_html_a44be07ab2c8661102741f79d6fcc7b93"><div class="ttname"><a href="class_x_m_l_node.html#a44be07ab2c8661102741f79d6fcc7b93">XMLNode::getNumChildren</a></div><div class="ttdeci">unsigned int getNumChildren() const</div><div class="ttdoc">Returns the number of children for this XMLNode.</div><div class="ttdef"><b>Definition:</b> XMLNode.cpp:507</div></div>
<div class="ttc" id="aclass_x_m_l_node_html_abe475aad26e52c716bb171ebfab85c39"><div class="ttname"><a href="class_x_m_l_node.html#abe475aad26e52c716bb171ebfab85c39">XMLNode::convertStringToXMLNode</a></div><div class="ttdeci">static XMLNode * convertStringToXMLNode(const std::string &amp;xmlstr, const XMLNamespaces *xmlns=NULL)</div><div class="ttdoc">Returns an XMLNode which is derived from a string containing XML content.</div><div class="ttdef"><b>Definition:</b> XMLNode.cpp:607</div></div>
<div class="ttc" id="aclass_x_m_l_token_html_ae963b35615525f8af949373c5765a230"><div class="ttname"><a href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230">XMLToken::isEOF</a></div><div class="ttdeci">bool isEOF() const</div><div class="ttdoc">Returns true if this token is an end of file marker.</div><div class="ttdef"><b>Definition:</b> XMLToken.cpp:1145</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#_a19">addingEvidenceCodes_2.cpp</a>, and <a class="el" href="create_example_s_b_m_l_8cpp-example.html#_a57">createExampleSBML.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7567021b6e9f7d43c71ff9c625854266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a7567021b6e9f7d43c71ff9c625854266">addAttr</a> (const std::string &amp;name, const std::string &amp;value, const std::string namespaceURI=&quot;&quot;, const std::string prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:a7567021b6e9f7d43c71ff9c625854266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attribute to the XML element represented by this token.  <a href="class_x_m_l_token.html#a7567021b6e9f7d43c71ff9c625854266">More...</a><br /></td></tr>
<tr class="separator:a7567021b6e9f7d43c71ff9c625854266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4557b10140fcd61dab77f69c0b86b87d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a4557b10140fcd61dab77f69c0b86b87d">addAttr</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, const std::string &amp;value)</td></tr>
<tr class="memdesc:a4557b10140fcd61dab77f69c0b86b87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attribute to the XML element represented by this token.  <a href="class_x_m_l_token.html#a4557b10140fcd61dab77f69c0b86b87d">More...</a><br /></td></tr>
<tr class="separator:a4557b10140fcd61dab77f69c0b86b87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c25373a33be80bd0f28e54a80be2044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a1c25373a33be80bd0f28e54a80be2044">addChild</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;node)</td></tr>
<tr class="memdesc:a1c25373a33be80bd0f28e54a80be2044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of <code>node</code> as a child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a1c25373a33be80bd0f28e54a80be2044">More...</a><br /></td></tr>
<tr class="separator:a1c25373a33be80bd0f28e54a80be2044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b55c6dfa29b482c45d7f61e2a2abae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a51b55c6dfa29b482c45d7f61e2a2abae">addNamespace</a> (const std::string &amp;uri, const std::string prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:a51b55c6dfa29b482c45d7f61e2a2abae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an XML namespace declaration to this token.  <a href="class_x_m_l_token.html#a51b55c6dfa29b482c45d7f61e2a2abae">More...</a><br /></td></tr>
<tr class="separator:a51b55c6dfa29b482c45d7f61e2a2abae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e389f37be54e6abb0d11d89b40d91e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a64e389f37be54e6abb0d11d89b40d91e">append</a> (const std::string &amp;chars)</td></tr>
<tr class="memdesc:a64e389f37be54e6abb0d11d89b40d91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends characters to the text content of token.  <a href="class_x_m_l_token.html#a64e389f37be54e6abb0d11d89b40d91e">More...</a><br /></td></tr>
<tr class="separator:a64e389f37be54e6abb0d11d89b40d91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02317b2903faab5e4b5fa6bacd6ba185"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a02317b2903faab5e4b5fa6bacd6ba185">clearAttributes</a> ()</td></tr>
<tr class="memdesc:a02317b2903faab5e4b5fa6bacd6ba185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all attributes of this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.  <a href="class_x_m_l_token.html#a02317b2903faab5e4b5fa6bacd6ba185">More...</a><br /></td></tr>
<tr class="separator:a02317b2903faab5e4b5fa6bacd6ba185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9b94ff6797c5169056557ad137389f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a2b9b94ff6797c5169056557ad137389f">clearNamespaces</a> ()</td></tr>
<tr class="memdesc:a2b9b94ff6797c5169056557ad137389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all XML namespace declarations from this token.  <a href="class_x_m_l_token.html#a2b9b94ff6797c5169056557ad137389f">More...</a><br /></td></tr>
<tr class="separator:a2b9b94ff6797c5169056557ad137389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe27cb9b8f715a33c5a688b0e8ee88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a7bfe27cb9b8f715a33c5a688b0e8ee88">clone</a> () const</td></tr>
<tr class="memdesc:a7bfe27cb9b8f715a33c5a688b0e8ee88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a deep copy of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> object.  <a href="class_x_m_l_node.html#a7bfe27cb9b8f715a33c5a688b0e8ee88">More...</a><br /></td></tr>
<tr class="separator:a7bfe27cb9b8f715a33c5a688b0e8ee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c2a16b990471ca2c5da6f3bff5b9fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a56c2a16b990471ca2c5da6f3bff5b9fa">equals</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;other, bool ignoreURI=false, bool ignoreAttributeValues=false) const</td></tr>
<tr class="memdesc:a56c2a16b990471ca2c5da6f3bff5b9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this <a class="el" href="class_x_m_l_node.html">XMLNode</a> against another <a class="el" href="class_x_m_l_node.html">XMLNode</a> returning true if both nodes represent the same XML tree, or false otherwise.  <a href="class_x_m_l_node.html#a56c2a16b990471ca2c5da6f3bff5b9fa">More...</a><br /></td></tr>
<tr class="separator:a56c2a16b990471ca2c5da6f3bff5b9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb82b0e44aa0bad9af110041b319cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a25eb82b0e44aa0bad9af110041b319cf">getAttributes</a> () const</td></tr>
<tr class="memdesc:a25eb82b0e44aa0bad9af110041b319cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attributes of the XML element represented by this token.  <a href="class_x_m_l_token.html#a25eb82b0e44aa0bad9af110041b319cf">More...</a><br /></td></tr>
<tr class="separator:a25eb82b0e44aa0bad9af110041b319cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604907127dd25094f73f4723060cd6fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe">getAttributesLength</a> () const</td></tr>
<tr class="memdesc:a604907127dd25094f73f4723060cd6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.  <a href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe">More...</a><br /></td></tr>
<tr class="separator:a604907127dd25094f73f4723060cd6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7431330304746a92b730e9ccebbf3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#aee7431330304746a92b730e9ccebbf3f">getAttrIndex</a> (const std::string &amp;name, const std::string uri=&quot;&quot;) const</td></tr>
<tr class="memdesc:aee7431330304746a92b730e9ccebbf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the attribute with the given name and namespace URI.  <a href="class_x_m_l_token.html#aee7431330304746a92b730e9ccebbf3f">More...</a><br /></td></tr>
<tr class="separator:aee7431330304746a92b730e9ccebbf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10343edba950a6f22e5db2eb423996b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ac10343edba950a6f22e5db2eb423996b">getAttrIndex</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const</td></tr>
<tr class="memdesc:ac10343edba950a6f22e5db2eb423996b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the attribute defined by the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object.  <a href="class_x_m_l_token.html#ac10343edba950a6f22e5db2eb423996b">More...</a><br /></td></tr>
<tr class="separator:ac10343edba950a6f22e5db2eb423996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb770a8721bb24f8c1a1e00046ab9304"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#abb770a8721bb24f8c1a1e00046ab9304">getAttrName</a> (int index) const</td></tr>
<tr class="memdesc:abb770a8721bb24f8c1a1e00046ab9304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the <em>n</em>th attribute in this token's list of attributes.  <a href="class_x_m_l_token.html#abb770a8721bb24f8c1a1e00046ab9304">More...</a><br /></td></tr>
<tr class="separator:abb770a8721bb24f8c1a1e00046ab9304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e28928fbea3163a2b537b20a05bb58"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ae4e28928fbea3163a2b537b20a05bb58">getAttrPrefix</a> (int index) const</td></tr>
<tr class="memdesc:ae4e28928fbea3163a2b537b20a05bb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefix of the <em>n</em>th attribute in this token's list of attributes.  <a href="class_x_m_l_token.html#ae4e28928fbea3163a2b537b20a05bb58">More...</a><br /></td></tr>
<tr class="separator:ae4e28928fbea3163a2b537b20a05bb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ae14a78885898cac9080c1955274da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a87ae14a78885898cac9080c1955274da">getAttrPrefixedName</a> (int index) const</td></tr>
<tr class="memdesc:a87ae14a78885898cac9080c1955274da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefixed name of the <em>n</em>th attribute in this token's list of attributes.  <a href="class_x_m_l_token.html#a87ae14a78885898cac9080c1955274da">More...</a><br /></td></tr>
<tr class="separator:a87ae14a78885898cac9080c1955274da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce0b4af23c52c79d6868952c3c8476e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a3ce0b4af23c52c79d6868952c3c8476e">getAttrURI</a> (int index) const</td></tr>
<tr class="memdesc:a3ce0b4af23c52c79d6868952c3c8476e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace URI of the <em>n</em>th attribute in this token's list of attributes.  <a href="class_x_m_l_token.html#a3ce0b4af23c52c79d6868952c3c8476e">More...</a><br /></td></tr>
<tr class="separator:a3ce0b4af23c52c79d6868952c3c8476e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadcb807680c7a330c7ea9b313d3d6ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#abadcb807680c7a330c7ea9b313d3d6ef">getAttrValue</a> (const std::string &amp;name, const std::string uri=&quot;&quot;) const</td></tr>
<tr class="memdesc:abadcb807680c7a330c7ea9b313d3d6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the attribute with a given name and XML namespace URI.  <a href="class_x_m_l_token.html#abadcb807680c7a330c7ea9b313d3d6ef">More...</a><br /></td></tr>
<tr class="separator:abadcb807680c7a330c7ea9b313d3d6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e8af3d2160c327cc8ed955c567499c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ac1e8af3d2160c327cc8ed955c567499c">getAttrValue</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const</td></tr>
<tr class="memdesc:ac1e8af3d2160c327cc8ed955c567499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the attribute specified by a given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object.  <a href="class_x_m_l_token.html#ac1e8af3d2160c327cc8ed955c567499c">More...</a><br /></td></tr>
<tr class="separator:ac1e8af3d2160c327cc8ed955c567499c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa104c724eb5b1d696a7b9776d6cc36bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#aa104c724eb5b1d696a7b9776d6cc36bc">getAttrValue</a> (int index) const</td></tr>
<tr class="memdesc:aa104c724eb5b1d696a7b9776d6cc36bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the <em>n</em>th attribute in this token's list of attributes.  <a href="class_x_m_l_token.html#aa104c724eb5b1d696a7b9776d6cc36bc">More...</a><br /></td></tr>
<tr class="separator:aa104c724eb5b1d696a7b9776d6cc36bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea8ba88316d9eba5eee22ab5d89c196"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#abea8ba88316d9eba5eee22ab5d89c196">getCharacters</a> () const</td></tr>
<tr class="memdesc:abea8ba88316d9eba5eee22ab5d89c196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character text of token.  <a href="class_x_m_l_token.html#abea8ba88316d9eba5eee22ab5d89c196">More...</a><br /></td></tr>
<tr class="separator:abea8ba88316d9eba5eee22ab5d89c196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13604a6e392a8526bd70eda48f6e7200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a13604a6e392a8526bd70eda48f6e7200">getChild</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a13604a6e392a8526bd70eda48f6e7200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the corresponding name.  <a href="class_x_m_l_node.html#a13604a6e392a8526bd70eda48f6e7200">More...</a><br /></td></tr>
<tr class="separator:a13604a6e392a8526bd70eda48f6e7200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2240d7a21e9990355d1502d10fa9f024"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a2240d7a21e9990355d1502d10fa9f024">getChild</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a2240d7a21e9990355d1502d10fa9f024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the corresponding name.  <a href="class_x_m_l_node.html#a2240d7a21e9990355d1502d10fa9f024">More...</a><br /></td></tr>
<tr class="separator:a2240d7a21e9990355d1502d10fa9f024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d5d8c64c480eacf80941ad851deacd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a02d5d8c64c480eacf80941ad851deacd">getChild</a> (unsigned int n)</td></tr>
<tr class="memdesc:a02d5d8c64c480eacf80941ad851deacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a02d5d8c64c480eacf80941ad851deacd">More...</a><br /></td></tr>
<tr class="separator:a02d5d8c64c480eacf80941ad851deacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe90fba581502c48f5931742bb51b4a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#abe90fba581502c48f5931742bb51b4a7">getChild</a> (unsigned int n) const</td></tr>
<tr class="memdesc:abe90fba581502c48f5931742bb51b4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#abe90fba581502c48f5931742bb51b4a7">More...</a><br /></td></tr>
<tr class="separator:abe90fba581502c48f5931742bb51b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891be63a2aa15685febbb658e70c4328"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a891be63a2aa15685febbb658e70c4328">getColumn</a> () const</td></tr>
<tr class="memdesc:a891be63a2aa15685febbb658e70c4328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column number at which this token occurs in the input.  <a href="class_x_m_l_token.html#a891be63a2aa15685febbb658e70c4328">More...</a><br /></td></tr>
<tr class="separator:a891be63a2aa15685febbb658e70c4328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55928de887e58bb62fc3f558739b2daa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a55928de887e58bb62fc3f558739b2daa">getIndex</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a55928de887e58bb62fc3f558739b2daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given name.  <a href="class_x_m_l_node.html#a55928de887e58bb62fc3f558739b2daa">More...</a><br /></td></tr>
<tr class="separator:a55928de887e58bb62fc3f558739b2daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07687edeb6cd5d5e1b57c93afb772300"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a07687edeb6cd5d5e1b57c93afb772300">getLine</a> () const</td></tr>
<tr class="memdesc:a07687edeb6cd5d5e1b57c93afb772300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number at which this token occurs in the input.  <a href="class_x_m_l_token.html#a07687edeb6cd5d5e1b57c93afb772300">More...</a><br /></td></tr>
<tr class="separator:a07687edeb6cd5d5e1b57c93afb772300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a3f9fb7e0c88444ed43633bb18ec2f"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ab3a3f9fb7e0c88444ed43633bb18ec2f">getName</a> () const</td></tr>
<tr class="memdesc:ab3a3f9fb7e0c88444ed43633bb18ec2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (unqualified) name of token.  <a href="class_x_m_l_token.html#ab3a3f9fb7e0c88444ed43633bb18ec2f">More...</a><br /></td></tr>
<tr class="separator:ab3a3f9fb7e0c88444ed43633bb18ec2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e2dcbc76a8b620deb29f3b3b31a193"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a30e2dcbc76a8b620deb29f3b3b31a193">getNamespaceIndex</a> (const std::string &amp;uri) const</td></tr>
<tr class="memdesc:a30e2dcbc76a8b620deb29f3b3b31a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of an XML namespace declaration based on its URI.  <a href="class_x_m_l_token.html#a30e2dcbc76a8b620deb29f3b3b31a193">More...</a><br /></td></tr>
<tr class="separator:a30e2dcbc76a8b620deb29f3b3b31a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5d62bdfabe74e06a989dff5c48d587"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a1d5d62bdfabe74e06a989dff5c48d587">getNamespaceIndexByPrefix</a> (const std::string &amp;prefix) const</td></tr>
<tr class="memdesc:a1d5d62bdfabe74e06a989dff5c48d587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of an XML namespace declaration based on its prefix.  <a href="class_x_m_l_token.html#a1d5d62bdfabe74e06a989dff5c48d587">More...</a><br /></td></tr>
<tr class="separator:a1d5d62bdfabe74e06a989dff5c48d587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920b2de814716d4828a809c2d1db7be9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a920b2de814716d4828a809c2d1db7be9">getNamespacePrefix</a> (const std::string &amp;uri) const</td></tr>
<tr class="memdesc:a920b2de814716d4828a809c2d1db7be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefix associated with a given XML namespace URI on this token.  <a href="class_x_m_l_token.html#a920b2de814716d4828a809c2d1db7be9">More...</a><br /></td></tr>
<tr class="separator:a920b2de814716d4828a809c2d1db7be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab553ac8a68a9856404b064ffa823d2c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ab553ac8a68a9856404b064ffa823d2c0">getNamespacePrefix</a> (int index) const</td></tr>
<tr class="memdesc:ab553ac8a68a9856404b064ffa823d2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefix of the <em>n</em>th XML namespace declaration.  <a href="class_x_m_l_token.html#ab553ac8a68a9856404b064ffa823d2c0">More...</a><br /></td></tr>
<tr class="separator:ab553ac8a68a9856404b064ffa823d2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4ac2b2be53e5ef56632c9ec3bf0c25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#acf4ac2b2be53e5ef56632c9ec3bf0c25">getNamespaces</a> () const</td></tr>
<tr class="memdesc:acf4ac2b2be53e5ef56632c9ec3bf0c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespaces declared for this token.  <a href="class_x_m_l_token.html#acf4ac2b2be53e5ef56632c9ec3bf0c25">More...</a><br /></td></tr>
<tr class="separator:acf4ac2b2be53e5ef56632c9ec3bf0c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af59569ca097bc9695f7deb0131e2dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a6af59569ca097bc9695f7deb0131e2dd">getNamespacesLength</a> () const</td></tr>
<tr class="memdesc:a6af59569ca097bc9695f7deb0131e2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of XML namespaces declared on this token.  <a href="class_x_m_l_token.html#a6af59569ca097bc9695f7deb0131e2dd">More...</a><br /></td></tr>
<tr class="separator:a6af59569ca097bc9695f7deb0131e2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61535e4ef04bce910183b3565afe262"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ac61535e4ef04bce910183b3565afe262">getNamespaceURI</a> (const std::string prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:ac61535e4ef04bce910183b3565afe262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the URI of an XML namespace with a given prefix.  <a href="class_x_m_l_token.html#ac61535e4ef04bce910183b3565afe262">More...</a><br /></td></tr>
<tr class="separator:ac61535e4ef04bce910183b3565afe262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c8a9e4b3cd5522290b87b193722a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#adb1c8a9e4b3cd5522290b87b193722a1">getNamespaceURI</a> (int index) const</td></tr>
<tr class="memdesc:adb1c8a9e4b3cd5522290b87b193722a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the URI of the <em>n</em>th XML namespace declared on this token.  <a href="class_x_m_l_token.html#adb1c8a9e4b3cd5522290b87b193722a1">More...</a><br /></td></tr>
<tr class="separator:adb1c8a9e4b3cd5522290b87b193722a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44be07ab2c8661102741f79d6fcc7b93"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a44be07ab2c8661102741f79d6fcc7b93">getNumChildren</a> () const</td></tr>
<tr class="memdesc:a44be07ab2c8661102741f79d6fcc7b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children for this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a44be07ab2c8661102741f79d6fcc7b93">More...</a><br /></td></tr>
<tr class="separator:a44be07ab2c8661102741f79d6fcc7b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b4fbfad7ebd29e94feb092771ccf9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#aed5b4fbfad7ebd29e94feb092771ccf9">getPrefix</a> () const</td></tr>
<tr class="memdesc:aed5b4fbfad7ebd29e94feb092771ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace prefix of token.  <a href="class_x_m_l_token.html#aed5b4fbfad7ebd29e94feb092771ccf9">More...</a><br /></td></tr>
<tr class="separator:aed5b4fbfad7ebd29e94feb092771ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c321b3c628fefb5c87c31e4d8dd9b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a2b2c321b3c628fefb5c87c31e4d8dd9b">getURI</a> () const</td></tr>
<tr class="memdesc:a2b2c321b3c628fefb5c87c31e4d8dd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace URI of token.  <a href="class_x_m_l_token.html#a2b2c321b3c628fefb5c87c31e4d8dd9b">More...</a><br /></td></tr>
<tr class="separator:a2b2c321b3c628fefb5c87c31e4d8dd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928dd71b5da0f4e630b1f18c6d68b890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a928dd71b5da0f4e630b1f18c6d68b890">hasAttr</a> (const std::string &amp;name, const std::string uri=&quot;&quot;) const</td></tr>
<tr class="memdesc:a928dd71b5da0f4e630b1f18c6d68b890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute with a given name and namespace URI exists.  <a href="class_x_m_l_token.html#a928dd71b5da0f4e630b1f18c6d68b890">More...</a><br /></td></tr>
<tr class="separator:a928dd71b5da0f4e630b1f18c6d68b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2d75e7a15853c83d61aaec4900e116"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a0b2d75e7a15853c83d61aaec4900e116">hasAttr</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const</td></tr>
<tr class="memdesc:a0b2d75e7a15853c83d61aaec4900e116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute defined by a given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object exists.  <a href="class_x_m_l_token.html#a0b2d75e7a15853c83d61aaec4900e116">More...</a><br /></td></tr>
<tr class="separator:a0b2d75e7a15853c83d61aaec4900e116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5903003d559f9d0290fd60e41366c2e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5">hasAttr</a> (int index) const</td></tr>
<tr class="memdesc:a5903003d559f9d0290fd60e41366c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute with the given index exists.  <a href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5">More...</a><br /></td></tr>
<tr class="separator:a5903003d559f9d0290fd60e41366c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5a6a3b186debd410f18574a563de10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a5e5a6a3b186debd410f18574a563de10">hasChild</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5e5a6a3b186debd410f18574a563de10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean indicating whether this <a class="el" href="class_x_m_l_node.html">XMLNode</a> has a child with the given name.  <a href="class_x_m_l_node.html#a5e5a6a3b186debd410f18574a563de10">More...</a><br /></td></tr>
<tr class="separator:a5e5a6a3b186debd410f18574a563de10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0f09a70ce764293a973c97a7e8de4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a0c0f09a70ce764293a973c97a7e8de4a">hasNamespaceNS</a> (const std::string &amp;uri, const std::string &amp;prefix) const</td></tr>
<tr class="memdesc:a0c0f09a70ce764293a973c97a7e8de4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token has an XML namespace with a given prefix and URI combination.  <a href="class_x_m_l_token.html#a0c0f09a70ce764293a973c97a7e8de4a">More...</a><br /></td></tr>
<tr class="separator:a0c0f09a70ce764293a973c97a7e8de4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88741070d315153c08db66d5fcd4069f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a88741070d315153c08db66d5fcd4069f">hasNamespacePrefix</a> (const std::string &amp;prefix) const</td></tr>
<tr class="memdesc:a88741070d315153c08db66d5fcd4069f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token has an XML namespace with a given prefix.  <a href="class_x_m_l_token.html#a88741070d315153c08db66d5fcd4069f">More...</a><br /></td></tr>
<tr class="separator:a88741070d315153c08db66d5fcd4069f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ff7469fc6d34a1f797da9901f2f1dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a19ff7469fc6d34a1f797da9901f2f1dd">hasNamespaceURI</a> (const std::string &amp;uri) const</td></tr>
<tr class="memdesc:a19ff7469fc6d34a1f797da9901f2f1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token has an XML namespace with a given URI.  <a href="class_x_m_l_token.html#a19ff7469fc6d34a1f797da9901f2f1dd">More...</a><br /></td></tr>
<tr class="separator:a19ff7469fc6d34a1f797da9901f2f1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22439cd49bfddd49f36474e2bc23c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#ab22439cd49bfddd49f36474e2bc23c95">insertChild</a> (unsigned int n, const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;node)</td></tr>
<tr class="memdesc:ab22439cd49bfddd49f36474e2bc23c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given node as the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#ab22439cd49bfddd49f36474e2bc23c95">More...</a><br /></td></tr>
<tr class="separator:ab22439cd49bfddd49f36474e2bc23c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c094a5459116dc8ca1f93bdaf1b0949"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a2c094a5459116dc8ca1f93bdaf1b0949">isAttributesEmpty</a> () const</td></tr>
<tr class="memdesc:a2c094a5459116dc8ca1f93bdaf1b0949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token has no attributes.  <a href="class_x_m_l_token.html#a2c094a5459116dc8ca1f93bdaf1b0949">More...</a><br /></td></tr>
<tr class="separator:a2c094a5459116dc8ca1f93bdaf1b0949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8833beadc3f06ae3e4b6cdfcac322ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef">isElement</a> () const</td></tr>
<tr class="memdesc:aa8833beadc3f06ae3e4b6cdfcac322ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token represents an XML element.  <a href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef">More...</a><br /></td></tr>
<tr class="separator:aa8833beadc3f06ae3e4b6cdfcac322ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a44a5db108d63aadf29b326bda3d21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21">isEnd</a> () const</td></tr>
<tr class="memdesc:ad0a44a5db108d63aadf29b326bda3d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token represents an XML end element.  <a href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21">More...</a><br /></td></tr>
<tr class="separator:ad0a44a5db108d63aadf29b326bda3d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee7d11da59a3ff1ca2af7d3c46ae27d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a3ee7d11da59a3ff1ca2af7d3c46ae27d">isEndFor</a> (const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;element) const</td></tr>
<tr class="memdesc:a3ee7d11da59a3ff1ca2af7d3c46ae27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token represents an XML end element for a particular start element.  <a href="class_x_m_l_token.html#a3ee7d11da59a3ff1ca2af7d3c46ae27d">More...</a><br /></td></tr>
<tr class="separator:a3ee7d11da59a3ff1ca2af7d3c46ae27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae963b35615525f8af949373c5765a230"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230">isEOF</a> () const</td></tr>
<tr class="memdesc:ae963b35615525f8af949373c5765a230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token is an end of file marker.  <a href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230">More...</a><br /></td></tr>
<tr class="separator:ae963b35615525f8af949373c5765a230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d7db81e24d4f90081be80652c089e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a57d7db81e24d4f90081be80652c089e7">isNamespacesEmpty</a> () const</td></tr>
<tr class="memdesc:a57d7db81e24d4f90081be80652c089e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if there are no namespaces declared on this token.  <a href="class_x_m_l_token.html#a57d7db81e24d4f90081be80652c089e7">More...</a><br /></td></tr>
<tr class="separator:a57d7db81e24d4f90081be80652c089e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7cb99aac8335048f2654af9582f6c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9">isStart</a> () const</td></tr>
<tr class="memdesc:ade7cb99aac8335048f2654af9582f6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token represents an XML start element.  <a href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9">More...</a><br /></td></tr>
<tr class="separator:ade7cb99aac8335048f2654af9582f6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f9506affaefd91d24150d15a21281"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281">isText</a> () const</td></tr>
<tr class="memdesc:a9e5f9506affaefd91d24150d15a21281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this token represents an XML text element.  <a href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281">More...</a><br /></td></tr>
<tr class="separator:a9e5f9506affaefd91d24150d15a21281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a099f21de99b8a4cbb7f78a211efb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a13a099f21de99b8a4cbb7f78a211efb6">operator=</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;rhs)</td></tr>
<tr class="memdesc:a13a099f21de99b8a4cbb7f78a211efb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a13a099f21de99b8a4cbb7f78a211efb6">More...</a><br /></td></tr>
<tr class="separator:a13a099f21de99b8a4cbb7f78a211efb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069eb01ce499152e7da6d890db4232de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a069eb01ce499152e7da6d890db4232de">removeAttr</a> (const std::string &amp;name, const std::string uri=&quot;&quot;)</td></tr>
<tr class="memdesc:a069eb01ce499152e7da6d890db4232de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an attribute from the XML element represented by this token.  <a href="class_x_m_l_token.html#a069eb01ce499152e7da6d890db4232de">More...</a><br /></td></tr>
<tr class="separator:a069eb01ce499152e7da6d890db4232de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9684376f7f4e2df66dd2b00496464b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#acd9684376f7f4e2df66dd2b00496464b">removeAttr</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple)</td></tr>
<tr class="memdesc:acd9684376f7f4e2df66dd2b00496464b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an attribute from the XML element represented by this token.  <a href="class_x_m_l_token.html#acd9684376f7f4e2df66dd2b00496464b">More...</a><br /></td></tr>
<tr class="separator:acd9684376f7f4e2df66dd2b00496464b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed4e8119bc50559a88b95c2e7932090"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a4ed4e8119bc50559a88b95c2e7932090">removeAttr</a> (int n)</td></tr>
<tr class="memdesc:a4ed4e8119bc50559a88b95c2e7932090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <em>n</em>th attribute from the XML element represented by this token.  <a href="class_x_m_l_token.html#a4ed4e8119bc50559a88b95c2e7932090">More...</a><br /></td></tr>
<tr class="separator:a4ed4e8119bc50559a88b95c2e7932090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a5bb2c6a951f76212675caa399377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a2d7a5bb2c6a951f76212675caa399377">removeChild</a> (unsigned int n)</td></tr>
<tr class="memdesc:a2d7a5bb2c6a951f76212675caa399377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> and returns the removed node.  <a href="class_x_m_l_node.html#a2d7a5bb2c6a951f76212675caa399377">More...</a><br /></td></tr>
<tr class="separator:a2d7a5bb2c6a951f76212675caa399377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1911ddafee6f3bce0fcf5885f3b9cd16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a1911ddafee6f3bce0fcf5885f3b9cd16">removeChildren</a> ()</td></tr>
<tr class="memdesc:a1911ddafee6f3bce0fcf5885f3b9cd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children from this node.  <a href="class_x_m_l_node.html#a1911ddafee6f3bce0fcf5885f3b9cd16">More...</a><br /></td></tr>
<tr class="separator:a1911ddafee6f3bce0fcf5885f3b9cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8477f21eedb02196088d22c2f5bfde3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#af8477f21eedb02196088d22c2f5bfde3">removeNamespace</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af8477f21eedb02196088d22c2f5bfde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an XML namespace declaration having a given prefix.  <a href="class_x_m_l_token.html#af8477f21eedb02196088d22c2f5bfde3">More...</a><br /></td></tr>
<tr class="separator:af8477f21eedb02196088d22c2f5bfde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493ef1d8677dd4b95e9ac55b61ba69be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a493ef1d8677dd4b95e9ac55b61ba69be">removeNamespace</a> (int index)</td></tr>
<tr class="memdesc:a493ef1d8677dd4b95e9ac55b61ba69be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <em>n</em>th XML namespace declaration.  <a href="class_x_m_l_token.html#a493ef1d8677dd4b95e9ac55b61ba69be">More...</a><br /></td></tr>
<tr class="separator:a493ef1d8677dd4b95e9ac55b61ba69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7f047728380a22c17ec735287da6de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a5f7f047728380a22c17ec735287da6de">setAttributes</a> (const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;attributes)</td></tr>
<tr class="memdesc:a5f7f047728380a22c17ec735287da6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the attributes on the XML element represented by this token.  <a href="class_x_m_l_token.html#a5f7f047728380a22c17ec735287da6de">More...</a><br /></td></tr>
<tr class="separator:a5f7f047728380a22c17ec735287da6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1a6af2872acb75f6f32dd91018c48d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a8d1a6af2872acb75f6f32dd91018c48d">setCharacters</a> (const std::string &amp;chars)</td></tr>
<tr class="memdesc:a8d1a6af2872acb75f6f32dd91018c48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the characters for this <a class="el" href="class_x_m_l_token.html">XMLToken</a>.  <a href="class_x_m_l_token.html#a8d1a6af2872acb75f6f32dd91018c48d">More...</a><br /></td></tr>
<tr class="separator:a8d1a6af2872acb75f6f32dd91018c48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85783786e0219ac1d822e37df460b587"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a85783786e0219ac1d822e37df460b587">setEnd</a> ()</td></tr>
<tr class="memdesc:a85783786e0219ac1d822e37df460b587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this token represents an XML element end tag.  <a href="class_x_m_l_token.html#a85783786e0219ac1d822e37df460b587">More...</a><br /></td></tr>
<tr class="separator:a85783786e0219ac1d822e37df460b587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce5f5ffe6df85ab02124abf91c6b61a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a6ce5f5ffe6df85ab02124abf91c6b61a">setEOF</a> ()</td></tr>
<tr class="memdesc:a6ce5f5ffe6df85ab02124abf91c6b61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this token is an end-of-file/input marker.  <a href="class_x_m_l_token.html#a6ce5f5ffe6df85ab02124abf91c6b61a">More...</a><br /></td></tr>
<tr class="separator:a6ce5f5ffe6df85ab02124abf91c6b61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ad2e51f7948cdafb6773ca068e5eb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a03ad2e51f7948cdafb6773ca068e5eb5">setNamespaces</a> (const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> &amp;namespaces)</td></tr>
<tr class="memdesc:a03ad2e51f7948cdafb6773ca068e5eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the XML namespaces on this XML element.  <a href="class_x_m_l_token.html#a03ad2e51f7948cdafb6773ca068e5eb5">More...</a><br /></td></tr>
<tr class="separator:a03ad2e51f7948cdafb6773ca068e5eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e1b33f0a4304905e256958e67ad9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a774e1b33f0a4304905e256958e67ad9a">setTriple</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple)</td></tr>
<tr class="memdesc:a774e1b33f0a4304905e256958e67ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name, namespace prefix and namespace URI of this token.  <a href="class_x_m_l_token.html#a774e1b33f0a4304905e256958e67ad9a">More...</a><br /></td></tr>
<tr class="separator:a774e1b33f0a4304905e256958e67ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f80ab90e7f1509b2828686c1d96490a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#a9f80ab90e7f1509b2828686c1d96490a">toString</a> ()</td></tr>
<tr class="memdesc:a9f80ab90e7f1509b2828686c1d96490a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a string representation of the underlying token stream.  <a href="class_x_m_l_token.html#a9f80ab90e7f1509b2828686c1d96490a">More...</a><br /></td></tr>
<tr class="separator:a9f80ab90e7f1509b2828686c1d96490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9431852ad49f526a4bf3c9afdc95fe62"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a9431852ad49f526a4bf3c9afdc95fe62">toXMLString</a> () const</td></tr>
<tr class="memdesc:a9431852ad49f526a4bf3c9afdc95fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a9431852ad49f526a4bf3c9afdc95fe62">More...</a><br /></td></tr>
<tr class="separator:a9431852ad49f526a4bf3c9afdc95fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b55ffbe6762bf67cae0af092f4bd59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_token.html#ac7b55ffbe6762bf67cae0af092f4bd59">unsetEnd</a> ()</td></tr>
<tr class="memdesc:ac7b55ffbe6762bf67cae0af092f4bd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this token no longer represents an XML start/end element.  <a href="class_x_m_l_token.html#ac7b55ffbe6762bf67cae0af092f4bd59">More...</a><br /></td></tr>
<tr class="separator:ac7b55ffbe6762bf67cae0af092f4bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b115adfb642594107854189559ff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a719b115adfb642594107854189559ff2">XMLNode</a> ()</td></tr>
<tr class="memdesc:a719b115adfb642594107854189559ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty <a class="el" href="class_x_m_l_node.html">XMLNode</a> with no children.  <a href="class_x_m_l_node.html#a719b115adfb642594107854189559ff2">More...</a><br /></td></tr>
<tr class="separator:a719b115adfb642594107854189559ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc5570614d9ee24d8bbd62ec3ec56a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a6bc5570614d9ee24d8bbd62ec3ec56a3">XMLNode</a> (const std::string &amp;chars, const unsigned int line=0, const unsigned int column=0)</td></tr>
<tr class="memdesc:a6bc5570614d9ee24d8bbd62ec3ec56a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a text <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a6bc5570614d9ee24d8bbd62ec3ec56a3">More...</a><br /></td></tr>
<tr class="separator:a6bc5570614d9ee24d8bbd62ec3ec56a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac86771ab653407944a03a4cf215c602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#aac86771ab653407944a03a4cf215c602">XMLNode</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;orig)</td></tr>
<tr class="memdesc:aac86771ab653407944a03a4cf215c602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; creates a copy of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#aac86771ab653407944a03a4cf215c602">More...</a><br /></td></tr>
<tr class="separator:aac86771ab653407944a03a4cf215c602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21843419c9e9725e3e3089e5ddfa7e2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a21843419c9e9725e3e3089e5ddfa7e2c">XMLNode</a> (const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;token)</td></tr>
<tr class="memdesc:a21843419c9e9725e3e3089e5ddfa7e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_x_m_l_node.html">XMLNode</a> by copying an <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.  <a href="class_x_m_l_node.html#a21843419c9e9725e3e3089e5ddfa7e2c">More...</a><br /></td></tr>
<tr class="separator:a21843419c9e9725e3e3089e5ddfa7e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2fbc1a3e6cbbf090b1e338be287bd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a5b2fbc1a3e6cbbf090b1e338be287bd9">XMLNode</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, const unsigned int line=0, const unsigned int column=0)</td></tr>
<tr class="memdesc:a5b2fbc1a3e6cbbf090b1e338be287bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an end element <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a5b2fbc1a3e6cbbf090b1e338be287bd9">More...</a><br /></td></tr>
<tr class="separator:a5b2fbc1a3e6cbbf090b1e338be287bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39b71036a280ba768bf4c0429faf82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a0d39b71036a280ba768bf4c0429faf82">XMLNode</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;attributes, const unsigned int line=0, const unsigned int column=0)</td></tr>
<tr class="memdesc:a0d39b71036a280ba768bf4c0429faf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a start element <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given set of attributes.  <a href="class_x_m_l_node.html#a0d39b71036a280ba768bf4c0429faf82">More...</a><br /></td></tr>
<tr class="separator:a0d39b71036a280ba768bf4c0429faf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ee7242a58c6ce81b20ef1388dae21d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a34ee7242a58c6ce81b20ef1388dae21d">XMLNode</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;attributes, const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> &amp;namespaces, const unsigned int line=0, const unsigned int column=0)</td></tr>
<tr class="memdesc:a34ee7242a58c6ce81b20ef1388dae21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new start element <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given set of attributes and namespace declarations.  <a href="class_x_m_l_node.html#a34ee7242a58c6ce81b20ef1388dae21d">More...</a><br /></td></tr>
<tr class="separator:a34ee7242a58c6ce81b20ef1388dae21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae652023d7f98430de2027471ef9d9065"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#ae652023d7f98430de2027471ef9d9065">~XMLNode</a> ()</td></tr>
<tr class="memdesc:ae652023d7f98430de2027471ef9d9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#ae652023d7f98430de2027471ef9d9065">More...</a><br /></td></tr>
<tr class="separator:ae652023d7f98430de2027471ef9d9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe475aad26e52c716bb171ebfab85c39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#abe475aad26e52c716bb171ebfab85c39">convertStringToXMLNode</a> (const std::string &amp;xmlstr, const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *xmlns=NULL)</td></tr>
<tr class="memdesc:abe475aad26e52c716bb171ebfab85c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_x_m_l_node.html">XMLNode</a> which is derived from a string containing XML content.  <a href="class_x_m_l_node.html#abe475aad26e52c716bb171ebfab85c39">More...</a><br /></td></tr>
<tr class="separator:abe475aad26e52c716bb171ebfab85c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b018589d7d8e2fdeff43b9c0045ea55"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a3b018589d7d8e2fdeff43b9c0045ea55">convertXMLNodeToString</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a3b018589d7d8e2fdeff43b9c0045ea55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a given <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_x_m_l_node.html#a3b018589d7d8e2fdeff43b9c0045ea55">More...</a><br /></td></tr>
<tr class="separator:a3b018589d7d8e2fdeff43b9c0045ea55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c5ed08d70c430e20a5d53e9478ac90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_node.html#a65c5ed08d70c430e20a5d53e9478ac90">readXMLNodeFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a65c5ed08d70c430e20a5d53e9478ac90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="class_x_m_l_node.html">XMLNode</a> which is readfrom a file containing XML content.  <a href="class_x_m_l_node.html#a65c5ed08d70c430e20a5d53e9478ac90">More...</a><br /></td></tr>
<tr class="separator:a65c5ed08d70c430e20a5d53e9478ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a719b115adfb642594107854189559ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b115adfb642594107854189559ff2">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new empty <a class="el" href="class_x_m_l_node.html">XMLNode</a> with no children. </p>

</div>
</div>
<a id="a21843419c9e9725e3e3089e5ddfa7e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21843419c9e9725e3e3089e5ddfa7e2c">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_x_m_l_node.html">XMLNode</a> by copying an <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td><a class="el" href="class_x_m_l_token.html">XMLToken</a> to be copied to <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34ee7242a58c6ce81b20ef1388dae21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ee7242a58c6ce81b20ef1388dae21d">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new start element <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given set of attributes and namespace declarations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td><a class="el" href="class_x_m_l_triple.html">XMLTriple</a>. </td></tr>
    <tr><td class="paramname">attributes</td><td><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a>, the attributes to set. </td></tr>
    <tr><td class="paramname">namespaces</td><td><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a>, the namespaces to set. </td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number (default = 0). </td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number (default = 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d39b71036a280ba768bf4c0429faf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39b71036a280ba768bf4c0429faf82">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a start element <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given set of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td><a class="el" href="class_x_m_l_triple.html">XMLTriple</a>. </td></tr>
    <tr><td class="paramname">attributes</td><td><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a>, the attributes to set. </td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number (default = 0). </td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number (default = 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b2fbc1a3e6cbbf090b1e338be287bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2fbc1a3e6cbbf090b1e338be287bd9">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an end element <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td><a class="el" href="class_x_m_l_triple.html">XMLTriple</a>. </td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number (default = 0). </td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number (default = 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bc5570614d9ee24d8bbd62ec3ec56a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc5570614d9ee24d8bbd62ec3ec56a3">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a text <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>a string, the text to be added to the <a class="el" href="class_x_m_l_token.html">XMLToken</a>. </td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number (default = 0). </td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number (default = 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae652023d7f98430de2027471ef9d9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae652023d7f98430de2027471ef9d9065">&#9670;&nbsp;</a></span>~XMLNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::~XMLNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>

</div>
</div>
<a id="aac86771ab653407944a03a4cf215c602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac86771ab653407944a03a4cf215c602">&#9670;&nbsp;</a></span>XMLNode() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLNode::XMLNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor; creates a copy of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>the <a class="el" href="class_x_m_l_node.html">XMLNode</a> instance to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7567021b6e9f7d43c71ff9c625854266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7567021b6e9f7d43c71ff9c625854266">&#9670;&nbsp;</a></span>addAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::addAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>namespaceURI</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an attribute to the XML element represented by this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the so-called "local part" of the attribute name; that is, the attribute name without any namespace qualifier or prefix.</td></tr>
    <tr><td class="paramname">value</td><td>a string, the value assigned to the attribute.</td></tr>
    <tr><td class="paramname">namespaceURI</td><td>a string, the XML namespace URI of the attribute.</td></tr>
    <tr><td class="paramname">prefix</td><td>a string, the prefix for the XML namespace.</td></tr>
  </table>
  </dd>
</dl>
<p>Recall that in XML, the complete form of an attribute on an XML element is the following: </p><center> <code>prefix:name="value"</code> </center><p> The <code>name</code> part is the name of the attribute, the <code>"value"</code> part is the value assigned to the attribute (and it is always a quoted string), and the <code>prefix</code> part is an optional XML namespace prefix. Internally in libSBML, this data is stored in an <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object associated with this <a class="el" href="class_x_m_l_token.html">XMLToken</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the same name and XML namespace URI already exists on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, then the previous value will be replaced with the new value provided to this method. </dd></dl>

</div>
</div>
<a id="a4557b10140fcd61dab77f69c0b86b87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4557b10140fcd61dab77f69c0b86b87d">&#9670;&nbsp;</a></span>addAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::addAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an attribute to the XML element represented by this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object defining the attribute, its value, and optionally its XML namespace (if any is provided).</td></tr>
    <tr><td class="paramname">value</td><td>a string, the value assigned to the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the same name and XML namespace URI already exists on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, then the previous value will be replaced with the new value provided to this method. </dd></dl>

</div>
</div>
<a id="a1c25373a33be80bd0f28e54a80be2044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c25373a33be80bd0f28e54a80be2044">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode::addChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of <code>node</code> as a child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<p>The given <code>node</code> is added at the end of the list of children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_x_m_l_node.html">XMLNode</a> to be added as child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The given node is added at the end of the children list. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a24">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a51b55c6dfa29b482c45d7f61e2a2abae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b55c6dfa29b482c45d7f61e2a2abae">&#9670;&nbsp;</a></span>addNamespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::addNamespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an XML namespace declaration to this token. </p>
<p>The namespace added will be defined by the given XML namespace URI and an optional prefix. If this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object already possesses an XML namespace declaration with the given <code>prefix</code>, then the existing XML namespace URI will be overwritten by the new one given by <code>uri</code>.</p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI for the namespace.</td></tr>
    <tr><td class="paramname">prefix</td><td>a string, the namespace prefix to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a64e389f37be54e6abb0d11d89b40d91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e389f37be54e6abb0d11d89b40d91e">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends characters to the text content of token. </p>
<p>This method only makes sense for <a class="el" href="class_x_m_l_token.html">XMLToken</a> objects that contains text. If this method is called on a token that represents an XML start or end tag, it will return the code <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>string, characters to append to the text of this token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd></dl>

</div>
</div>
<a id="a02317b2903faab5e4b5fa6bacd6ba185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02317b2903faab5e4b5fa6bacd6ba185">&#9670;&nbsp;</a></span>clearAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::clearAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all attributes of this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2b9b94ff6797c5169056557ad137389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9b94ff6797c5169056557ad137389f">&#9670;&nbsp;</a></span>clearNamespaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::clearNamespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all XML namespace declarations from this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7bfe27cb9b8f715a33c5a688b0e8ee88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfe27cb9b8f715a33c5a688b0e8ee88">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * XMLNode::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a deep copy of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the (deep) copy of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> object. </dd></dl>

</div>
</div>
<a id="abe475aad26e52c716bb171ebfab85c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe475aad26e52c716bb171ebfab85c39">&#9670;&nbsp;</a></span>convertStringToXMLNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * XMLNode::convertStringToXMLNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>xmlns</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_x_m_l_node.html">XMLNode</a> which is derived from a string containing XML content. </p>
<p>The XML namespace must be defined using argument <code>xmlns</code> if the corresponding XML namespace attribute is not part of the string of the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmlstr</td><td>string to be converted to a XML node. </td></tr>
    <tr><td class="paramname">xmlns</td><td><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> the namespaces to set (default value is <code>NULL</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller owns the returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> and is reponsible for deleting it. The returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> object is a dummy root (container) <a class="el" href="class_x_m_l_node.html">XMLNode</a> if the top-level element in the given XML string is NOT <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;annotation&gt;</code>, or <code>&lt;notes&gt;</code>. In the dummy root node, each top-level element in the given XML string is contained as a child <a class="el" href="class_x_m_l_node.html">XMLNode</a>. <a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230" title="Returns true if this token is an end of file marker.">XMLToken::isEOF()</a> can be used to identify if the returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> object is a dummy node.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_x_m_l_node.html">XMLNode</a> which is converted from string <code>xmlstr</code>. If the conversion failed, this method returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="a3b018589d7d8e2fdeff43b9c0045ea55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b018589d7d8e2fdeff43b9c0045ea55">&#9670;&nbsp;</a></span>convertXMLNodeToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLNode::convertXMLNodeToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of a given <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_x_m_l_node.html">XMLNode</a> to be represented as a string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string-form representation of <code>node</code>. </dd></dl>

</div>
</div>
<a id="a56c2a16b990471ca2c5da6f3bff5b9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c2a16b990471ca2c5da6f3bff5b9fa">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLNode::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreURI</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreAttributeValues</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare this <a class="el" href="class_x_m_l_node.html">XMLNode</a> against another <a class="el" href="class_x_m_l_node.html">XMLNode</a> returning true if both nodes represent the same XML tree, or false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another <a class="el" href="class_x_m_l_node.html">XMLNode</a> to compare against.</td></tr>
    <tr><td class="paramname">ignoreURI</td><td>whether to ignore the namespace URI when doing the comparison.</td></tr>
    <tr><td class="paramname">ignoreAttributeValues</td><td>whetehr to ignore attribute values when doing the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean indicating whether this <a class="el" href="class_x_m_l_node.html">XMLNode</a> represents the same XML tree as another.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another <a class="el" href="class_x_m_l_node.html">XMLNode</a> to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean indicating whether this <a class="el" href="class_x_m_l_node.html">XMLNode</a> represents the same XML tree as another. </dd></dl>

</div>
</div>
<a id="a25eb82b0e44aa0bad9af110041b319cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25eb82b0e44aa0bad9af110041b319cf">&#9670;&nbsp;</a></span>getAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp; XMLToken::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the attributes of the XML element represented by this token. </p>
<dl class="section return"><dt>Returns</dt><dd>the attributes of this XML element, stored in an <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a id="a604907127dd25094f73f4723060cd6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604907127dd25094f73f4723060cd6fe">&#9670;&nbsp;</a></span>getAttributesLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::getAttributesLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of attributes on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of attributes possessed by this token.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">hasAttr()</a> </dd></dl>

</div>
</div>
<a id="aee7431330304746a92b730e9ccebbf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7431330304746a92b730e9ccebbf3f">&#9670;&nbsp;</a></span>getAttrIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::getAttrIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the attribute with the given name and namespace URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the namespace URI of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute with the given local name and namespace URI, or <code>-1</code> if it is not present on this token. </dd></dl>

</div>
</div>
<a id="ac10343edba950a6f22e5db2eb423996b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10343edba950a6f22e5db2eb423996b">&#9670;&nbsp;</a></span>getAttrIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::getAttrIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the attribute defined by the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>the <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object that defines the attribute whose index is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute with the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object, or <code>-1</code> if no such attribute is present on this token. </dd></dl>

</div>
</div>
<a id="abb770a8721bb24f8c1a1e00046ab9304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb770a8721bb24f8c1a1e00046ab9304">&#9670;&nbsp;</a></span>getAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the <em>n</em>th attribute in this token's list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose name is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the attribute located at position <code>n</code> in the list of attributes possessed by this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test for an attribute's existence explicitly, and <a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">XMLToken::getAttributesLength()</a> can be used to find out the number of attributes possessed by this token.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">hasAttr()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">getAttributesLength()</a> </dd></dl>

</div>
</div>
<a id="ae4e28928fbea3163a2b537b20a05bb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e28928fbea3163a2b537b20a05bb58">&#9670;&nbsp;</a></span>getAttrPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrPrefix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the prefix of the <em>n</em>th attribute in this token's list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose prefix is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace prefix of the attribute located at position <code>n</code> in the list of attributes possessed by this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test for an attribute's existence explicitly, and <a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">XMLToken::getAttributesLength()</a> can be used to find out the number of attributes possessed by this token.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">hasAttr()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">getAttributesLength()</a> </dd></dl>

</div>
</div>
<a id="a87ae14a78885898cac9080c1955274da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ae14a78885898cac9080c1955274da">&#9670;&nbsp;</a></span>getAttrPrefixedName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrPrefixedName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the prefixed name of the <em>n</em>th attribute in this token's list of attributes. </p>
<p>In this context, <em>prefixed name</em> means the name of the attribute prefixed with the XML namespace prefix assigned to the attribute. This will be a string of the form <code>prefix:name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose prefixed name is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the prefixed name of the attribute located at position <code>n</code> in the list of attributes possessed by this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test for an attribute's existence explicitly, and <a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">XMLToken::getAttributesLength()</a> can be used to find out the number of attributes possessed by this token. </dd></dl>

</div>
</div>
<a id="a3ce0b4af23c52c79d6868952c3c8476e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce0b4af23c52c79d6868952c3c8476e">&#9670;&nbsp;</a></span>getAttrURI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrURI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML namespace URI of the <em>n</em>th attribute in this token's list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose namespace URI is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace URI of the attribute located at position <code>n</code> in the list of attributes possessed by this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test for an attribute's existence explicitly, and <a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">XMLToken::getAttributesLength()</a> can be used to find out the number of attributes possessed by this token. </dd></dl>

</div>
</div>
<a id="abadcb807680c7a330c7ea9b313d3d6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadcb807680c7a330c7ea9b313d3d6ef">&#9670;&nbsp;</a></span>getAttrValue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the attribute with a given name and XML namespace URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute whose value is being sought.</td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the attribute, as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the given <code>name</code> and <code>uri</code> does not exist on this token object, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test explicitly for the presence of an attribute with a given name and namespace. </dd></dl>

</div>
</div>
<a id="ac1e8af3d2160c327cc8ed955c567499c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e8af3d2160c327cc8ed955c567499c">&#9670;&nbsp;</a></span>getAttrValue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the attribute specified by a given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> describing the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the attribute, as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute defined by the given <code>triple</code> does not exist on this token object, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test explicitly for the existence of an attribute with the properties of a given triple. </dd></dl>

</div>
</div>
<a id="aa104c724eb5b1d696a7b9776d6cc36bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa104c724eb5b1d696a7b9776d6cc36bc">&#9670;&nbsp;</a></span>getAttrValue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getAttrValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the <em>n</em>th attribute in this token's list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose value is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the attribute located at position <code>n</code> in the list of attributes possessed by this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a5903003d559f9d0290fd60e41366c2e5" title="Returns true if an attribute with the given index exists.">XMLToken::hasAttr()</a> can be used to test for an attribute's existence explicitly, and <a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">XMLToken::getAttributesLength()</a> can be used to find out the number of attributes possessed by this token. </dd></dl>

</div>
</div>
<a id="abea8ba88316d9eba5eee22ab5d89c196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea8ba88316d9eba5eee22ab5d89c196">&#9670;&nbsp;</a></span>getCharacters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; XMLToken::getCharacters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the character text of token. </p>
<dl class="section return"><dt>Returns</dt><dd>the characters of this XML token. If this token is not a text token (i.e., it's an XML element and not character content), then this will return an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd></dl>

</div>
</div>
<a id="a13604a6e392a8526bd70eda48f6e7200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13604a6e392a8526bd70eda48f6e7200">&#9670;&nbsp;</a></span>getChild() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp; XMLNode::getChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the corresponding name. </p>
<p>If no child with corrsponding name can be found, this method returns an empty node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the node to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with given name.</dd></dl>
<p>If no child with corrsponding name can be found, this method returns an empty node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the node to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with given name. </dd></dl>

</div>
</div>
<a id="a2240d7a21e9990355d1502d10fa9f024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2240d7a21e9990355d1502d10fa9f024">&#9670;&nbsp;</a></span>getChild() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp; XMLNode::getChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the corresponding name. </p>
<p>If no child with corrsponding name can be found, this method returns an empty node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the node to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with given name.</dd></dl>
<p>If no child with corrsponding name can be found, this method returns an empty node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the node to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with given name. </dd></dl>

</div>
</div>
<a id="a02d5d8c64c480eacf80941ad851deacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d5d8c64c480eacf80941ad851deacd">&#9670;&nbsp;</a></span>getChild() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp; XMLNode::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<p>If the index <code>n</code> is greater than the number of child nodes, this method returns an empty node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an unsigned integer, the index of the node to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </dd></dl>

</div>
</div>
<a id="abe90fba581502c48f5931742bb51b4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe90fba581502c48f5931742bb51b4a7">&#9670;&nbsp;</a></span>getChild() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp; XMLNode::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<p>If the index <code>n</code> is greater than the number of child nodes, this method returns an empty node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an unsigned integer, the index of the node to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </dd></dl>

</div>
</div>
<a id="a891be63a2aa15685febbb658e70c4328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891be63a2aa15685febbb658e70c4328">&#9670;&nbsp;</a></span>getColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XMLToken::getColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column number at which this token occurs in the input. </p>
<dl class="section return"><dt>Returns</dt><dd>the column at which this <a class="el" href="class_x_m_l_token.html">XMLToken</a> occurred. </dd></dl>

</div>
</div>
<a id="a55928de887e58bb62fc3f558739b2daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55928de887e58bb62fc3f558739b2daa">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode::getIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the child for which the index is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> with the given name, or <code>-1</code> if not present. </dd></dl>

</div>
</div>
<a id="a07687edeb6cd5d5e1b57c93afb772300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07687edeb6cd5d5e1b57c93afb772300">&#9670;&nbsp;</a></span>getLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XMLToken::getLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line number at which this token occurs in the input. </p>
<dl class="section return"><dt>Returns</dt><dd>the line at which this <a class="el" href="class_x_m_l_token.html">XMLToken</a> occurred. </dd></dl>

</div>
</div>
<a id="ab3a3f9fb7e0c88444ed43633bb18ec2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a3f9fb7e0c88444ed43633bb18ec2f">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; XMLToken::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (unqualified) name of token. </p>
<dl class="section return"><dt>Returns</dt><dd>the (unqualified) name of token. </dd></dl>

</div>
</div>
<a id="a30e2dcbc76a8b620deb29f3b3b31a193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e2dcbc76a8b620deb29f3b3b31a193">&#9670;&nbsp;</a></span>getNamespaceIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::getNamespaceIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of an XML namespace declaration based on its URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the sought-after namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given declaration, or <code>-1</code> if no such namespace URI is present on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </dd></dl>

</div>
</div>
<a id="a1d5d62bdfabe74e06a989dff5c48d587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5d62bdfabe74e06a989dff5c48d587">&#9670;&nbsp;</a></span>getNamespaceIndexByPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::getNamespaceIndexByPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of an XML namespace declaration based on its prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>a string, the prefix of the sought-after XML namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given declaration, or <code>-1</code> if no such namespace URI is present on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </dd></dl>

</div>
</div>
<a id="a920b2de814716d4828a809c2d1db7be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920b2de814716d4828a809c2d1db7be9">&#9670;&nbsp;</a></span>getNamespacePrefix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getNamespacePrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the prefix associated with a given XML namespace URI on this token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>a string, the URI of the namespace whose prefix is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the prefix of an XML namespace declaration on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there is no XML namespace with the given <code>uri</code> declared on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, this method will return an empty string. </dd></dl>

</div>
</div>
<a id="ab553ac8a68a9856404b064ffa823d2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab553ac8a68a9856404b064ffa823d2c0">&#9670;&nbsp;</a></span>getNamespacePrefix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getNamespacePrefix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the prefix of the <em>n</em>th XML namespace declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, position of the required prefix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the prefix of an XML namespace declaration in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> (by position).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. <a class="el" href="class_x_m_l_token.html#a6af59569ca097bc9695f7deb0131e2dd" title="Returns the number of XML namespaces declared on this token.">XMLToken::getNamespacesLength()</a> can be used to find out how many namespaces are defined on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a6af59569ca097bc9695f7deb0131e2dd" title="Returns the number of XML namespaces declared on this token.">getNamespacesLength()</a> </dd></dl>

</div>
</div>
<a id="acf4ac2b2be53e5ef56632c9ec3bf0c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4ac2b2be53e5ef56632c9ec3bf0c25">&#9670;&nbsp;</a></span>getNamespaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> &amp; XMLToken::getNamespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML namespaces declared for this token. </p>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace declarations for this XML element. </dd></dl>

</div>
</div>
<a id="a6af59569ca097bc9695f7deb0131e2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af59569ca097bc9695f7deb0131e2dd">&#9670;&nbsp;</a></span>getNamespacesLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::getNamespacesLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of XML namespaces declared on this token. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of XML namespaces stored in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object of this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </dd></dl>

</div>
</div>
<a id="ac61535e4ef04bce910183b3565afe262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61535e4ef04bce910183b3565afe262">&#9670;&nbsp;</a></span>getNamespaceURI() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getNamespaceURI </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the URI of an XML namespace with a given prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>a string, the prefix of the sought-after XML namespace URI.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the URI of an XML namespace declaration given its prefix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there is no XML namespace with the given <code>prefix</code> stored in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object of this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, this method will return an empty string. </dd></dl>

</div>
</div>
<a id="adb1c8a9e4b3cd5522290b87b193722a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c8a9e4b3cd5522290b87b193722a1">&#9670;&nbsp;</a></span>getNamespaceURI() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToken::getNamespaceURI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the URI of the <em>n</em>th XML namespace declared on this token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the sought-after XML namespace URI.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the URI of the <em>n</em>th XML namespace stored in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object in this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a6af59569ca097bc9695f7deb0131e2dd" title="Returns the number of XML namespaces declared on this token.">getNamespacesLength()</a> </dd></dl>

</div>
</div>
<a id="a44be07ab2c8661102741f79d6fcc7b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44be07ab2c8661102741f79d6fcc7b93">&#9670;&nbsp;</a></span>getNumChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XMLNode::getNumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of children for this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of children for this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </dd></dl>

</div>
</div>
<a id="aed5b4fbfad7ebd29e94feb092771ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5b4fbfad7ebd29e94feb092771ccf9">&#9670;&nbsp;</a></span>getPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; XMLToken::getPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML namespace prefix of token. </p>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace prefix of token.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If no XML namespace prefix has been assigned to this token, this method will return an empty string. </dd></dl>

</div>
</div>
<a id="a2b2c321b3c628fefb5c87c31e4d8dd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2c321b3c628fefb5c87c31e4d8dd9b">&#9670;&nbsp;</a></span>getURI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; XMLToken::getURI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML namespace URI of token. </p>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace URI of token. </dd></dl>

</div>
</div>
<a id="a928dd71b5da0f4e630b1f18c6d68b890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928dd71b5da0f4e630b1f18c6d68b890">&#9670;&nbsp;</a></span>hasAttr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::hasAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute with a given name and namespace URI exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute being sought.</td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given local name and namespace URI exists in the list of attributes on this token object, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0b2d75e7a15853c83d61aaec4900e116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2d75e7a15853c83d61aaec4900e116">&#9670;&nbsp;</a></span>hasAttr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::hasAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute defined by a given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute matching the properties of the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object exists in the list of attributes on this token, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5903003d559f9d0290fd60e41366c2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5903003d559f9d0290fd60e41366c2e5">&#9670;&nbsp;</a></span>hasAttr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::hasAttr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute with the given index exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this token object possesses an attribute with the given index, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5e5a6a3b186debd410f18574a563de10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5a6a3b186debd410f18574a563de10">&#9670;&nbsp;</a></span>hasChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLNode::hasChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean indicating whether this <a class="el" href="class_x_m_l_node.html">XMLNode</a> has a child with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the child to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean indicating whether this <a class="el" href="class_x_m_l_node.html">XMLNode</a> has a child with the given name. </dd></dl>

</div>
</div>
<a id="a0c0f09a70ce764293a973c97a7e8de4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0f09a70ce764293a973c97a7e8de4a">&#9670;&nbsp;</a></span>hasNamespaceNS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::hasNamespaceNS </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token has an XML namespace with a given prefix and URI combination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>a string, the URI for the namespace. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string, the prefix for the namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an XML namespace with the given URI/prefix pair is contained in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object of this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a88741070d315153c08db66d5fcd4069f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88741070d315153c08db66d5fcd4069f">&#9670;&nbsp;</a></span>hasNamespacePrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::hasNamespacePrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token has an XML namespace with a given prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>a string, the prefix for the XML namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an XML Namespace with the given URI is contained in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> of this <a class="el" href="class_x_m_l_token.html">XMLToken</a>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a19ff7469fc6d34a1f797da9901f2f1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ff7469fc6d34a1f797da9901f2f1dd">&#9670;&nbsp;</a></span>hasNamespaceURI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::hasNamespaceURI </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token has an XML namespace with a given URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>a string, the URI of the XML namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an XML namespace with the given URI is contained in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object of this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab22439cd49bfddd49f36474e2bc23c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22439cd49bfddd49f36474e2bc23c95">&#9670;&nbsp;</a></span>insertChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp; XMLNode::insertChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of the given node as the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<p>If the given index <code>n</code> is out of range for this <a class="el" href="class_x_m_l_node.html">XMLNode</a> instance, the <code>node</code> is added at the end of the list of children. Even in that situation, this method does not throw an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer, the index at which the given node is inserted. </td></tr>
    <tr><td class="paramname">node</td><td>an <a class="el" href="class_x_m_l_node.html">XMLNode</a> to be inserted as <code>n</code>th child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly-inserted child <code>node</code>. </dd></dl>

</div>
</div>
<a id="a2c094a5459116dc8ca1f93bdaf1b0949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c094a5459116dc8ca1f93bdaf1b0949">&#9670;&nbsp;</a></span>isAttributesEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isAttributesEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token has no attributes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the list of attributes on <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is empty, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa8833beadc3f06ae3e4b6cdfcac322ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8833beadc3f06ae3e4b6cdfcac322ef">&#9670;&nbsp;</a></span>isElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token represents an XML element. </p>
<p>This generic predicate returns <code>true</code> if the element is either a start or end tag, and <code>false</code> if it's a text object. The related methods <a class="el" href="class_x_m_l_token.html">XMLToken</a>:<a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9" title="Returns true if this token represents an XML start element.">isStart()</a>, <a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21" title="Returns true if this token represents an XML end element.">XMLToken::isEnd()</a> and <a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">XMLToken::isText()</a> are more specific predicates.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object represents an XML element, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9" title="Returns true if this token represents an XML start element.">isStart()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21" title="Returns true if this token represents an XML end element.">isEnd()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd></dl>

</div>
</div>
<a id="ad0a44a5db108d63aadf29b326bda3d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a44a5db108d63aadf29b326bda3d21">&#9670;&nbsp;</a></span>isEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token represents an XML end element. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object represents an XML end element, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9" title="Returns true if this token represents an XML start element.">isStart()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd></dl>

</div>
</div>
<a id="a3ee7d11da59a3ff1ca2af7d3c46ae27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee7d11da59a3ff1ca2af7d3c46ae27d">&#9670;&nbsp;</a></span>isEndFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isEndFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token represents an XML end element for a particular start element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td><a class="el" href="class_x_m_l_token.html">XMLToken</a>, the element with which the current object should be compared to determined whether the current object is a start element for the given one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object represents an XML end tag for the start tag given by <code>element</code>, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9" title="Returns true if this token represents an XML start element.">isStart()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21" title="Returns true if this token represents an XML end element.">isEnd()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd></dl>

</div>
</div>
<a id="ae963b35615525f8af949373c5765a230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae963b35615525f8af949373c5765a230">&#9670;&nbsp;</a></span>isEOF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token is an end of file marker. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object represents the end of the input, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a6ce5f5ffe6df85ab02124abf91c6b61a" title="Declares that this token is an end-of-file/input marker.">setEOF()</a> </dd></dl>

</div>
</div>
<a id="a57d7db81e24d4f90081be80652c089e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d7db81e24d4f90081be80652c089e7">&#9670;&nbsp;</a></span>isNamespacesEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isNamespacesEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if there are no namespaces declared on this token. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object stored in this <a class="el" href="class_x_m_l_token.html">XMLToken</a> token is empty, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ade7cb99aac8335048f2654af9582f6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7cb99aac8335048f2654af9582f6c9">&#9670;&nbsp;</a></span>isStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token represents an XML start element. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> is an XML start element, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21" title="Returns true if this token represents an XML end element.">isEnd()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd></dl>

</div>
</div>
<a id="a9e5f9506affaefd91d24150d15a21281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5f9506affaefd91d24150d15a21281">&#9670;&nbsp;</a></span>isText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLToken::isText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this token represents an XML text element. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> is an XML text element, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9" title="Returns true if this token represents an XML start element.">isStart()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21" title="Returns true if this token represents an XML end element.">isEnd()</a> </dd></dl>

</div>
</div>
<a id="a13a099f21de99b8a4cbb7f78a211efb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a099f21de99b8a4cbb7f78a211efb6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp; XMLNode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the <a class="el" href="class_x_m_l_node.html">XMLNode</a> object whose values are used as the basis of the assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65c5ed08d70c430e20a5d53e9478ac90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c5ed08d70c430e20a5d53e9478ac90">&#9670;&nbsp;</a></span>readXMLNodeFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * XMLNode::readXMLNodeFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="class_x_m_l_node.html">XMLNode</a> which is readfrom a file containing XML content. </p>
<p>The XML namespace must be defined using argument <code>xmlns</code> if the corresponding XML namespace attribute is not part of the file of the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string name of file to be read to a XML node. </td></tr>
    <tr><td class="paramname">xmlns</td><td><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> the namespaces to set (default value is <code>NULL</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller owns the returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> and is reponsible for deleting it. The returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> object is a dummy root (container) <a class="el" href="class_x_m_l_node.html">XMLNode</a> if the top-level element in the given XML string is NOT <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;annotation&gt;</code>, or <code>&lt;notes&gt;</code>. In the dummy root node, each top-level element in the given XML string is contained as a child <a class="el" href="class_x_m_l_node.html">XMLNode</a>. <a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230" title="Returns true if this token is an end of file marker.">XMLToken::isEOF()</a> can be used to identify if the returned <a class="el" href="class_x_m_l_node.html">XMLNode</a> object is a dummy node.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_x_m_l_node.html">XMLNode</a> which is read from file <code>filename</code>. If the conversion failed, this method returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="a069eb01ce499152e7da6d890db4232de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069eb01ce499152e7da6d890db4232de">&#9670;&nbsp;</a></span>removeAttr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::removeAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an attribute from the XML element represented by this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute to be removed. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute on this element with the given <code>name</code> (and <code>uri</code> if specified).</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttr(const std::string name, const std::string uri) const </dd></dl>

</div>
</div>
<a id="acd9684376f7f4e2df66dd2b00496464b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9684376f7f4e2df66dd2b00496464b">&#9670;&nbsp;</a></span>removeAttr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::removeAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an attribute from the XML element represented by this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> describing the attribute to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute on this element matching the properties of the given <code>triple</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a0b2d75e7a15853c83d61aaec4900e116" title="Returns true if an attribute defined by a given XMLTriple object exists.">hasAttr(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="a4ed4e8119bc50559a88b95c2e7932090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed4e8119bc50559a88b95c2e7932090">&#9670;&nbsp;</a></span>removeAttr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::removeAttr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the <em>n</em>th attribute from the XML element represented by this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer the index of the resource to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute on this element at the given index <code>n</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#ac10343edba950a6f22e5db2eb423996b" title="Returns the index of the attribute defined by the given XMLTriple object.">getAttrIndex(const XMLTriple&amp; triple) const</a> </dd>
<dd>
getAttrIndex(const std::string&amp; name, const std::string&amp; uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a604907127dd25094f73f4723060cd6fe" title="Returns the number of attributes on this XMLToken object.">getAttributesLength()</a> </dd></dl>

</div>
</div>
<a id="a2d7a5bb2c6a951f76212675caa399377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7a5bb2c6a951f76212675caa399377">&#9670;&nbsp;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * XMLNode::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <code>n</code>th child of this <a class="el" href="class_x_m_l_node.html">XMLNode</a> and returns the removed node. </p>
<p>It is important to keep in mind that a given <a class="el" href="class_x_m_l_node.html">XMLNode</a> may have more than one child. Calling this method erases all existing references to child nodes <em>after</em> the given position <code>n</code>. If the index <code>n</code> is greater than the number of child nodes in this <a class="el" href="class_x_m_l_node.html">XMLNode</a>, this method takes no action (and returns <code>NULL</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer, the index of the node to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed child, or <code>NULL</code> if <code>n</code> is greater than the number of children in this node.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller owns the returned node and is responsible for deleting it. </dd></dl>

</div>
</div>
<a id="a1911ddafee6f3bce0fcf5885f3b9cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1911ddafee6f3bce0fcf5885f3b9cd16">&#9670;&nbsp;</a></span>removeChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode::removeChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all children from this node. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af8477f21eedb02196088d22c2f5bfde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8477f21eedb02196088d22c2f5bfde3">&#9670;&nbsp;</a></span>removeNamespace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::removeNamespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an XML namespace declaration having a given prefix. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>a string, the prefix of the namespace to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no namespace with the given <code>prefix</code> on this element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a1d5d62bdfabe74e06a989dff5c48d587" title="Returns the index of an XML namespace declaration based on its prefix.">getNamespaceIndexByPrefix()</a> </dd></dl>

</div>
</div>
<a id="a493ef1d8677dd4b95e9ac55b61ba69be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493ef1d8677dd4b95e9ac55b61ba69be">&#9670;&nbsp;</a></span>removeNamespace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::removeNamespace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the <em>n</em>th XML namespace declaration. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the namespace to be removed. The position in this context refers to the position of the namespace in the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object stored in this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. Callers can use one of the <code>getNamespace___()</code> methods to find the index number of a given namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a30e2dcbc76a8b620deb29f3b3b31a193" title="Returns the index of an XML namespace declaration based on its URI.">getNamespaceIndex()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a1d5d62bdfabe74e06a989dff5c48d587" title="Returns the index of an XML namespace declaration based on its prefix.">getNamespaceIndexByPrefix()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#a6af59569ca097bc9695f7deb0131e2dd" title="Returns the number of XML namespaces declared on this token.">getNamespacesLength()</a> </dd></dl>

</div>
</div>
<a id="a5f7f047728380a22c17ec735287da6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7f047728380a22c17ec735287da6de">&#9670;&nbsp;</a></span>setAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::setAttributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the attributes on the XML element represented by this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>an <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object to be assigned to this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object, thereby setting the XML attributes associated with this token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function replaces any existing <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object with the one given by <code>attributes</code>. </dd></dl>

</div>
</div>
<a id="a8d1a6af2872acb75f6f32dd91018c48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1a6af2872acb75f6f32dd91018c48d">&#9670;&nbsp;</a></span>setCharacters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::setCharacters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the characters for this <a class="el" href="class_x_m_l_token.html">XMLToken</a>. </p>
<p>This method only makes sense for <a class="el" href="class_x_m_l_token.html">XMLToken</a> objects that contains text. If this method is called on a token that represents an XML start or end tag, it will return the code <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>string, characters to append to the text of this token.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#a9e5f9506affaefd91d24150d15a21281" title="Returns true if this token represents an XML text element.">isText()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#aa8833beadc3f06ae3e4b6cdfcac322ef" title="Returns true if this token represents an XML element.">isElement()</a> </dd></dl>

</div>
</div>
<a id="a85783786e0219ac1d822e37df460b587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85783786e0219ac1d822e37df460b587">&#9670;&nbsp;</a></span>setEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::setEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this token represents an XML element end tag. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#ade7cb99aac8335048f2654af9582f6c9" title="Returns true if this token represents an XML start element.">isStart()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html#ad0a44a5db108d63aadf29b326bda3d21" title="Returns true if this token represents an XML end element.">isEnd()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a23">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6ce5f5ffe6df85ab02124abf91c6b61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce5f5ffe6df85ab02124abf91c6b61a">&#9670;&nbsp;</a></span>setEOF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::setEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this token is an end-of-file/input marker. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230" title="Returns true if this token is an end of file marker.">isEOF()</a> </dd></dl>

</div>
</div>
<a id="a03ad2e51f7948cdafb6773ca068e5eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ad2e51f7948cdafb6773ca068e5eb5">&#9670;&nbsp;</a></span>setNamespaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::setNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the XML namespaces on this XML element. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaces</td><td>the <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object to be assigned to this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function replaces any existing <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> object on this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object with the new one given by <code>namespaces</code>. </dd></dl>

</div>
</div>
<a id="a774e1b33f0a4304905e256958e67ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774e1b33f0a4304905e256958e67ad9a">&#9670;&nbsp;</a></span>setTriple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::setTriple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name, namespace prefix and namespace URI of this token. </p>
<dl class="section user"><dt></dt><dd>This operation only makes sense for XML start elements. This method will return <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> if this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object is not an XML start element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>the new <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> to use for this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. If this <a class="el" href="class_x_m_l_token.html">XMLToken</a> already had an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object stored within it, that object will be replaced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6f4d0e33e449c4a876971e3a382ff3e7">LIBSBML_INVALID_XML_OPERATION</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9f80ab90e7f1509b2828686c1d96490a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f80ab90e7f1509b2828686c1d96490a">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string XMLToken::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a string representation of the underlying token stream. </p>
<p>This method is intended for debugging purposes.</p>
<dl class="section return"><dt>Returns</dt><dd>a text string representing this <a class="el" href="class_x_m_l_token.html">XMLToken</a> object. </dd></dl>

</div>
</div>
<a id="a9431852ad49f526a4bf3c9afdc95fe62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9431852ad49f526a4bf3c9afdc95fe62">&#9670;&nbsp;</a></span>toXMLString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLNode::toXMLString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a string derived from this <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </dd></dl>

</div>
</div>
<a id="ac7b55ffbe6762bf67cae0af092f4bd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b55ffbe6762bf67cae0af092f4bd59">&#9670;&nbsp;</a></span>unsetEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XMLToken::unsetEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that this token no longer represents an XML start/end element. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
