<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>libSBML C++ API: XMLInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.20.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_x_m_l_input_stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_x_m_l_input_stream-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">XMLInputStream Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> An interface to an XML input stream.</p>
<p style='color: #777; font-style: italic'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</p>
<p>SBML content is serialized using XML; the resulting data can be stored and read to/from a file or data stream. Low-level XML parsers such as Xerces provide facilities to read XML data. To permit the use of different XML parsers (Xerces, Expat or libxml2), libSBML implements an abstraction layer. <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a> and <a class="el" href="class_x_m_l_output_stream.html">XMLOutputStream</a> are two parts of that abstraction layer.</p>
<p><a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a> is an interface to a file or text string containing XML. It wraps the content to be read, as well as the low-level XML parser to be used and an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> to record errors and other issues (if any arise). Internally, the content will be in the form of either a pointer to a file name or a character string; <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a> knows the form of the content and acts appropriately. Other libSBML object classes use <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a> as their interface for all read operations on the XML data. <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a> provides the functionality to extract data in the form of <a class="el" href="class_x_m_l_token.html">XMLToken</a> objects. It logs any errors encountered while reading. It also keeps track of whether a read operation has failed irrecoverably or determines whether it is safe to continue reading.</p>
<p><a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> objects can be associated with an <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>; this facilitates logging errors related to reading XML attributes and elements that may only be relevant to particular Level and Version combinations of SBML.</p>
<dl class="section note"><dt>Note</dt><dd>The convenience of the <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a> and <a class="el" href="class_x_m_l_output_stream.html">XMLOutputStream</a> abstraction may be useful for developers interested in creating parsers for other XML formats besides SBML. It can provide developers with a layer above more basic XML parsers, as well as some useful programmatic elements such as <a class="el" href="class_x_m_l_token.html">XMLToken</a>, <a class="el" href="class_x_m_l_error.html">XMLError</a>, etc.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_output_stream.html">XMLOutputStream</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c292e0c680931f77529af34c63e55f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a7c292e0c680931f77529af34c63e55f0">containsChild</a> (const std::string &amp;childName, const std::string &amp;container)</td></tr>
<tr class="memdesc:a7c292e0c680931f77529af34c63e55f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if a child token of the specified type occurs within a given container element.  <a href="class_x_m_l_input_stream.html#a7c292e0c680931f77529af34c63e55f0">More...</a><br /></td></tr>
<tr class="separator:a7c292e0c680931f77529af34c63e55f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe529e82113dba4fae8324e665024b5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a2fe529e82113dba4fae8324e665024b5">determineNumberChildren</a> (const std::string elementName=&quot;&quot;)</td></tr>
<tr class="memdesc:a2fe529e82113dba4fae8324e665024b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of child tokens of the given element in this stream.  <a href="class_x_m_l_input_stream.html#a2fe529e82113dba4fae8324e665024b5">More...</a><br /></td></tr>
<tr class="separator:a2fe529e82113dba4fae8324e665024b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d3674aa4052621c511a3dd0ce64c7f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a00d3674aa4052621c511a3dd0ce64c7f">determineNumSpecificChildren</a> (const std::string &amp;childName, const std::string &amp;container)</td></tr>
<tr class="memdesc:a00d3674aa4052621c511a3dd0ce64c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of child tokens of the specified type within a given container element.  <a href="class_x_m_l_input_stream.html#a00d3674aa4052621c511a3dd0ce64c7f">More...</a><br /></td></tr>
<tr class="separator:a00d3674aa4052621c511a3dd0ce64c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037591c42cfb96f10672d806348e67b5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a037591c42cfb96f10672d806348e67b5">getEncoding</a> ()</td></tr>
<tr class="memdesc:a037591c42cfb96f10672d806348e67b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encoding of the XML stream.  <a href="class_x_m_l_input_stream.html#a037591c42cfb96f10672d806348e67b5">More...</a><br /></td></tr>
<tr class="separator:a037591c42cfb96f10672d806348e67b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab464c22d57f2faa9f21a430a11192c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a2ab464c22d57f2faa9f21a430a11192c">getErrorLog</a> ()</td></tr>
<tr class="memdesc:a2ab464c22d57f2faa9f21a430a11192c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> used to log parsing problems.  <a href="class_x_m_l_input_stream.html#a2ab464c22d57f2faa9f21a430a11192c">More...</a><br /></td></tr>
<tr class="separator:a2ab464c22d57f2faa9f21a430a11192c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb85d80ba4e8b3071b66ca8636b3c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a7cb85d80ba4e8b3071b66ca8636b3c10">getSBMLNamespaces</a> ()</td></tr>
<tr class="memdesc:a7cb85d80ba4e8b3071b66ca8636b3c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object attached to this <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>.  <a href="class_x_m_l_input_stream.html#a7cb85d80ba4e8b3071b66ca8636b3c10">More...</a><br /></td></tr>
<tr class="separator:a7cb85d80ba4e8b3071b66ca8636b3c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460456212b04b50701a2bf3aac147ae7"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a460456212b04b50701a2bf3aac147ae7">getVersion</a> ()</td></tr>
<tr class="memdesc:a460456212b04b50701a2bf3aac147ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version of the XML stream.  <a href="class_x_m_l_input_stream.html#a460456212b04b50701a2bf3aac147ae7">More...</a><br /></td></tr>
<tr class="separator:a460456212b04b50701a2bf3aac147ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4c47a91d304f164486429b4d5ee6f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#aed4c47a91d304f164486429b4d5ee6f2">isEOF</a> () const</td></tr>
<tr class="memdesc:aed4c47a91d304f164486429b4d5ee6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if end of file (stream) has been reached.  <a href="class_x_m_l_input_stream.html#aed4c47a91d304f164486429b4d5ee6f2">More...</a><br /></td></tr>
<tr class="separator:aed4c47a91d304f164486429b4d5ee6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148aded50007a665759c336b87cdd9e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a148aded50007a665759c336b87cdd9e9">isError</a> () const</td></tr>
<tr class="memdesc:a148aded50007a665759c336b87cdd9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if a fatal error occurred while reading from this stream.  <a href="class_x_m_l_input_stream.html#a148aded50007a665759c336b87cdd9e9">More...</a><br /></td></tr>
<tr class="separator:a148aded50007a665759c336b87cdd9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d5c9e68b6cfd0d09d1fa8891929244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a95d5c9e68b6cfd0d09d1fa8891929244">isGood</a> () const</td></tr>
<tr class="memdesc:a95d5c9e68b6cfd0d09d1fa8891929244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the stream is in a good state.  <a href="class_x_m_l_input_stream.html#a95d5c9e68b6cfd0d09d1fa8891929244">More...</a><br /></td></tr>
<tr class="separator:a95d5c9e68b6cfd0d09d1fa8891929244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404a03edbc912e086a319f30e4544d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_token.html">XMLToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a404a03edbc912e086a319f30e4544d85">next</a> ()</td></tr>
<tr class="memdesc:a404a03edbc912e086a319f30e4544d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next token on this XML input stream.  <a href="class_x_m_l_input_stream.html#a404a03edbc912e086a319f30e4544d85">More...</a><br /></td></tr>
<tr class="separator:a404a03edbc912e086a319f30e4544d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa332df276ac8c47a740dbb0c21749e0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#aa332df276ac8c47a740dbb0c21749e0a">peek</a> ()</td></tr>
<tr class="memdesc:aa332df276ac8c47a740dbb0c21749e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next token <em>without</em> consuming it.  <a href="class_x_m_l_input_stream.html#aa332df276ac8c47a740dbb0c21749e0a">More...</a><br /></td></tr>
<tr class="separator:aa332df276ac8c47a740dbb0c21749e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c24b9f851b3af5b33bacadd3263c38c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a4c24b9f851b3af5b33bacadd3263c38c">setErrorLog</a> (<a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log)</td></tr>
<tr class="memdesc:a4c24b9f851b3af5b33bacadd3263c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> this stream will use to log errors.  <a href="class_x_m_l_input_stream.html#a4c24b9f851b3af5b33bacadd3263c38c">More...</a><br /></td></tr>
<tr class="separator:a4c24b9f851b3af5b33bacadd3263c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75cf6a2f1137f646c57d15e6e32d668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#ac75cf6a2f1137f646c57d15e6e32d668">setSBMLNamespaces</a> (<a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *sbmlns)</td></tr>
<tr class="memdesc:ac75cf6a2f1137f646c57d15e6e32d668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the SBML namespaces associated with this XML input stream.  <a href="class_x_m_l_input_stream.html#ac75cf6a2f1137f646c57d15e6e32d668">More...</a><br /></td></tr>
<tr class="separator:ac75cf6a2f1137f646c57d15e6e32d668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7464b56118371b0dea78bc5276e0caae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a7464b56118371b0dea78bc5276e0caae">skipPastEnd</a> (const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;element)</td></tr>
<tr class="memdesc:a7464b56118371b0dea78bc5276e0caae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume zero or more tokens up to and including the corresponding end element or EOF.  <a href="class_x_m_l_input_stream.html#a7464b56118371b0dea78bc5276e0caae">More...</a><br /></td></tr>
<tr class="separator:a7464b56118371b0dea78bc5276e0caae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891802729e91d5b1fcf5057a16d5bf78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a891802729e91d5b1fcf5057a16d5bf78">skipText</a> ()</td></tr>
<tr class="memdesc:a891802729e91d5b1fcf5057a16d5bf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume zero or more tokens up to but not including the next XML element or EOF.  <a href="class_x_m_l_input_stream.html#a891802729e91d5b1fcf5057a16d5bf78">More...</a><br /></td></tr>
<tr class="separator:a891802729e91d5b1fcf5057a16d5bf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a3306cd13c8071c5173150aeeffaa9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#aa9a3306cd13c8071c5173150aeeffaa9">toString</a> ()</td></tr>
<tr class="memdesc:aa9a3306cd13c8071c5173150aeeffaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a string representation of the underlying token stream.  <a href="class_x_m_l_input_stream.html#aa9a3306cd13c8071c5173150aeeffaa9">More...</a><br /></td></tr>
<tr class="separator:aa9a3306cd13c8071c5173150aeeffaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8eec316ff4eb4555e5cbb8b005a117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a9a8eec316ff4eb4555e5cbb8b005a117">XMLInputStream</a> (const char *content, bool isFile=true, const std::string library=&quot;&quot;, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *errorLog=NULL)</td></tr>
<tr class="memdesc:a9a8eec316ff4eb4555e5cbb8b005a117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>.  <a href="class_x_m_l_input_stream.html#a9a8eec316ff4eb4555e5cbb8b005a117">More...</a><br /></td></tr>
<tr class="separator:a9a8eec316ff4eb4555e5cbb8b005a117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3418bdb4be800160eeb2c6217c1e31e3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_input_stream.html#a3418bdb4be800160eeb2c6217c1e31e3">~XMLInputStream</a> ()</td></tr>
<tr class="memdesc:a3418bdb4be800160eeb2c6217c1e31e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>.  <a href="class_x_m_l_input_stream.html#a3418bdb4be800160eeb2c6217c1e31e3">More...</a><br /></td></tr>
<tr class="separator:a3418bdb4be800160eeb2c6217c1e31e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a8eec316ff4eb4555e5cbb8b005a117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8eec316ff4eb4555e5cbb8b005a117">&#9670;&nbsp;</a></span>XMLInputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLInputStream::XMLInputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFile</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>library</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>errorLog</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>the source of the stream.</td></tr>
    <tr><td class="paramname">isFile</td><td>a boolean flag to indicate whether <code>content</code> is a file name. If <code>true</code>, <code>content</code> is assumed to be the file from which the XML content is to be read. If <code>false</code>, <code>content</code> is taken to be a string that <em>is</em> the content to be read.</td></tr>
    <tr><td class="paramname">library</td><td>the name of the parser library to use.</td></tr>
    <tr><td class="paramname">errorLog</td><td>the <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3418bdb4be800160eeb2c6217c1e31e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3418bdb4be800160eeb2c6217c1e31e3">&#9670;&nbsp;</a></span>~XMLInputStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual XMLInputStream::~XMLInputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c292e0c680931f77529af34c63e55f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c292e0c680931f77529af34c63e55f0">&#9670;&nbsp;</a></span>containsChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLInputStream::containsChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>childName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if a child token of the specified type occurs within a given container element. </p>
<p>This method allows information from the input stream to be determined without the need to actually read and consume the tokens in the stream. It returns <code>true</code> if the <code>childName</code> element occurs at any point within the element specified by <code>container</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childName</td><td>a string representing the name of the child element whose presence is to be determined.</td></tr>
    <tr><td class="paramname">container</td><td>a string representing the name of the element for which the presence of the child element is to be determined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean <code>true</code> if a child of type <code>childName</code> occurs within the <code>container</code> element, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method assumes the stream has been read up to and including the element <code>container</code>. </dd></dl>

</div>
</div>
<a id="a2fe529e82113dba4fae8324e665024b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe529e82113dba4fae8324e665024b5">&#9670;&nbsp;</a></span>determineNumberChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XMLInputStream::determineNumberChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>elementName</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of child tokens of the given element in this stream. </p>
<p>This method allows information from the input stream to be determined without the need to actually read and consume the tokens in the stream. It returns the number of child elements of the element represented by the <code>elementName</code>, i.e., the number of child elements encountered before the closing tag for the <code>elementName</code> supplied.</p>
<p>If no <code>elementName</code> is supplied or it is an empty string, then as a special case, this method assumes the element is a MathML <code>apply</code> element followed by a function name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>a string representing the name of the element for which the number of children are to be determined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unsigned int giving the number of children of the <code>elementName</code> specified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method assumes the stream has been read up to and including the element <code>elementName</code>. </dd></dl>

</div>
</div>
<a id="a00d3674aa4052621c511a3dd0ce64c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d3674aa4052621c511a3dd0ce64c7f">&#9670;&nbsp;</a></span>determineNumSpecificChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XMLInputStream::determineNumSpecificChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>childName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of child tokens of the specified type within a given container element. </p>
<p>This method allows information from the input stream to be determined without the need to actually read and consume the tokens in the stream. It returns the number of child elements of the <code>childName</code> element within the element specified by <code>container</code>. In other words, it counts the number of <code>childName</code> elements encountered before the closing tag for the <code>container</code> supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childName</td><td>a string representing the name of the child element whose number is to be determined.</td></tr>
    <tr><td class="paramname">container</td><td>a string representing the name of the element for which the number of children are to be determined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unsigned int giving the number of children of type <code>childName</code> within the <code>container</code> element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method assumes the stream has been read up to and including the element <code>container</code>. </dd></dl>

</div>
</div>
<a id="a037591c42cfb96f10672d806348e67b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037591c42cfb96f10672d806348e67b5">&#9670;&nbsp;</a></span>getEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; XMLInputStream::getEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the encoding of the XML stream. </p>
<dl class="section user"><dt>The <em>encoding</em> is indicated by the xml declaration at the</dt><dd>beginning of an XML document or data stream. The form of this declaration is <pre class="fragment">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</pre> Note that the SBML specifications require the use of UTF-8 encoding, so for SBML documents, the value returned by this method will always be the string <code>"UTF-8"</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding of the XML stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_input_stream.html#a460456212b04b50701a2bf3aac147ae7" title="Returns the version of the XML stream.">getVersion()</a> </dd></dl>

</div>
</div>
<a id="a2ab464c22d57f2faa9f21a430a11192c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab464c22d57f2faa9f21a430a11192c">&#9670;&nbsp;</a></span>getErrorLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a>* XMLInputStream::getErrorLog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> used to log parsing problems. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> used to log XML parse errors and other validation errors (and messages). </dd></dl>

</div>
</div>
<a id="a7cb85d80ba4e8b3071b66ca8636b3c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb85d80ba4e8b3071b66ca8636b3c10">&#9670;&nbsp;</a></span>getSBMLNamespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a>* XMLInputStream::getSBMLNamespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object attached to this <a class="el" href="class_x_m_l_input_stream.html">XMLInputStream</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object or <code>NULL</code> if none has been set. </dd></dl>

</div>
</div>
<a id="a460456212b04b50701a2bf3aac147ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460456212b04b50701a2bf3aac147ae7">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; XMLInputStream::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the version of the XML stream. </p>
<dl class="section user"><dt>The <em>version</em> is indicated by the xml declaration at the</dt><dd>beginning of an XML document or data stream. The form of this declaration is <pre class="fragment"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
</pre> Note that the SBML specifications require the use of version 1.0, so for SBML documents, the value returned by this method will always be the string <code>"1.0"</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the version of the XML stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_input_stream.html#a037591c42cfb96f10672d806348e67b5" title="Returns the encoding of the XML stream.">getEncoding()</a> </dd></dl>

</div>
</div>
<a id="aed4c47a91d304f164486429b4d5ee6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4c47a91d304f164486429b4d5ee6f2">&#9670;&nbsp;</a></span>isEOF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLInputStream::isEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if end of file (stream) has been reached. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if end of file (stream) has been reached, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a148aded50007a665759c336b87cdd9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148aded50007a665759c336b87cdd9e9">&#9670;&nbsp;</a></span>isError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLInputStream::isError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if a fatal error occurred while reading from this stream. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a fatal error occurred while reading from this stream. </dd></dl>

</div>
</div>
<a id="a95d5c9e68b6cfd0d09d1fa8891929244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d5c9e68b6cfd0d09d1fa8891929244">&#9670;&nbsp;</a></span>isGood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLInputStream::isGood </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the stream is in a good state. </p>
<p>The definition of "good state" is that <a class="el" href="class_x_m_l_input_stream.html#aed4c47a91d304f164486429b4d5ee6f2" title="Returns true if end of file (stream) has been reached.">isEOF()</a> and <a class="el" href="class_x_m_l_input_stream.html#a148aded50007a665759c336b87cdd9e9" title="Returns true if a fatal error occurred while reading from this stream.">isError()</a> both return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the stream is in a good state, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a404a03edbc912e086a319f30e4544d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404a03edbc912e086a319f30e4544d85">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_token.html">XMLToken</a> XMLInputStream::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next token on this XML input stream. </p>
<p>The token is consumed in the process.</p>
<dl class="section return"><dt>Returns</dt><dd>the next <a class="el" href="class_x_m_l_token.html">XMLToken</a>, or an EOF token (i.e., <code><a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230" title="Returns true if this token is an end of file marker.">XMLToken.isEOF()</a> == true</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_input_stream.html#aa332df276ac8c47a740dbb0c21749e0a" title="Returns the next token without consuming it.">peek()</a> </dd></dl>

</div>
</div>
<a id="aa332df276ac8c47a740dbb0c21749e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa332df276ac8c47a740dbb0c21749e0a">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_m_l_token.html">XMLToken</a>&amp; XMLInputStream::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next token <em>without</em> consuming it. </p>
<p>A subsequent call to either <a class="el" href="class_x_m_l_input_stream.html#aa332df276ac8c47a740dbb0c21749e0a" title="Returns the next token without consuming it.">peek()</a> or <a class="el" href="class_x_m_l_input_stream.html#a404a03edbc912e086a319f30e4544d85" title="Returns the next token on this XML input stream.">next()</a> will return the same token.</p>
<dl class="section return"><dt>Returns</dt><dd>the next <a class="el" href="class_x_m_l_token.html">XMLToken</a> or EOF (<a class="el" href="class_x_m_l_token.html#ae963b35615525f8af949373c5765a230" title="Returns true if this token is an end of file marker.">XMLToken.isEOF()</a> == true).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_input_stream.html#a404a03edbc912e086a319f30e4544d85" title="Returns the next token on this XML input stream.">next()</a> </dd></dl>

</div>
</div>
<a id="a4c24b9f851b3af5b33bacadd3263c38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c24b9f851b3af5b33bacadd3263c38c">&#9670;&nbsp;</a></span>setErrorLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLInputStream::setErrorLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> this stream will use to log errors. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac75cf6a2f1137f646c57d15e6e32d668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75cf6a2f1137f646c57d15e6e32d668">&#9670;&nbsp;</a></span>setSBMLNamespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMLInputStream::setSBMLNamespaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the SBML namespaces associated with this XML input stream. </p>
<p>This allows this stream to reference the available SBML namespaces being read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td>the list of namespaces to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7464b56118371b0dea78bc5276e0caae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7464b56118371b0dea78bc5276e0caae">&#9670;&nbsp;</a></span>skipPastEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMLInputStream::skipPastEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_token.html">XMLToken</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume zero or more tokens up to and including the corresponding end element or EOF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>the element whose end will be sought in the input stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a891802729e91d5b1fcf5057a16d5bf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891802729e91d5b1fcf5057a16d5bf78">&#9670;&nbsp;</a></span>skipText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMLInputStream::skipText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume zero or more tokens up to but not including the next XML element or EOF. </p>

</div>
</div>
<a id="aa9a3306cd13c8071c5173150aeeffaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a3306cd13c8071c5173150aeeffaa9">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLInputStream::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a string representation of the underlying token stream. </p>
<dl class="section return"><dt>Returns</dt><dd>a string representing the underlying XML token stream.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is intended for debugging purposes. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
