<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>libSBML C++ API: XMLAttributes Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.20.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_x_m_l_attributes.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_x_m_l_attributes-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">XMLAttributes Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> A list of attributes on an XML element.</p>
<p style='color: #777; font-style: italic'>
This class of objects is defined by libSBML only and has no direct
equivalent in terms of SBML components.  This class is not prescribed by
the SBML specifications, although it is used to implement features
defined in SBML.
</p>
<p>In libSBML's XML interface layer, attributes on an element are stored as a list of values kept in an <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> has methods for adding and removing individual attributes as well as performing other actions on the list of attributes. Classes in libSBML that represent nodes in an XML document (i.e., <a class="el" href="class_x_m_l_node.html">XMLNode</a> and its parent class, <a class="el" href="class_x_m_l_token.html">XMLToken</a>) use <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects to manage attributes on XML elements.</p>
<p>Attributes on an XML element can be written in one of two forms: </p><ul>
<li><code>name="value"</code> </li>
<li><code>prefix:name="value"</code></li>
</ul>
<p>An attribute in XML must always have a value, and the value must always be a quoted string; i.e., it is always <code>name="value"</code> and not <code>name=value</code>. An empty value is represented simply as an empty string; i.e., <code>name=""</code>.</p>
<p>In cases when a <code>prefix</code> is provided with an attribute name, general XML validity rules require that the prefix is an XML namespace prefix that has been declared somewhere else (possibly as an another attribute on the same element). However, the <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class does <em>not</em> test for the proper existence or declaration of XML namespaces&mdash;callers must arrange to do this themselves in some other way. This class only provides facilities for tracking and manipulating attributes and their prefix/URI/name/value components.</p>
<dl class="section note"><dt>Note</dt><dd>Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_triple.html">XMLTriple</a> </dd>
<dd>
<a class="el" href="class_x_m_l_node.html">XMLNode</a> </dd>
<dd>
<a class="el" href="class_x_m_l_token.html">XMLToken</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#_a16">addingEvidenceCodes_2.cpp</a>, and <a class="el" href="create_example_s_b_m_l_8cpp-example.html#_a59">createExampleSBML.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4e8d0dd27a9b619edf3766f5a87e471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a> (const std::string &amp;name, const std::string &amp;value, const std::string namespaceURI=&quot;&quot;, const std::string prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:aa4e8d0dd27a9b619edf3766f5a87e471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attribute to this list of attributes.  <a href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">More...</a><br /></td></tr>
<tr class="separator:aa4e8d0dd27a9b619edf3766f5a87e471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac244dd478625b8c31423c29d6e64e601"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601">add</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, const std::string &amp;value)</td></tr>
<tr class="memdesc:ac244dd478625b8c31423c29d6e64e601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an attribute to this list of attributes.  <a href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601">More...</a><br /></td></tr>
<tr class="separator:ac244dd478625b8c31423c29d6e64e601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab841f490f96d62770359ba0f27a9444b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ab841f490f96d62770359ba0f27a9444b">clear</a> ()</td></tr>
<tr class="memdesc:ab841f490f96d62770359ba0f27a9444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all attributes in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.  <a href="class_x_m_l_attributes.html#ab841f490f96d62770359ba0f27a9444b">More...</a><br /></td></tr>
<tr class="separator:ab841f490f96d62770359ba0f27a9444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69325ddb74b92fe88b54a6e0cd7f54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ad69325ddb74b92fe88b54a6e0cd7f54b">clone</a> () const</td></tr>
<tr class="memdesc:ad69325ddb74b92fe88b54a6e0cd7f54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a deep copy of this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.  <a href="class_x_m_l_attributes.html#ad69325ddb74b92fe88b54a6e0cd7f54b">More...</a><br /></td></tr>
<tr class="separator:ad69325ddb74b92fe88b54a6e0cd7f54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8050369c1767c04fad660225362b6195"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195">getIndex</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a8050369c1767c04fad660225362b6195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of an attribute having a given name.  <a href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195">More...</a><br /></td></tr>
<tr class="separator:a8050369c1767c04fad660225362b6195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fd14dc1178b760b9b9b9ab2b9b1f5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a20fd14dc1178b760b9b9b9ab2b9b1f5e">getIndex</a> (const std::string &amp;name, const std::string &amp;uri) const</td></tr>
<tr class="memdesc:a20fd14dc1178b760b9b9b9ab2b9b1f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the attribute having a given name and XML namespace URI.  <a href="class_x_m_l_attributes.html#a20fd14dc1178b760b9b9b9ab2b9b1f5e">More...</a><br /></td></tr>
<tr class="separator:a20fd14dc1178b760b9b9b9ab2b9b1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1425640a8385f32949ea213bc3a9a80c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a1425640a8385f32949ea213bc3a9a80c">getIndex</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const</td></tr>
<tr class="memdesc:a1425640a8385f32949ea213bc3a9a80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the attribute defined by the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object.  <a href="class_x_m_l_attributes.html#a1425640a8385f32949ea213bc3a9a80c">More...</a><br /></td></tr>
<tr class="separator:a1425640a8385f32949ea213bc3a9a80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936fec6daf5e0510d0dfd9df44fad25a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a">getLength</a> () const</td></tr>
<tr class="memdesc:a936fec6daf5e0510d0dfd9df44fad25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes in this list of attributes.  <a href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a">More...</a><br /></td></tr>
<tr class="separator:a936fec6daf5e0510d0dfd9df44fad25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dcbc0c37755d40a0e20593b0581117"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a05dcbc0c37755d40a0e20593b0581117">getName</a> (int index) const</td></tr>
<tr class="memdesc:a05dcbc0c37755d40a0e20593b0581117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the <em>n</em>th attribute in this list of attributes.  <a href="class_x_m_l_attributes.html#a05dcbc0c37755d40a0e20593b0581117">More...</a><br /></td></tr>
<tr class="separator:a05dcbc0c37755d40a0e20593b0581117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484b45989186e742b7cd642ccf2f63b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a484b45989186e742b7cd642ccf2f63b4">getNumAttributes</a> () const</td></tr>
<tr class="memdesc:a484b45989186e742b7cd642ccf2f63b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes in this list of attributes.  <a href="class_x_m_l_attributes.html#a484b45989186e742b7cd642ccf2f63b4">More...</a><br /></td></tr>
<tr class="separator:a484b45989186e742b7cd642ccf2f63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aa63338d8908636a3e760db2eed092"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a39aa63338d8908636a3e760db2eed092">getPrefix</a> (int index) const</td></tr>
<tr class="memdesc:a39aa63338d8908636a3e760db2eed092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the namespace prefix of the <em>n</em>th attribute in this attribute set.  <a href="class_x_m_l_attributes.html#a39aa63338d8908636a3e760db2eed092">More...</a><br /></td></tr>
<tr class="separator:a39aa63338d8908636a3e760db2eed092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d766ebb4b862881f5a209cec2a8f942"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a6d766ebb4b862881f5a209cec2a8f942">getPrefixedName</a> (int index) const</td></tr>
<tr class="memdesc:a6d766ebb4b862881f5a209cec2a8f942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prefix name of the <em>n</em>th attribute in this attribute set.  <a href="class_x_m_l_attributes.html#a6d766ebb4b862881f5a209cec2a8f942">More...</a><br /></td></tr>
<tr class="separator:a6d766ebb4b862881f5a209cec2a8f942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad82b7966353611170710096065b6f3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a1ad82b7966353611170710096065b6f3">getURI</a> (int index) const</td></tr>
<tr class="memdesc:a1ad82b7966353611170710096065b6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace URI of the <em>n</em>th attribute in this attribute set.  <a href="class_x_m_l_attributes.html#a1ad82b7966353611170710096065b6f3">More...</a><br /></td></tr>
<tr class="separator:a1ad82b7966353611170710096065b6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1478d3d5b3eceef1ec428bef4480a246"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a1478d3d5b3eceef1ec428bef4480a246">getValue</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1478d3d5b3eceef1ec428bef4480a246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a named attribute's value.  <a href="class_x_m_l_attributes.html#a1478d3d5b3eceef1ec428bef4480a246">More...</a><br /></td></tr>
<tr class="separator:a1478d3d5b3eceef1ec428bef4480a246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38135f7e3256e29f955473f8250ad88d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a38135f7e3256e29f955473f8250ad88d">getValue</a> (const std::string &amp;name, const std::string &amp;uri) const</td></tr>
<tr class="memdesc:a38135f7e3256e29f955473f8250ad88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a named attribute's value.  <a href="class_x_m_l_attributes.html#a38135f7e3256e29f955473f8250ad88d">More...</a><br /></td></tr>
<tr class="separator:a38135f7e3256e29f955473f8250ad88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0553e99c24cdf9e9df100b7168afe3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a1e0553e99c24cdf9e9df100b7168afe3">getValue</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const</td></tr>
<tr class="memdesc:a1e0553e99c24cdf9e9df100b7168afe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of an attribute described by a given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object.  <a href="class_x_m_l_attributes.html#a1e0553e99c24cdf9e9df100b7168afe3">More...</a><br /></td></tr>
<tr class="separator:a1e0553e99c24cdf9e9df100b7168afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa38650f61175d00eb024c9a6c3733df"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#afa38650f61175d00eb024c9a6c3733df">getValue</a> (int index) const</td></tr>
<tr class="memdesc:afa38650f61175d00eb024c9a6c3733df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the <em>n</em>th attribute in this list of attributes.  <a href="class_x_m_l_attributes.html#afa38650f61175d00eb024c9a6c3733df">More...</a><br /></td></tr>
<tr class="separator:afa38650f61175d00eb024c9a6c3733df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63575a8679d3d9a8c3e192d78daa0c20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a63575a8679d3d9a8c3e192d78daa0c20">hasAttribute</a> (const std::string &amp;name, const std::string uri=&quot;&quot;) const</td></tr>
<tr class="memdesc:a63575a8679d3d9a8c3e192d78daa0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute with a given name and namespace URI exists.  <a href="class_x_m_l_attributes.html#a63575a8679d3d9a8c3e192d78daa0c20">More...</a><br /></td></tr>
<tr class="separator:a63575a8679d3d9a8c3e192d78daa0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3b2b1a64f845e644c3ad5e7c6947f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3">hasAttribute</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple) const</td></tr>
<tr class="memdesc:aba3b2b1a64f845e644c3ad5e7c6947f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute with the given properties exists.  <a href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3">More...</a><br /></td></tr>
<tr class="separator:aba3b2b1a64f845e644c3ad5e7c6947f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45898e17f92166c87f24fe9152d23fd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7">hasAttribute</a> (int index) const</td></tr>
<tr class="memdesc:a45898e17f92166c87f24fe9152d23fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if an attribute exists at a given index.  <a href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7">More...</a><br /></td></tr>
<tr class="separator:a45898e17f92166c87f24fe9152d23fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48043570a0cac83713ed54f5ffea3603"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a48043570a0cac83713ed54f5ffea3603">isEmpty</a> () const</td></tr>
<tr class="memdesc:a48043570a0cac83713ed54f5ffea3603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this list of attributes is empty.  <a href="class_x_m_l_attributes.html#a48043570a0cac83713ed54f5ffea3603">More...</a><br /></td></tr>
<tr class="separator:a48043570a0cac83713ed54f5ffea3603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044f9a1f9c37123e8a185df1600abc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a4044f9a1f9c37123e8a185df1600abc9">operator=</a> (const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4044f9a1f9c37123e8a185df1600abc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a>.  <a href="class_x_m_l_attributes.html#a4044f9a1f9c37123e8a185df1600abc9">More...</a><br /></td></tr>
<tr class="separator:a4044f9a1f9c37123e8a185df1600abc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78278e85ce1c623f7a9a5cb0249a2f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ab78278e85ce1c623f7a9a5cb0249a2f2">readInto</a> (const std::string &amp;name, bool &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:ab78278e85ce1c623f7a9a5cb0249a2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a Boolean value.  <a href="class_x_m_l_attributes.html#ab78278e85ce1c623f7a9a5cb0249a2f2">More...</a><br /></td></tr>
<tr class="separator:ab78278e85ce1c623f7a9a5cb0249a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e57f08504574bcb559fd7e0809ab9bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a7e57f08504574bcb559fd7e0809ab9bc">readInto</a> (const std::string &amp;name, double &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:a7e57f08504574bcb559fd7e0809ab9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>double</code> value.  <a href="class_x_m_l_attributes.html#a7e57f08504574bcb559fd7e0809ab9bc">More...</a><br /></td></tr>
<tr class="separator:a7e57f08504574bcb559fd7e0809ab9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97e9f68e4e8a8c55a024aed954116b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aa97e9f68e4e8a8c55a024aed954116b3">readInto</a> (const std::string &amp;name, int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:aa97e9f68e4e8a8c55a024aed954116b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>int</code> value.  <a href="class_x_m_l_attributes.html#aa97e9f68e4e8a8c55a024aed954116b3">More...</a><br /></td></tr>
<tr class="separator:aa97e9f68e4e8a8c55a024aed954116b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcafc477ca5acc43cd5f26702a85383c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#afcafc477ca5acc43cd5f26702a85383c">readInto</a> (const std::string &amp;name, long &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:afcafc477ca5acc43cd5f26702a85383c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>long</code> integer value.  <a href="class_x_m_l_attributes.html#afcafc477ca5acc43cd5f26702a85383c">More...</a><br /></td></tr>
<tr class="separator:afcafc477ca5acc43cd5f26702a85383c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf6030a8be152723fbd58003472c812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#afdf6030a8be152723fbd58003472c812">readInto</a> (const std::string &amp;name, std::string &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:afdf6030a8be152723fbd58003472c812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a string value.  <a href="class_x_m_l_attributes.html#afdf6030a8be152723fbd58003472c812">More...</a><br /></td></tr>
<tr class="separator:afdf6030a8be152723fbd58003472c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1944b6814390139f26dd8703788cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#acc1944b6814390139f26dd8703788cb5">readInto</a> (const std::string &amp;name, unsigned int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:acc1944b6814390139f26dd8703788cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>unsigned int</code> value.  <a href="class_x_m_l_attributes.html#acc1944b6814390139f26dd8703788cb5">More...</a><br /></td></tr>
<tr class="separator:acc1944b6814390139f26dd8703788cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b263b299e7c09e5022973084e4788e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#af7b263b299e7c09e5022973084e4788e">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, bool &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:af7b263b299e7c09e5022973084e4788e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a Boolean value.  <a href="class_x_m_l_attributes.html#af7b263b299e7c09e5022973084e4788e">More...</a><br /></td></tr>
<tr class="separator:af7b263b299e7c09e5022973084e4788e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccf4381499f20fbcab14455d8a9c13c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#abccf4381499f20fbcab14455d8a9c13c">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, double &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:abccf4381499f20fbcab14455d8a9c13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>double</code> value.  <a href="class_x_m_l_attributes.html#abccf4381499f20fbcab14455d8a9c13c">More...</a><br /></td></tr>
<tr class="separator:abccf4381499f20fbcab14455d8a9c13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f80748431996fb5ce4c2f8b98cf7603"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a4f80748431996fb5ce4c2f8b98cf7603">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:a4f80748431996fb5ce4c2f8b98cf7603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>int</code> value.  <a href="class_x_m_l_attributes.html#a4f80748431996fb5ce4c2f8b98cf7603">More...</a><br /></td></tr>
<tr class="separator:a4f80748431996fb5ce4c2f8b98cf7603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001fc41cee4bc6333d51c3321b01914d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a001fc41cee4bc6333d51c3321b01914d">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, long &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:a001fc41cee4bc6333d51c3321b01914d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>long</code> integer value.  <a href="class_x_m_l_attributes.html#a001fc41cee4bc6333d51c3321b01914d">More...</a><br /></td></tr>
<tr class="separator:a001fc41cee4bc6333d51c3321b01914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0857de9a26b2f3efa2d8ab3b0a42874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#ae0857de9a26b2f3efa2d8ab3b0a42874">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, std::string &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:ae0857de9a26b2f3efa2d8ab3b0a42874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a string value.  <a href="class_x_m_l_attributes.html#ae0857de9a26b2f3efa2d8ab3b0a42874">More...</a><br /></td></tr>
<tr class="separator:ae0857de9a26b2f3efa2d8ab3b0a42874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6818649d83ece7701c7c35a19d13256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#af6818649d83ece7701c7c35a19d13256">readInto</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple, unsigned int &amp;value, <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *log=NULL, bool required=false, const unsigned int line=0, const unsigned int column=0) const</td></tr>
<tr class="memdesc:af6818649d83ece7701c7c35a19d13256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an attribute as a <code>unsigned int</code> value.  <a href="class_x_m_l_attributes.html#af6818649d83ece7701c7c35a19d13256">More...</a><br /></td></tr>
<tr class="separator:af6818649d83ece7701c7c35a19d13256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93f0fb0bb2933afd40264d23fea4a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aca93f0fb0bb2933afd40264d23fea4a7">remove</a> (const std::string &amp;name, const std::string uri=&quot;&quot;)</td></tr>
<tr class="memdesc:aca93f0fb0bb2933afd40264d23fea4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a named attribute from this list of attributes.  <a href="class_x_m_l_attributes.html#aca93f0fb0bb2933afd40264d23fea4a7">More...</a><br /></td></tr>
<tr class="separator:aca93f0fb0bb2933afd40264d23fea4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807cc84ce5e1d372af5dbf3404815f9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b">remove</a> (const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;triple)</td></tr>
<tr class="memdesc:a807cc84ce5e1d372af5dbf3404815f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specific attribute from this list of attributes.  <a href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b">More...</a><br /></td></tr>
<tr class="separator:a807cc84ce5e1d372af5dbf3404815f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba7c7900c10a809b4d14aec7344fd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1">remove</a> (int n)</td></tr>
<tr class="memdesc:a92ba7c7900c10a809b4d14aec7344fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <em>n</em>th attribute from this list of attributes.  <a href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1">More...</a><br /></td></tr>
<tr class="separator:a92ba7c7900c10a809b4d14aec7344fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb85120c7a1a43e65e35efeba8bef6ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes</a> ()</td></tr>
<tr class="memdesc:aeb85120c7a1a43e65e35efeba8bef6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new, empty <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.  <a href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">More...</a><br /></td></tr>
<tr class="separator:aeb85120c7a1a43e65e35efeba8bef6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfc9deeaac1b011a509e96b33ed5d02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a6cfc9deeaac1b011a509e96b33ed5d02">XMLAttributes</a> (const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;orig)</td></tr>
<tr class="memdesc:a6cfc9deeaac1b011a509e96b33ed5d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; creates a copy of this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.  <a href="class_x_m_l_attributes.html#a6cfc9deeaac1b011a509e96b33ed5d02">More...</a><br /></td></tr>
<tr class="separator:a6cfc9deeaac1b011a509e96b33ed5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666cf3d31b17e758424c7cbbfc77ac22"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_m_l_attributes.html#a666cf3d31b17e758424c7cbbfc77ac22">~XMLAttributes</a> ()</td></tr>
<tr class="memdesc:a666cf3d31b17e758424c7cbbfc77ac22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.  <a href="class_x_m_l_attributes.html#a666cf3d31b17e758424c7cbbfc77ac22">More...</a><br /></td></tr>
<tr class="separator:a666cf3d31b17e758424c7cbbfc77ac22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb85120c7a1a43e65e35efeba8bef6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb85120c7a1a43e65e35efeba8bef6ad">&#9670;&nbsp;</a></span>XMLAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttributes::XMLAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new, empty <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </p>

</div>
</div>
<a id="a666cf3d31b17e758424c7cbbfc77ac22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666cf3d31b17e758424c7cbbfc77ac22">&#9670;&nbsp;</a></span>~XMLAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttributes::~XMLAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </p>

</div>
</div>
<a id="a6cfc9deeaac1b011a509e96b33ed5d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfc9deeaac1b011a509e96b33ed5d02">&#9670;&nbsp;</a></span>XMLAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMLAttributes::XMLAttributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor; creates a copy of this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </p>
<p><code>orig</code> the <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object to copy. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa4e8d0dd27a9b619edf3766f5a87e471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e8d0dd27a9b619edf3766f5a87e471">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>namespaceURI</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an attribute to this list of attributes. </p>
<dl class="section user"><dt></dt><dd>Some explanations are in order about the behavior of <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> with respect to namespace prefixes and namespace URIs. <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> does <em>not</em> verify the consistency of different uses of an XML namespace and the prefix used to refer to it in a given context. It cannot, because the prefix used for a given XML namespace in an XML document may intentionally be different on different elements in the document. Consequently, callers need to manage their own prefix-to-namespace mappings, and need to ensure that the desired prefix is used in any given context.</dd></dl>
<p>When called with attribute names, prefixes and namespace URIs, <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> pays attention to the namespace URIs and not the prefixes: a match is established by a combination of attribute name and namespace URI, and if on different occasions a different prefix is used for the same name/namespace combination, the prefix associated with the namespace on that attribute is overwritten.</p>
<p>Some examples will hopefully clarify this. Here are the results of a sequence of calls to the <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> <code>add</code> methods with different argument combinations. First, we create the object and add one attribute:</p>
<div class="fragment"><div class="line"><a class="code" href="class_x_m_l_attributes.html">XMLAttributes</a> * att = <span class="keyword">new</span> <a class="code" href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes</a>();</div>
<div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div>
<div class="ttc" id="aclass_x_m_l_attributes_html"><div class="ttname"><a href="class_x_m_l_attributes.html">XMLAttributes</a></div><div class="ttdef"><b>Definition:</b> XMLAttributes.h:257</div></div>
<div class="ttc" id="aclass_x_m_l_attributes_html_aa4e8d0dd27a9b619edf3766f5a87e471"><div class="ttname"><a href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">XMLAttributes::add</a></div><div class="ttdeci">int add(const std::string &amp;name, const std::string &amp;value, const std::string namespaceURI=&quot;&quot;, const std::string prefix=&quot;&quot;)</div><div class="ttdoc">Adds an attribute to this list of attributes.</div><div class="ttdef"><b>Definition:</b> XMLAttributes.cpp:140</div></div>
<div class="ttc" id="aclass_x_m_l_attributes_html_aeb85120c7a1a43e65e35efeba8bef6ad"><div class="ttname"><a href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes::XMLAttributes</a></div><div class="ttdeci">XMLAttributes()</div><div class="ttdoc">Creates a new, empty XMLAttributes object.</div><div class="ttdef"><b>Definition:</b> XMLAttributes.cpp:80</div></div>
</div><!-- fragment --><p> The above adds an attribute named <code>myattribute</code> in the namespace <code>myuri</code>, and with the attribute value <code>1</code>. No namespace prefix is associated with the attribute (but the attribute is recorded to exist in the namespace <code>myuri</code>). If this attribute object were written out in XML, it would look like the following (and note that, since no namespace prefix was assigned, none is written out): </p><center><pre>
myattribute="1"
   </pre></center><p>Continuing with this series of examples, suppose we invoke the <code>add</code> method again as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
</div><!-- fragment --><p> The above adds a <em>new</em> attribute <em>also</em> named <code>myattribute</code>, but in a different XML namespace: it is placed in the namespace with no URI, which is to say, the default XML namespace. Both attributes coexist on this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object; both can be independently retrieved.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div>
</div><!-- fragment --><p> The code above now replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. The attribute in the namespace <code>myuri</code> remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div>
</div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. The attribute in the default namespace remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also now assigns a namespace prefix, <code>foo</code>, to the attribute. The attribute <code>myattribute</code> in the default namespace remains untouched. If this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
myattribute="3"
foo:myattribute="5"
   </pre></center><p> Pressing on, now suppose we call the <code>add</code> method as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>);</div>
</div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also assigns a different prefix to the attribute. The namespace of the attribute remains <code>myuri</code>.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p>The code above replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. It also now assigns a namespace prefix, <code>foo</code>, to that attribute. If this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
bar:myattribute="6"
foo:myattribute="7"
   </pre></center><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute. </td></tr>
    <tr><td class="paramname">value</td><td>a string, the value of the attribute. </td></tr>
    <tr><td class="paramname">namespaceURI</td><td>a string, the namespace URI of the attribute. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string, a prefix for the XML namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> &ndash; this value is returned if any of the arguments are <code>NULL</code>. To set an empty <code>prefix</code> and/or <code>name</code> value, use an empty string rather than <code>NULL</code>.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the same name and XML namespace URI already exists in the list of attributes held by this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, then the previous value of that attribute will be replaced with the new value provided to this method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601" title="Adds an attribute to this list of attributes.">add(const XMLTriple&amp; triple, const std::string&amp; value)</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a20fd14dc1178b760b9b9b9ab2b9b1f5e" title="Returns the index of the attribute having a given name and XML namespace URI.">getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a1425640a8385f32949ea213bc3a9a80c" title="Returns the index of the attribute defined by the given XMLTriple object.">getIndex(const XMLTriple&amp; triple) const</a> </dd>
<dd>
hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a21">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac244dd478625b8c31423c29d6e64e601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac244dd478625b8c31423c29d6e64e601">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an attribute to this list of attributes. </p>
<dl class="section user"><dt></dt><dd>Some explanations are in order about the behavior of <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> with respect to namespace prefixes and namespace URIs. <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> does <em>not</em> verify the consistency of different uses of an XML namespace and the prefix used to refer to it in a given context. It cannot, because the prefix used for a given XML namespace in an XML document may intentionally be different on different elements in the document. Consequently, callers need to manage their own prefix-to-namespace mappings, and need to ensure that the desired prefix is used in any given context.</dd></dl>
<p>When called with attribute names, prefixes and namespace URIs, <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> pays attention to the namespace URIs and not the prefixes: a match is established by a combination of attribute name and namespace URI, and if on different occasions a different prefix is used for the same name/namespace combination, the prefix associated with the namespace on that attribute is overwritten.</p>
<p>Some examples will hopefully clarify this. Here are the results of a sequence of calls to the <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> <code>add</code> methods with different argument combinations. First, we create the object and add one attribute:</p>
<div class="fragment"><div class="line"><a class="code" href="class_x_m_l_attributes.html">XMLAttributes</a> * att = <span class="keyword">new</span> <a class="code" href="class_x_m_l_attributes.html#aeb85120c7a1a43e65e35efeba8bef6ad">XMLAttributes</a>();</div>
<div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div>
</div><!-- fragment --><p> The above adds an attribute named <code>myattribute</code> in the namespace <code>myuri</code>, and with the attribute value <code>1</code>. No namespace prefix is associated with the attribute (but the attribute is recorded to exist in the namespace <code>myuri</code>). If this attribute object were written out in XML, it would look like the following (and note that, since no namespace prefix was assigned, none is written out): </p><center><pre>
myattribute="1"
   </pre></center><p>Continuing with this series of examples, suppose we invoke the <code>add</code> method again as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
</div><!-- fragment --><p> The above adds a <em>new</em> attribute <em>also</em> named <code>myattribute</code>, but in a different XML namespace: it is placed in the namespace with no URI, which is to say, the default XML namespace. Both attributes coexist on this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object; both can be independently retrieved.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>);</div>
</div><!-- fragment --><p> The code above now replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. The attribute in the namespace <code>myuri</code> remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>);</div>
</div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. The attribute in the default namespace remains untouched.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also now assigns a namespace prefix, <code>foo</code>, to the attribute. The attribute <code>myattribute</code> in the default namespace remains untouched. If this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
myattribute="3"
foo:myattribute="5"
   </pre></center><p> Pressing on, now suppose we call the <code>add</code> method as follows:</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;myuri&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>);</div>
</div><!-- fragment --><p> The code above replaces the value of the attribute <code>myattribute</code> that resides in the <code>myuri</code> namespace. It also assigns a different prefix to the attribute. The namespace of the attribute remains <code>myuri</code>.</p>
<div class="fragment"><div class="line">att-&gt;<a class="code" href="class_x_m_l_attributes.html#aa4e8d0dd27a9b619edf3766f5a87e471">add</a>(<span class="stringliteral">&quot;myattribute&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p>The code above replaces the value of the attribute <code>myattribute</code> that resides in the default namespace. It also now assigns a namespace prefix, <code>foo</code>, to that attribute. If this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object were written out in XML, it would look like the following: </p><center><pre>
bar:myattribute="6"
foo:myattribute="7"
   </pre></center><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute to be added. </td></tr>
    <tr><td class="paramname">value</td><td>a string, the value of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> &ndash; this value is returned if any of the arguments are <code>NULL</code>. To set an empty value for the attribute, use an empty string rather than <code>NULL</code>.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the same name and XML namespace URI already exists in the list of attributes held by this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, then the previous value of that attribute will be replaced with the new value provided to this method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>add(const std::string&amp; name, const std::string&amp; value, const std::string&amp; namespaceURI, const std::string&amp; prefix) </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a20fd14dc1178b760b9b9b9ab2b9b1f5e" title="Returns the index of the attribute having a given name and XML namespace URI.">getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a1425640a8385f32949ea213bc3a9a80c" title="Returns the index of the attribute defined by the given XMLTriple object.">getIndex(const XMLTriple&amp; triple) const</a> </dd>
<dd>
hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="ab841f490f96d62770359ba0f27a9444b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab841f490f96d62770359ba0f27a9444b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all attributes in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1" title="Removes the nth attribute from this list of attributes.">remove(int n)</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b" title="Removes a specific attribute from this list of attributes.">remove(const XMLTriple&amp; triple)</a> </dd>
<dd>
remove(const std::string&amp; name, const std::string&amp; uri) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a20">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad69325ddb74b92fe88b54a6e0cd7f54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69325ddb74b92fe88b54a6e0cd7f54b">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> * XMLAttributes::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a deep copy of this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the (deep) copy of this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a id="a8050369c1767c04fad660225362b6195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8050369c1767c04fad660225362b6195">&#9670;&nbsp;</a></span>getIndex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of an attribute having a given name. </p>
<dl class="section note"><dt>Note</dt><dd>This method does not check XML namespaces. Thus, if there are multiple attributes with the same local <code>name</code> but different namespaces, this method will return the first one found. Callers should use the more specific methods <a class="el" href="class_x_m_l_attributes.html#a20fd14dc1178b760b9b9b9ab2b9b1f5e" title="Returns the index of the attribute having a given name and XML namespace URI.">XMLAttributes::getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> or <a class="el" href="class_x_m_l_attributes.html#a1425640a8385f32949ea213bc3a9a80c" title="Returns the index of the attribute defined by the given XMLTriple object.">XMLAttributes::getIndex(const XMLTriple&amp; triple) const</a> to find attributes in particular namespaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute whose index is begin sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute with the given local name, or <code>-1</code> if no such attribute is present.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="a20fd14dc1178b760b9b9b9ab2b9b1f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fd14dc1178b760b9b9b9ab2b9b1f5e">&#9670;&nbsp;</a></span>getIndex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the attribute having a given name and XML namespace URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute being sought. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the namespace URI of the attribute being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute with the given local name and namespace URI, or <code>-1</code> if no such attribute is present.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="a1425640a8385f32949ea213bc3a9a80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1425640a8385f32949ea213bc3a9a80c">&#9670;&nbsp;</a></span>getIndex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the attribute defined by the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> describing the attribute being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of an attribute described by the given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object, or <code>-1</code> if no such attribute is present.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="a936fec6daf5e0510d0dfd9df44fad25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936fec6daf5e0510d0dfd9df44fad25a">&#9670;&nbsp;</a></span>getLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of attributes in this list of attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of attributes contained in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a id="a05dcbc0c37755d40a0e20593b0581117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dcbc0c37755d40a0e20593b0581117">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the <em>n</em>th attribute in this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose name is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the local name of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a id="a484b45989186e742b7cd642ccf2f63b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484b45989186e742b7cd642ccf2f63b4">&#9670;&nbsp;</a></span>getNumAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::getNumAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of attributes in this list of attributes. </p>
<p>This function is merely an alias of <a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">XMLAttributes::getLength()</a> introduced for consistency with other libXML classes.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of attributes contained in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object. </dd></dl>

</div>
</div>
<a id="a39aa63338d8908636a3e760db2eed092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aa63338d8908636a3e760db2eed092">&#9670;&nbsp;</a></span>getPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getPrefix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the namespace prefix of the <em>n</em>th attribute in this attribute set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose namespace prefix is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace prefix of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a id="a6d766ebb4b862881f5a209cec2a8f942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d766ebb4b862881f5a209cec2a8f942">&#9670;&nbsp;</a></span>getPrefixedName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getPrefixedName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the prefix name of the <em>n</em>th attribute in this attribute set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose prefixed name is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the prefixed name of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a id="a1ad82b7966353611170710096065b6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad82b7966353611170710096065b6f3">&#9670;&nbsp;</a></span>getURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getURI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the XML namespace URI of the <em>n</em>th attribute in this attribute set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose namespace URI is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML namespace URI of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a id="a1478d3d5b3eceef1ec428bef4480a246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1478d3d5b3eceef1ec428bef4480a246">&#9670;&nbsp;</a></span>getValue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a named attribute's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute value as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the given local <code>name</code> does not exist in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, this method will return an empty string. Callers can use XMLAttributes::hasAttribute(const std::string name, const std::string uri) const to test for an attribute's existence. This method also does not check the XML namespace of the named attribute. Thus, if there are multiple attributes with the same local <code>name</code> but different namespaces, this method will return the value of the first such attribute found. Callers should use the more specific methods <a class="el" href="class_x_m_l_attributes.html#a20fd14dc1178b760b9b9b9ab2b9b1f5e" title="Returns the index of the attribute having a given name and XML namespace URI.">XMLAttributes::getIndex(const std::string&amp; name, const std::string&amp; uri) const</a> or <a class="el" href="class_x_m_l_attributes.html#a1425640a8385f32949ea213bc3a9a80c" title="Returns the index of the attribute defined by the given XMLTriple object.">XMLAttributes::getIndex(const XMLTriple&amp; triple) const </a>to find attributes in particular namespaces.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="a38135f7e3256e29f955473f8250ad88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38135f7e3256e29f955473f8250ad88d">&#9670;&nbsp;</a></span>getValue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a named attribute's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute whose value is being sought. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute value as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the given <code>name</code> and namespace <code>uri</code> does not exist in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, this method will return an empty string. Callers can use XMLAttributes::hasAttribute(const std::string name, const std::string uri) const to test for an attribute's existence.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="a1e0553e99c24cdf9e9df100b7168afe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0553e99c24cdf9e9df100b7168afe3">&#9670;&nbsp;</a></span>getValue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of an attribute described by a given <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> describing the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute value as a string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an attribute with the properties given by <code>triple</code> does not exist in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, this method will return an empty string. Callers can use XMLAttributes::hasAttribute(const std::string name, const std::string uri) const to test for an attribute's existence.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasAttribute(const std::string name, const std::string uri) const </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#aba3b2b1a64f845e644c3ad5e7c6947f3" title="Returns true if an attribute with the given properties exists.">hasAttribute(const XMLTriple&amp; triple) const</a> </dd></dl>

</div>
</div>
<a id="afa38650f61175d00eb024c9a6c3733df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa38650f61175d00eb024c9a6c3733df">&#9670;&nbsp;</a></span>getValue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLAttributes::getValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the <em>n</em>th attribute in this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute whose value is being sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XML value of the <em>n</em>th attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>index</code> is out of range, this method will return an empty string. Callers should use <a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">XMLAttributes::getLength()</a> to check the number of attributes contained in this object or <a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">XMLAttributes::hasAttribute</a>(int index) const to test for the existence of an attribute at a given position.</dd>
<dd>
Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a45898e17f92166c87f24fe9152d23fd7" title="Returns true if an attribute exists at a given index.">hasAttribute(int index) const</a> </dd></dl>

</div>
</div>
<a id="a63575a8679d3d9a8c3e192d78daa0c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63575a8679d3d9a8c3e192d78daa0c20">&#9670;&nbsp;</a></span>hasAttribute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute with a given name and namespace URI exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute. </td></tr>
    <tr><td class="paramname">uri</td><td>a string, the XML namespace URI of the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given local name and XML namespace URI exists in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>add(const std::string&amp; name, const std::string&amp; value, const std::string&amp; namespaceURI, const std::string&amp; prefix) </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601" title="Adds an attribute to this list of attributes.">add(const XMLTriple&amp; triple, const std::string&amp; value)</a> </dd></dl>

</div>
</div>
<a id="aba3b2b1a64f845e644c3ad5e7c6947f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3b2b1a64f845e644c3ad5e7c6947f3">&#9670;&nbsp;</a></span>hasAttribute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute with the given properties exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> describing the attribute to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given XML triple exists in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>add(const std::string&amp; name, const std::string&amp; value, const std::string&amp; namespaceURI, const std::string&amp; prefix) </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#ac244dd478625b8c31423c29d6e64e601" title="Adds an attribute to this list of attributes.">add(const XMLTriple&amp; triple, const std::string&amp; value)</a> </dd></dl>

</div>
</div>
<a id="a45898e17f92166c87f24fe9152d23fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45898e17f92166c87f24fe9152d23fd7">&#9670;&nbsp;</a></span>hasAttribute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if an attribute exists at a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an integer, the position of the attribute to be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an attribute with the given index exists in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream. </dd></dl>

</div>
</div>
<a id="a48043570a0cac83713ed54f5ffea3603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48043570a0cac83713ed54f5ffea3603">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this list of attributes is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object is empty, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4044f9a1f9c37123e8a185df1600abc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4044f9a1f9c37123e8a185df1600abc9">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp; XMLAttributes::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object whose values are used as the basis of the assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab78278e85ce1c623f7a9a5cb0249a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78278e85ce1c623f7a9a5cb0249a2f2">&#9670;&nbsp;</a></span>readInto() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a Boolean value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as a Boolean. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as a Boolean, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#boolean" target="_blank">XML Schema</a>, the valid Boolean values are: <code>"true"</code>, <code>"false"</code>, <code>"1"</code>, and <code>"0"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a Boolean, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a Boolean, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7e57f08504574bcb559fd7e0809ab9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e57f08504574bcb559fd7e0809ab9bc">&#9670;&nbsp;</a></span>readInto() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>double</code> value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as a <code>double</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>double</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#double" target="_blank">XML Schema</a>, valid doubles are the same as valid doubles for the C language and in addition, the special values <code>"INF"</code>, <code>"-INF"</code>, and <code>"NaN"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>double</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a <code>double</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195" title="Returns the index of an attribute having a given name.">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a id="aa97e9f68e4e8a8c55a024aed954116b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97e9f68e4e8a8c55a024aed954116b3">&#9670;&nbsp;</a></span>readInto() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>int</code> value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as an <code>int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as signed <code>int</code> values and cannot represent larger values. Note that variant methods on <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> are available to work with <code>unsigned int</code> type and <code>long</code> type values; users may wish to investigate those methods if they need to handle larger integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195" title="Returns the index of an attribute having a given name.">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a id="afcafc477ca5acc43cd5f26702a85383c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcafc477ca5acc43cd5f26702a85383c">&#9670;&nbsp;</a></span>readInto() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>long</code> integer value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as a <code>long</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>long</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. This is unfortunately a larger space of values than can be represented in a long integer, so libSBML limits the possible values to those that can be stored in a <code>long</code> data type.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a <code>long</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195" title="Returns the index of an attribute having a given name.">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a id="afdf6030a8be152723fbd58003472c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf6030a8be152723fbd58003472c812">&#9670;&nbsp;</a></span>readInto() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a string value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, <code>value</code> is left unmodified.</p>
<p>Unlike the other variant methods on <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a>, there are no format errors possible when reading strings, since XML attribute values <em>are</em> strings. However, the case of a missing attribute can still occur. Errors will be logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>a string, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195" title="Returns the index of an attribute having a given name.">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a id="acc1944b6814390139f26dd8703788cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1944b6814390139f26dd8703788cb5">&#9670;&nbsp;</a></span>readInto() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>unsigned int</code> value. </p>
<p>This method reads the value associated with the attribute <code>name</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as an <code>unsigned int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>unsigned int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as <code>unsigned int</code> and cannot represent larger values. Note that a variant method on <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> is available to work with <code>long</code> type values; users may wish to investigate that method if they need to handle large integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the name of the attribute.</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195" title="Returns the index of an attribute having a given name.">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a id="af7b263b299e7c09e5022973084e4788e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b263b299e7c09e5022973084e4788e">&#9670;&nbsp;</a></span>readInto() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a Boolean value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as a Boolean. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as a Boolean, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#boolean" target="_blank">XML Schema</a>, the valid Boolean values are: <code>"true"</code>, <code>"false"</code>, <code>"1"</code>, and <code>"0"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a Boolean, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute to read.</td></tr>
    <tr><td class="paramname">value</td><td>a Boolean, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="abccf4381499f20fbcab14455d8a9c13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccf4381499f20fbcab14455d8a9c13c">&#9670;&nbsp;</a></span>readInto() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>double</code> value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as a <code>double</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>double</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#double" target="_blank">XML Schema</a>, valid doubles are the same as valid doubles for the C language and in addition, the special values <code>"INF"</code>, <code>"-INF"</code>, and <code>"NaN"</code>, read in a case-insensitive manner.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>double</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute to read.</td></tr>
    <tr><td class="paramname">value</td><td>a <code>double</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4f80748431996fb5ce4c2f8b98cf7603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f80748431996fb5ce4c2f8b98cf7603">&#9670;&nbsp;</a></span>readInto() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>int</code> value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as an <code>int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as signed <code>int</code> values and cannot represent larger values. Note that variant methods on <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> are available to work with <code>unsigned int</code> type and <code>long</code> type values; users may wish to investigate those methods if they need to handle larger integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a001fc41cee4bc6333d51c3321b01914d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001fc41cee4bc6333d51c3321b01914d">&#9670;&nbsp;</a></span>readInto() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>long</code> integer value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as a <code>long</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as a <code>long</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. This is unfortunately a larger space of values than can be represented in a long, so libSBML limits the possible values to those that can be stored in a <code>long</code> data type.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>a <code>long</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The XML namespace associated with the attribute named <code>name</code> is not considered when looking up the attribute. If more than one attribute with the same name exists with different XML namespace URI associations, this method will operate on the first one it encounters; this behavior is identical to <a class="el" href="class_x_m_l_attributes.html#a8050369c1767c04fad660225362b6195" title="Returns the index of an attribute having a given name.">XMLAttributes::getIndex</a> (const std::string&amp; name) const. To have XML namespaces be considered too, callers should use the variant method that takes an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object instead of a string <code>name</code> argument. </dd></dl>

</div>
</div>
<a id="ae0857de9a26b2f3efa2d8ab3b0a42874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0857de9a26b2f3efa2d8ab3b0a42874">&#9670;&nbsp;</a></span>readInto() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a string value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object, <code>value</code> is left unmodified.</p>
<p>Unlike the other variant methods on <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a>, there are no format errors possible when reading strings, since XML attribute values <em>are</em> strings. However, the case of a missing attribute can still occur. Errors will be logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>a string, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af6818649d83ece7701c7c35a19d13256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6818649d83ece7701c7c35a19d13256">&#9670;&nbsp;</a></span>readInto() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMLAttributes::readInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> *&#160;</td>
          <td class="paramname"><em>log</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>column</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interprets an attribute as a <code>unsigned int</code> value. </p>
<p>This method reads the value associated with the attribute described by <code>triple</code> in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object and attempts to interpret it as an <code>unsigned int</code>. If successful, this method stores the value into the variable passed in as <code>value</code>. If no attribute named <code>name</code> can be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object or the value of the attribute could not be interpreted as an <code>unsigned int</code>, <code>value</code> is left unmodified.</p>
<p>According to the specification of <a href="http://www.w3.org/TR/xmlschema-2/#integer" target="_blank">XML Schema</a>, valid <code>long</code>-type values are zero, all positive whole numbers and all negative whole numbers. The present method is designed to interpret numbers as <code>unsigned int</code> and cannot represent larger values. Note that a variant method on <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> is available to work with <code>long</code> type values; users may wish to investigate that method if they need to handle large integer values.</p>
<p>Errors in attempting to interpret the format are logged to <code>log</code>, if an error log object is supplied. If the parameter <code>required</code> is <code>true</code>, then if no attribute named <code>name</code> exists, an error will be logged to <code>log</code> with a description that explains the error is due to a missing required attribute. If the parameter <code>required</code> is <code>false</code> (the default), then if no attribute <code>name</code> exists, no error will be logged and this method will simply return <code>false</code> to indicate an unsuccessful assignment. Finally, if <code>log</code> is provided, <code>name</code> exists, but the value associated with <code>name</code> could not be parsed as a <code>long</code>, then the error logged to <code>log</code> indicates that a value type mismatch occurred.</p>
<p>Values are read using the "C" locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> object describing the attribute</td></tr>
    <tr><td class="paramname">value</td><td>an <code>int</code>, the return parameter into which the value should be assigned.</td></tr>
    <tr><td class="paramname">log</td><td>an <a class="el" href="class_x_m_l_error_log.html">XMLErrorLog</a> object, an optional error log for reporting problems.</td></tr>
    <tr><td class="paramname">required</td><td>a Boolean flag, to indicate whether it should be considered an error if the attribute <code>name</code> cannot be found in this <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> object.</td></tr>
    <tr><td class="paramname">line</td><td>an unsigned int, the line number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
    <tr><td class="paramname">column</td><td>an unsigned int, the column number at which the error occurred. Callers can supply this value if it makes sense for their applications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the attribute was successfully read into value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aca93f0fb0bb2933afd40264d23fea4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca93f0fb0bb2933afd40264d23fea4a7">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uri</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a named attribute from this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a string, the unprefixed name of the attribute to be removed.</td></tr>
    <tr><td class="paramname">uri</td><td>a string, the namespace URI of the attribute to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute with the given <code>name</code> (and <code>uri</code> if specified).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1" title="Removes the nth attribute from this list of attributes.">remove(int n)</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b" title="Removes a specific attribute from this list of attributes.">remove(const XMLTriple&amp; triple)</a> </dd></dl>

</div>
</div>
<a id="a807cc84ce5e1d372af5dbf3404815f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807cc84ce5e1d372af5dbf3404815f9b">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>triple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a specific attribute from this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triple</td><td>an <a class="el" href="class_x_m_l_triple.html">XMLTriple</a> describing the attribute to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute matching the properties of the given <code>triple</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a92ba7c7900c10a809b4d14aec7344fd1" title="Removes the nth attribute from this list of attributes.">remove(int n)</a> </dd>
<dd>
remove(const std::string&amp; name, const std::string&amp; uri) </dd></dl>

</div>
</div>
<a id="a92ba7c7900c10a809b4d14aec7344fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ba7c7900c10a809b4d14aec7344fd1">&#9670;&nbsp;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLAttributes::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <em>n</em>th attribute from this list of attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer the index of the resource to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a></li>
</ul>
The value <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da25d0e2b25f574cfad8e6b5178c0d8a0c">LIBSBML_INDEX_EXCEEDS_SIZE</a> is returned if there is no attribute at the given index <code>n</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that although <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> provides operations that can manipulate attributes based on a numerical index, XML attributes are in fact unordered when they appear in files and data streams. The <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> class provides some list-like facilities, but it is only for the convenience of callers. (For example, it permits callers to loop across all attributes more easily.) Users should keep in mind that the order in which attributes are stored in <a class="el" href="class_x_m_l_attributes.html">XMLAttributes</a> objects has no real impact on the order in which the attributes are read or written from an XML file or data stream.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_x_m_l_attributes.html#a936fec6daf5e0510d0dfd9df44fad25a" title="Returns the number of attributes in this list of attributes.">getLength()</a> </dd>
<dd>
<a class="el" href="class_x_m_l_attributes.html#a807cc84ce5e1d372af5dbf3404815f9b" title="Removes a specific attribute from this list of attributes.">remove(const XMLTriple&amp; triple)</a> </dd>
<dd>
remove(const std::string&amp; name, const std::string&amp; uri) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
