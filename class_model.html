<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>libSBML C++ API: Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.20.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_model.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_model-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Model Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Model:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_model__inherit__graph.svg" width="136" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> An SBML model.</p>
<p>In an SBML model definition, a single object of class <a class="el" href="class_model.html">Model</a> serves as the overall container for the lists of the various model components. All of the lists are optional, but if a given list container is present within the model, the list must not be empty; that is, it must have length one or more. The following are the components and lists permitted in different Levels and Versions of SBML in version 5.20.2
 of libSBML: </p><ul>
<li>
<p class="startli">In SBML Level 1, the components are: <a class="el" href="class_unit_definition.html">UnitDefinition</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_rule.html">Rule</a>, and <a class="el" href="class_reaction.html">Reaction</a>. Instances of the classes are placed inside instances of classes <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a>, <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a>, <a class="el" href="class_list_of_species.html">ListOfSpecies</a>, <a class="el" href="class_list_of_parameters.html">ListOfParameters</a>, <a class="el" href="class_list_of_rules.html">ListOfRules</a>, and <a class="el" href="class_list_of_reactions.html">ListOfReactions</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In SBML Level 2 Version 1, the components are: <a class="el" href="class_function_definition.html">FunctionDefinition</a>, <a class="el" href="class_unit_definition.html">UnitDefinition</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_rule.html">Rule</a>, <a class="el" href="class_reaction.html">Reaction</a> and <a class="el" href="class_event.html">Event</a>. Instances of the classes are placed inside instances of classes <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a>, <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a>, <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a>, <a class="el" href="class_list_of_species.html">ListOfSpecies</a>, <a class="el" href="class_list_of_parameters.html">ListOfParameters</a>, <a class="el" href="class_list_of_rules.html">ListOfRules</a>, <a class="el" href="class_list_of_reactions.html">ListOfReactions</a>, and <a class="el" href="class_list_of_events.html">ListOfEvents</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In SBML Level 2 Versions 2, 3 and 4, the components are: <a class="el" href="class_function_definition.html">FunctionDefinition</a>, <a class="el" href="class_unit_definition.html">UnitDefinition</a>, <a class="el" href="class_compartment_type.html">CompartmentType</a>, <a class="el" href="class_species_type.html">SpeciesType</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_rule.html">Rule</a>, <a class="el" href="class_constraint.html">Constraint</a>, <a class="el" href="class_reaction.html">Reaction</a> and <a class="el" href="class_event.html">Event</a>. Instances of the classes are placed inside instances of classes <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a>, <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a>, <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a>, <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a>, <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a>, <a class="el" href="class_list_of_species.html">ListOfSpecies</a>, <a class="el" href="class_list_of_parameters.html">ListOfParameters</a>, <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a>, <a class="el" href="class_list_of_rules.html">ListOfRules</a>, <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a>, <a class="el" href="class_list_of_reactions.html">ListOfReactions</a>, and <a class="el" href="class_list_of_events.html">ListOfEvents</a>.</p>
<p class="endli"></p>
</li>
<li>
In SBML Level 3 Version 1, the components are: <a class="el" href="class_function_definition.html">FunctionDefinition</a>, <a class="el" href="class_unit_definition.html">UnitDefinition</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_rule.html">Rule</a>, <a class="el" href="class_constraint.html">Constraint</a>, <a class="el" href="class_reaction.html">Reaction</a> and <a class="el" href="class_event.html">Event</a>. Instances of the classes are placed inside instances of classes <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a>, <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a>, <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a>, <a class="el" href="class_list_of_species.html">ListOfSpecies</a>, <a class="el" href="class_list_of_parameters.html">ListOfParameters</a>, <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a>, <a class="el" href="class_list_of_rules.html">ListOfRules</a>, <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a>, <a class="el" href="class_list_of_reactions.html">ListOfReactions</a>, and <a class="el" href="class_list_of_events.html">ListOfEvents</a>. </li>
</ul>
<p>Although all the lists are optional, there are dependencies between SBML components such that defining some components requires defining others. An example is that defining a species requires defining a compartment, and defining a reaction requires defining a species. The dependencies are explained in more detail in the SBML specifications.</p>
<p>In addition to the above lists and attributes, the <a class="el" href="class_model.html">Model</a> class in both SBML Level&#160;2 and Level&#160;3 has the usual two attributes of "id" and "name", and both are optional. As is the case for other SBML components with "id" and "name" attributes, they must be used according to the guidelines described in the SBML specifications. (Within the frameworks of SBML Level&#160;2 and Level&#160;3, a <a class="el" href="class_model.html">Model</a> object identifier has no assigned meaning, but extension packages planned for SBML Level&#160;3 are likely to make use of this identifier.)</p>
<p>Finally, SBML Level&#160;3 has introduced a number of additional <a class="el" href="class_model.html">Model</a> attributes. They are discussed in a separate section below.</p>
<h1><a class="anchor" id="approaches"></a>
Approaches to creating objects using the libSBML API</h1>
<p>LibSBML provides two main mechanisms for creating objects: class constructors (e.g., <a class="el" href="class_species.html#aa8e24eb309535800054011cb5dcea436" title="Creates a new Species using the given SBML level and version values.">Species::Species()</a> ), and <code>create<span class="placeholder-nospace"><em>Object</em></span>()</code> methods (such as <a class="el" href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e" title="Creates a new Species inside this Model and returns it.">Model::createSpecies()</a>) provided by certain <span class="placeholder-nospace"><em>Object</em></span> classes such as <a class="el" href="class_model.html">Model</a>. These multiple mechanisms are provided by libSBML for flexibility and to support different use-cases, but they also have different implications for the overall model structure.</p>
<p>In general, the recommended approach is to use the <code>create<span class="placeholder-nospace"><em>Object</em></span>()</code> methods. These methods both create an object <em>and</em> link it to the parent in one step. Here is an example:</p><div class="fragment"><div class="line"><span class="comment">// Create an SBMLDocument object in Level 3 Version 1 format:</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_s_b_m_l_document.html">SBMLDocument</a>* sbmlDoc = <span class="keyword">new</span> <a class="code" href="class_model.html#a878bda56c626c699ffa01db2d09386b1">SBMLDocument</a>(3, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Model object inside the SBMLDocument object and set</span></div>
<div class="line"><span class="comment">// its identifier.  The call returns a pointer to the Model object</span></div>
<div class="line"><span class="comment">// created, and methods called on that object affect the attributes</span></div>
<div class="line"><span class="comment">// of the object attached to the model (as expected).</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_model.html">Model</a>* model = sbmlDoc-&gt;<a class="code" href="class_s_b_m_l_document.html#a2240e2070ddf9225e3bd8b1a94106a1a">createModel</a>();</div>
<div class="line">model-&gt;<a class="code" href="class_model.html#a9f5805553e7d385ced27c4065fa190fe">setId</a>(<span class="stringliteral">&quot;BestModelEver&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Species object inside the Model and set its identifier.</span></div>
<div class="line"><span class="comment">// Similar to the lines above, this call returns a pointer to the Species</span></div>
<div class="line"><span class="comment">// object created, and methods called on that object affect the attributes</span></div>
<div class="line"><span class="comment">// of the object attached to the model (as expected).</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_species.html">Species</a> *sp = model-&gt;<a class="code" href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e">createSpecies</a>();</div>
<div class="line">sp-&gt;<a class="code" href="class_species.html#ac1f8c4724b30a8a060056dfe61528480">setId</a>(<span class="stringliteral">&quot;MySpecies&quot;</span>);</div>
<div class="ttc" id="aclass_model_html"><div class="ttname"><a href="class_model.html">Model</a></div><div class="ttdef"><b>Definition:</b> Model.h:485</div></div>
<div class="ttc" id="aclass_model_html_a878bda56c626c699ffa01db2d09386b1"><div class="ttname"><a href="class_model.html#a878bda56c626c699ffa01db2d09386b1">Model::SBMLDocument</a></div><div class="ttdeci">friend class SBMLDocument</div><div class="ttdef"><b>Definition:</b> Model.h:491</div></div>
<div class="ttc" id="aclass_model_html_a9f5805553e7d385ced27c4065fa190fe"><div class="ttname"><a href="class_model.html#a9f5805553e7d385ced27c4065fa190fe">Model::setId</a></div><div class="ttdeci">virtual int setId(const std::string &amp;sid)</div><div class="ttdoc">Sets the value of the &quot;id&quot; attribute of this Model.</div><div class="ttdef"><b>Definition:</b> Model.cpp:717</div></div>
<div class="ttc" id="aclass_model_html_aaafcd74740d9cad9e2526467f6019d1e"><div class="ttname"><a href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e">Model::createSpecies</a></div><div class="ttdeci">Species * createSpecies()</div><div class="ttdoc">Creates a new Species inside this Model and returns it.</div><div class="ttdef"><b>Definition:</b> Model.cpp:1586</div></div>
<div class="ttc" id="aclass_s_b_m_l_document_html"><div class="ttname"><a href="class_s_b_m_l_document.html">SBMLDocument</a></div><div class="ttdef"><b>Definition:</b> SBMLDocument.h:349</div></div>
<div class="ttc" id="aclass_s_b_m_l_document_html_a2240e2070ddf9225e3bd8b1a94106a1a"><div class="ttname"><a href="class_s_b_m_l_document.html#a2240e2070ddf9225e3bd8b1a94106a1a">SBMLDocument::createModel</a></div><div class="ttdeci">Model * createModel(const std::string sid=&quot;&quot;)</div><div class="ttdoc">Creates a new Model inside this SBMLDocument, and returns a pointer to it.</div><div class="ttdef"><b>Definition:</b> SBMLDocument.cpp:627</div></div>
<div class="ttc" id="aclass_species_html"><div class="ttname"><a href="class_species.html">Species</a></div><div class="ttdef"><b>Definition:</b> Species.h:429</div></div>
<div class="ttc" id="aclass_species_html_ac1f8c4724b30a8a060056dfe61528480"><div class="ttname"><a href="class_species.html#ac1f8c4724b30a8a060056dfe61528480">Species::setId</a></div><div class="ttdeci">virtual int setId(const std::string &amp;sid)</div><div class="ttdoc">Sets the value of the &quot;id&quot; attribute of this Species.</div><div class="ttdef"><b>Definition:</b> Species.cpp:591</div></div>
</div><!-- fragment --><p>The <code>create<span class="placeholder-nospace"><em>Object</em></span>()</code> methods return a pointer to the object created, but they also add the object to the relevant list of object instances contained in the parent. (These lists become the <code>&lt;listOf<span class="placeholder-nospace"><em>Object</em></span>s&gt;</code> elements in the finished XML rendition of SBML.) In the example above, <a class="el" href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e" title="Creates a new Species inside this Model and returns it.">Model::createSpecies()</a> adds the created species directly to the <code>&lt;listOfSpecies&gt;</code> list in the model. Subsequently, methods called on the species change the species in the model (which is what is expected in most situations).</p>
<h1><a class="anchor" id="model-checking"></a>
Consistency and adherence to SBML specifications</h1>
<p>To make it easier for applications to do whatever they need, libSBML version 5.20.2
 is relatively lax when it comes to enforcing correctness and completeness of models <em>during</em> model construction and editing. Essentially, libSBML <em>will</em> <em>not</em> in most cases check automatically that a model's components have valid attribute values, or that the overall model is consistent and free of errors&mdash;even obvious errors such as duplication of identifiers. This allows applications great leeway in how they build their models, but it means that software authors must take deliberate steps to ensure that the model will be, in the end, valid SBML. These steps include such things as keeping track of the identifiers used in a model, manually performing updates in certain situations where an entity is referenced in more than one place (e.g., a species that is referenced by multiple <a class="el" href="class_species_reference.html">SpeciesReference</a> objects), and so on.</p>
<p>That said, libSBML does provide powerful features for deliberately performing validation of SBML when an application decides it is time to do so. The interfaces to these facilities are on the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> class, in the form of <a class="el" href="class_s_b_m_l_document.html#a5d0aceba94d7005122b9149470998349" title="Performs consistency checking on libSBML&#39;s internal representation of an SBML Model.">SBMLDocument::checkInternalConsistency()</a> and <a class="el" href="class_s_b_m_l_document.html#a25684f139b8f5e44ec2089eba3fdfda0" title="Performs consistency checking and validation on this SBML document.">SBMLDocument::checkConsistency()</a>. Please refer to the documentation for <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> for more information about this.</p>
<p>While applications may play fast and loose and live like free spirits during the construction and editing of SBML models, they should always make sure to call <a class="el" href="class_s_b_m_l_document.html#a5d0aceba94d7005122b9149470998349" title="Performs consistency checking on libSBML&#39;s internal representation of an SBML Model.">SBMLDocument::checkInternalConsistency()</a> and/or <a class="el" href="class_s_b_m_l_document.html#a25684f139b8f5e44ec2089eba3fdfda0" title="Performs consistency checking and validation on this SBML document.">SBMLDocument::checkConsistency()</a> before writing out the final version of an SBML model.</p>
<h1><a class="anchor" id="model-l3-attrib"></a>
Model attributes introduced in SBML LevelÂ 3</h1>
<p>As mentioned above, the <a class="el" href="class_model.html">Model</a> class has a number of optional attributes in SBML Level&#160;3. These are "substanceUnits", "timeUnits", "volumeUnits", "areaUnits", "lengthUnits", "extentUnits", and "conversionFactor. The following provide more information about them.</p>
<h2><a class="anchor" id="model-l3-substanceunits"></a>
The "substanceUnits" attribute</h2>
<p>The "substanceUnits" attribute is used to specify the unit of measurement associated with substance quantities of <a class="el" href="class_species.html">Species</a> objects that do not specify units explicitly. If a given <a class="el" href="class_species.html">Species</a> object definition does not specify its unit of substance quantity via the "substanceUnits" attribute on the <a class="el" href="class_species.html">Species</a> object instance, then that species inherits the value of the <a class="el" href="class_model.html">Model</a> "substanceUnits" attribute. If the <a class="el" href="class_model.html">Model</a> does not define a value for this attribute, then there is no unit to inherit, and all species that do not specify individual "substanceUnits" attribute values then have <em>no</em> declared units for their quantities. The SBML Level&#160;3 specifications provide more details.</p>
<p>Note that when the identifier of a species appears in a model's mathematical expressions, the unit of measurement associated with that identifier is <em>not solely determined</em> by setting "substanceUnits" on <a class="el" href="class_model.html">Model</a> or <a class="el" href="class_species.html">Species</a>. Please see the discussion about units given in the documentation for the <a class="el" href="class_species.html">Species</a> class.</p>
<h2><a class="anchor" id="model-l3-timeunits"></a>
The "timeUnits" attribute</h2>
<p>The "timeUnits" attribute on SBML Level&#160;3's <a class="el" href="class_model.html">Model</a> object is used to specify the unit in which time is measured in the model. This attribute on <a class="el" href="class_model.html">Model</a> is the <em>only</em> way to specify a unit for time in a model. It is a global attribute; time is measured in the model everywhere in the same way. This is particularly relevant to <a class="el" href="class_reaction.html">Reaction</a> and <a class="el" href="class_rate_rule.html">RateRule</a> objects in a model: all <a class="el" href="class_reaction.html">Reaction</a> and <a class="el" href="class_rate_rule.html">RateRule</a> objects in SBML define per-time values, and the unit of time is given by the "timeUnits" attribute on the <a class="el" href="class_model.html">Model</a> object instance. If the <a class="el" href="class_model.html">Model</a> "timeUnits" attribute has no value, it means that the unit of time is not defined for the model's reactions and rate rules. Leaving it unspecified in an SBML model does not result in an invalid model in SBML Level&#160;3; however, as a matter of best practice, we strongly recommend that all models specify units of measurement for time.</p>
<h2><a class="anchor" id="model-l3-voletc"></a>
The "volumeUnits", "areaUnits", and "lengthUnits" attributes</h2>
<p>The attributes "volumeUnits", "areaUnits" and "lengthUnits" together are used to set the units of measurements for the sizes of <a class="el" href="class_compartment.html">Compartment</a> objects in an SBML Level&#160;3 model when those objects do not otherwise specify units. The three attributes correspond to the most common cases of compartment dimensions: "volumeUnits" for compartments having a "spatialDimensions" attribute value of <code>"3"</code>, "areaUnits" for compartments having a "spatialDimensions" attribute value of <code>"2"</code>, and "lengthUnits" for compartments having a "spatialDimensions" attribute value of <code>"1"</code>. The attributes are not applicable to compartments whose "spatialDimensions" attribute values are <em>not</em> one of <code>"1"</code>, <code>"2"</code> or <code>"3"</code>.</p>
<p>If a given <a class="el" href="class_compartment.html">Compartment</a> object instance does not provide a value for its "units" attribute, then the unit of measurement of that compartment's size is inherited from the value specified by the <a class="el" href="class_model.html">Model</a> "volumeUnits", "areaUnits" or "lengthUnits" attribute, as appropriate based on the <a class="el" href="class_compartment.html">Compartment</a> object's "spatialDimensions" attribute value. If the <a class="el" href="class_model.html">Model</a> object does not define the relevant attribute, then there are no units to inherit, and all <a class="el" href="class_compartment.html">Compartment</a> objects that do not set a value for their "units" attribute then have <em>no</em> units associated with their compartment sizes.</p>
<p>The use of three separate attributes is a carry-over from SBML Level&#160;2. Note that it is entirely possible for a model to define a value for two or more of the attributes "volumeUnits", "areaUnits" and "lengthUnits" simultaneously, because SBML models may contain compartments with different numbers of dimensions.</p>
<h2><a class="anchor" id="model-l3-extentunits"></a>
The "extentUnits" attribute</h2>
<p>Reactions are processes that occur over time. These processes involve events of some sort, where a single ``reaction event'' is one in which some set of entities (known as reactants, products and modifiers in SBML) interact, once. The <em>extent</em> of a reaction is a measure of how many times the reaction has occurred, while the time derivative of the extent gives the instantaneous rate at which the reaction is occurring. Thus, what is colloquially referred to as the "rate of the
   reaction" is in fact equal to the rate of change of reaction extent.</p>
<p>In SBML Level&#160;3, the combination of "extentUnits" and "timeUnits" defines the units of kinetic laws in SBML and establishes how the numerical value of each <a class="el" href="class_kinetic_law.html">KineticLaw</a> object's mathematical formula is meant to be interpreted in a model. The units of the kinetic laws are taken to be "extentUnits" divided by "timeUnits".</p>
<p>Note that this embodies an important principle in SBML Level&#160;3 models: <em>all reactions in an SBML model must have the same units</em> for the rate of change of extent. In other words, the units of all reaction rates in the model <em>must be the same</em>. There is only one global value for "extentUnits" and one global value for "timeUnits".</p>
<h2><a class="anchor" id="model-l3-convfactor"></a>
The "conversionFactor" attribute</h2>
<p>The attribute "conversionFactor" in SBML Level&#160;3's <a class="el" href="class_model.html">Model</a> object defines a global value inherited by all <a class="el" href="class_species.html">Species</a> object instances that do not define separate values for their "conversionFactor" attributes. The value of this attribute must refer to a <a class="el" href="class_parameter.html">Parameter</a> object instance defined in the model. The <a class="el" href="class_parameter.html">Parameter</a> object in question must be a constant; ie it must have its "constant" attribute value set to <code>"true"</code>.</p>
<p>If a given <a class="el" href="class_species.html">Species</a> object definition does not specify a conversion factor via the "conversionFactor" attribute on <a class="el" href="class_species.html">Species</a>, then the species inherits the conversion factor specified by the <a class="el" href="class_model.html">Model</a> "conversionFactor" attribute. If the <a class="el" href="class_model.html">Model</a> does not define a value for this attribute, then there is no conversion factor to inherit. More information about conversion factors is provided in the SBML Level&#160;3 specifications. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#_a11">SBMLHttpResolverExample.cpp</a>, <a class="el" href="add_layout_8cpp-example.html#_a8">addLayout.cpp</a>, <a class="el" href="create_example_s_b_m_l_8cpp-example.html#_a1">createExampleSBML.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#_a3">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#_a4">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#_a1">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#_a1">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#_a2">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#_a4">example3.cpp</a>, <a class="el" href="fbc_example1_8cpp-example.html#_a3">fbc_example1.cpp</a>, <a class="el" href="groups_example1_8cpp-example.html#_a3">groups_example1.cpp</a>, <a class="el" href="groups_example2_8cpp-example.html#_a3">groups_example2.cpp</a>, <a class="el" href="print_annotation_8cpp-example.html#_a11">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#_a32">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#_a11">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#_a6">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#_a4">printUnits.cpp</a>, <a class="el" href="qual_example1_8cpp-example.html#_a3">qual_example1.cpp</a>, <a class="el" href="spec_example1_8cpp-example.html#_a35">spec_example1.cpp</a>, <a class="el" href="spec_example2_8cpp-example.html#_a12">spec_example2.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#_a46">spec_example3.cpp</a>, <a class="el" href="spec_example4_8cpp-example.html#_a42">spec_example4.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#_a5">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#_a5">unsetNotes.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75c4b9d309099c77a2c43b6188a95d92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a75c4b9d309099c77a2c43b6188a95d92">addCompartment</a> (const <a class="el" href="class_compartment.html">Compartment</a> *c)</td></tr>
<tr class="memdesc:a75c4b9d309099c77a2c43b6188a95d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_compartment.html">Compartment</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a75c4b9d309099c77a2c43b6188a95d92">More...</a><br /></td></tr>
<tr class="separator:a75c4b9d309099c77a2c43b6188a95d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bf084b6219c2dc2f292751f14b003e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a06bf084b6219c2dc2f292751f14b003e">addCompartmentType</a> (const <a class="el" href="class_compartment_type.html">CompartmentType</a> *ct)</td></tr>
<tr class="memdesc:a06bf084b6219c2dc2f292751f14b003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_compartment_type.html">CompartmentType</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a06bf084b6219c2dc2f292751f14b003e">More...</a><br /></td></tr>
<tr class="separator:a06bf084b6219c2dc2f292751f14b003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255f24c2e94521663a2bd00803a5e83a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a255f24c2e94521663a2bd00803a5e83a">addConstraint</a> (const <a class="el" href="class_constraint.html">Constraint</a> *c)</td></tr>
<tr class="memdesc:a255f24c2e94521663a2bd00803a5e83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_constraint.html">Constraint</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a255f24c2e94521663a2bd00803a5e83a">More...</a><br /></td></tr>
<tr class="separator:a255f24c2e94521663a2bd00803a5e83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852e0bd8bfc64342750faf5cbccec65e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a852e0bd8bfc64342750faf5cbccec65e">addCVTerm</a> (<a class="el" href="class_c_v_term.html">CVTerm</a> *term, bool newBag=false)</td></tr>
<tr class="memdesc:a852e0bd8bfc64342750faf5cbccec65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_c_v_term.html">CVTerm</a> object to this SBML object.  <a href="class_s_base.html#a852e0bd8bfc64342750faf5cbccec65e">More...</a><br /></td></tr>
<tr class="separator:a852e0bd8bfc64342750faf5cbccec65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa342c92c7b9f2599975422d56a4079f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa342c92c7b9f2599975422d56a4079f3">addEvent</a> (const <a class="el" href="class_event.html">Event</a> *e)</td></tr>
<tr class="memdesc:aa342c92c7b9f2599975422d56a4079f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_event.html">Event</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aa342c92c7b9f2599975422d56a4079f3">More...</a><br /></td></tr>
<tr class="separator:aa342c92c7b9f2599975422d56a4079f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1290871a56070866fcab4a039b16cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3d1290871a56070866fcab4a039b16cd">addFunctionDefinition</a> (const <a class="el" href="class_function_definition.html">FunctionDefinition</a> *fd)</td></tr>
<tr class="memdesc:a3d1290871a56070866fcab4a039b16cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_function_definition.html">FunctionDefinition</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a3d1290871a56070866fcab4a039b16cd">More...</a><br /></td></tr>
<tr class="separator:a3d1290871a56070866fcab4a039b16cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb35ac94ab8320fcb1e266f0fd78311"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a2cb35ac94ab8320fcb1e266f0fd78311">addInitialAssignment</a> (const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> *ia)</td></tr>
<tr class="memdesc:a2cb35ac94ab8320fcb1e266f0fd78311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a2cb35ac94ab8320fcb1e266f0fd78311">More...</a><br /></td></tr>
<tr class="separator:a2cb35ac94ab8320fcb1e266f0fd78311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b02092069159bda9b7ff14ecacfca5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a0b02092069159bda9b7ff14ecacfca5d">addModifiedDate</a> (<a class="el" href="class_date.html">Date</a> *date)</td></tr>
<tr class="memdesc:a0b02092069159bda9b7ff14ecacfca5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a modified date to the <a class="el" href="class_model_history.html">ModelHistory</a> of this object.  <a href="class_s_base.html#a0b02092069159bda9b7ff14ecacfca5d">More...</a><br /></td></tr>
<tr class="separator:a0b02092069159bda9b7ff14ecacfca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1668494d46d267c23cadff8e72c5d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3e1668494d46d267c23cadff8e72c5d2">addParameter</a> (const <a class="el" href="class_parameter.html">Parameter</a> *p)</td></tr>
<tr class="memdesc:a3e1668494d46d267c23cadff8e72c5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_parameter.html">Parameter</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a3e1668494d46d267c23cadff8e72c5d2">More...</a><br /></td></tr>
<tr class="separator:a3e1668494d46d267c23cadff8e72c5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae945a58eec61bf2e1bc0269c8bf3b830"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ae945a58eec61bf2e1bc0269c8bf3b830">addReaction</a> (const <a class="el" href="class_reaction.html">Reaction</a> *r)</td></tr>
<tr class="memdesc:ae945a58eec61bf2e1bc0269c8bf3b830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_reaction.html">Reaction</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ae945a58eec61bf2e1bc0269c8bf3b830">More...</a><br /></td></tr>
<tr class="separator:ae945a58eec61bf2e1bc0269c8bf3b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de64a99c51803afea41661695864ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a31de64a99c51803afea41661695864ff">addRule</a> (const <a class="el" href="class_rule.html">Rule</a> *r)</td></tr>
<tr class="memdesc:a31de64a99c51803afea41661695864ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_rule.html">Rule</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a31de64a99c51803afea41661695864ff">More...</a><br /></td></tr>
<tr class="separator:a31de64a99c51803afea41661695864ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2760726af3b7d89f9590e634154d8017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a2760726af3b7d89f9590e634154d8017">addSpecies</a> (const <a class="el" href="class_species.html">Species</a> *s)</td></tr>
<tr class="memdesc:a2760726af3b7d89f9590e634154d8017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_species.html">Species</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a2760726af3b7d89f9590e634154d8017">More...</a><br /></td></tr>
<tr class="separator:a2760726af3b7d89f9590e634154d8017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1f7217efd0a9a5f4d00244bb816ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#adde1f7217efd0a9a5f4d00244bb816ed">addSpeciesType</a> (const <a class="el" href="class_species_type.html">SpeciesType</a> *st)</td></tr>
<tr class="memdesc:adde1f7217efd0a9a5f4d00244bb816ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_species_type.html">SpeciesType</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#adde1f7217efd0a9a5f4d00244bb816ed">More...</a><br /></td></tr>
<tr class="separator:adde1f7217efd0a9a5f4d00244bb816ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6a8da867f27288c39d10e559ccb09f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a6b6a8da867f27288c39d10e559ccb09f">addUnitDefinition</a> (const <a class="el" href="class_unit_definition.html">UnitDefinition</a> *ud)</td></tr>
<tr class="memdesc:a6b6a8da867f27288c39d10e559ccb09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_unit_definition.html">UnitDefinition</a> object to this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a6b6a8da867f27288c39d10e559ccb09f">More...</a><br /></td></tr>
<tr class="separator:a6b6a8da867f27288c39d10e559ccb09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866fda8a7ba2ba45bf861885fdac4dc1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1">appendAnnotation</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a866fda8a7ba2ba45bf861885fdac4dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends annotation content to any existing content in the "annotation" subelement of this object.  <a href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1">More...</a><br /></td></tr>
<tr class="separator:a866fda8a7ba2ba45bf861885fdac4dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2762b5bd0f32b5a4a1e9141ca9a5cbf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf">appendAnnotation</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *annotation)</td></tr>
<tr class="memdesc:ab2762b5bd0f32b5a4a1e9141ca9a5cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends annotation content to any existing content in the "annotation" subelement of this object.  <a href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf">More...</a><br /></td></tr>
<tr class="separator:ab2762b5bd0f32b5a4a1e9141ca9a5cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce3de4a1664f4fb174dda177c746860"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#adce3de4a1664f4fb174dda177c746860">appendFrom</a> (const <a class="el" href="class_model.html">Model</a> *model)</td></tr>
<tr class="memdesc:adce3de4a1664f4fb174dda177c746860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a given <a class="el" href="class_model.html">Model</a> object's subcomponents and appends the copies to the appropriate places in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#adce3de4a1664f4fb174dda177c746860">More...</a><br /></td></tr>
<tr class="separator:adce3de4a1664f4fb174dda177c746860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33da5a2b0b03cbe6af69730869e35212"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212">appendNotes</a> (const std::string &amp;notes)</td></tr>
<tr class="memdesc:a33da5a2b0b03cbe6af69730869e35212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>notes</code> to the "notes" subelement of this object.  <a href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212">More...</a><br /></td></tr>
<tr class="separator:a33da5a2b0b03cbe6af69730869e35212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8c800163c108a27880bd644d7767ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad">appendNotes</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *notes)</td></tr>
<tr class="memdesc:adb8c800163c108a27880bd644d7767ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>notes</code> to the "notes" subelement of this object.  <a href="class_s_base.html#adb8c800163c108a27880bd644d7767ad">More...</a><br /></td></tr>
<tr class="separator:adb8c800163c108a27880bd644d7767ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288edbb994d52c8de423ef925bac23e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a288edbb994d52c8de423ef925bac23e9">clearAllElementIdList</a> ()</td></tr>
<tr class="memdesc:a288edbb994d52c8de423ef925bac23e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the internal list of the identifiers of all elements within this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#a288edbb994d52c8de423ef925bac23e9">More...</a><br /></td></tr>
<tr class="separator:a288edbb994d52c8de423ef925bac23e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aac3fbf0838005f8f94453bd3079dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5aac3fbf0838005f8f94453bd3079dbb">clearAllElementMetaIdList</a> ()</td></tr>
<tr class="memdesc:a5aac3fbf0838005f8f94453bd3079dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the internal list of the metaids of all elements within this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#a5aac3fbf0838005f8f94453bd3079dbb">More...</a><br /></td></tr>
<tr class="separator:a5aac3fbf0838005f8f94453bd3079dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e189fa4c10411e199f3791f977370e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_model.html">Model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a8e189fa4c10411e199f3791f977370e6">clone</a> () const</td></tr>
<tr class="memdesc:a8e189fa4c10411e199f3791f977370e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a deep copy of this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#a8e189fa4c10411e199f3791f977370e6">More...</a><br /></td></tr>
<tr class="separator:a8e189fa4c10411e199f3791f977370e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb00eae391f2edbb097b4efbb6b45fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_algebraic_rule.html">AlgebraicRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a8fb00eae391f2edbb097b4efbb6b45fb">createAlgebraicRule</a> ()</td></tr>
<tr class="memdesc:a8fb00eae391f2edbb097b4efbb6b45fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_algebraic_rule.html">AlgebraicRule</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a8fb00eae391f2edbb097b4efbb6b45fb">More...</a><br /></td></tr>
<tr class="separator:a8fb00eae391f2edbb097b4efbb6b45fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1d0023c589dafa52f8af6591974c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assignment_rule.html">AssignmentRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aaa1d0023c589dafa52f8af6591974c71">createAssignmentRule</a> ()</td></tr>
<tr class="memdesc:aaa1d0023c589dafa52f8af6591974c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_assignment_rule.html">AssignmentRule</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#aaa1d0023c589dafa52f8af6591974c71">More...</a><br /></td></tr>
<tr class="separator:aaa1d0023c589dafa52f8af6591974c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe76cdc808d929b588d793e3d550115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aefe76cdc808d929b588d793e3d550115">createCompartment</a> ()</td></tr>
<tr class="memdesc:aefe76cdc808d929b588d793e3d550115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_compartment.html">Compartment</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#aefe76cdc808d929b588d793e3d550115">More...</a><br /></td></tr>
<tr class="separator:aefe76cdc808d929b588d793e3d550115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd26cd5442b78b6fc4447debd3f413d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#afbd26cd5442b78b6fc4447debd3f413d">createCompartmentType</a> ()</td></tr>
<tr class="memdesc:afbd26cd5442b78b6fc4447debd3f413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_compartment_type.html">CompartmentType</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#afbd26cd5442b78b6fc4447debd3f413d">More...</a><br /></td></tr>
<tr class="separator:afbd26cd5442b78b6fc4447debd3f413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab6d88ef3df96b37cfbd3722f8def1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_constraint.html">Constraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a73ab6d88ef3df96b37cfbd3722f8def1">createConstraint</a> ()</td></tr>
<tr class="memdesc:a73ab6d88ef3df96b37cfbd3722f8def1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_constraint.html">Constraint</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a73ab6d88ef3df96b37cfbd3722f8def1">More...</a><br /></td></tr>
<tr class="separator:a73ab6d88ef3df96b37cfbd3722f8def1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150451e2cf6a696edda9345e000bcd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_delay.html">Delay</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a150451e2cf6a696edda9345e000bcd02">createDelay</a> ()</td></tr>
<tr class="memdesc:a150451e2cf6a696edda9345e000bcd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_delay.html">Delay</a> inside the last <a class="el" href="class_event.html">Event</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#a150451e2cf6a696edda9345e000bcd02">More...</a><br /></td></tr>
<tr class="separator:a150451e2cf6a696edda9345e000bcd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be7c6f9f80fa95f9b47b70ac3bedd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3be7c6f9f80fa95f9b47b70ac3bedd78">createEvent</a> ()</td></tr>
<tr class="memdesc:a3be7c6f9f80fa95f9b47b70ac3bedd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_event.html">Event</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a3be7c6f9f80fa95f9b47b70ac3bedd78">More...</a><br /></td></tr>
<tr class="separator:a3be7c6f9f80fa95f9b47b70ac3bedd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541bdec2121e3de1919a8e81cb9c53d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_event_assignment.html">EventAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a541bdec2121e3de1919a8e81cb9c53d4">createEventAssignment</a> ()</td></tr>
<tr class="memdesc:a541bdec2121e3de1919a8e81cb9c53d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_event_assignment.html">EventAssignment</a> inside the last <a class="el" href="class_event.html">Event</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#a541bdec2121e3de1919a8e81cb9c53d4">More...</a><br /></td></tr>
<tr class="separator:a541bdec2121e3de1919a8e81cb9c53d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1817656dcda8ea92216522f2a3ea635e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1817656dcda8ea92216522f2a3ea635e">createFunctionDefinition</a> ()</td></tr>
<tr class="memdesc:a1817656dcda8ea92216522f2a3ea635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_function_definition.html">FunctionDefinition</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a1817656dcda8ea92216522f2a3ea635e">More...</a><br /></td></tr>
<tr class="separator:a1817656dcda8ea92216522f2a3ea635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271a78b495901e8ad471381c648812fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a271a78b495901e8ad471381c648812fe">createInitialAssignment</a> ()</td></tr>
<tr class="memdesc:a271a78b495901e8ad471381c648812fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_initial_assignment.html">InitialAssignment</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a271a78b495901e8ad471381c648812fe">More...</a><br /></td></tr>
<tr class="separator:a271a78b495901e8ad471381c648812fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb467efcf7a46af60bc7aa3d8bf6ae09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_kinetic_law.html">KineticLaw</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#adb467efcf7a46af60bc7aa3d8bf6ae09">createKineticLaw</a> ()</td></tr>
<tr class="memdesc:adb467efcf7a46af60bc7aa3d8bf6ae09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_kinetic_law.html">KineticLaw</a> inside the last <a class="el" href="class_reaction.html">Reaction</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#adb467efcf7a46af60bc7aa3d8bf6ae09">More...</a><br /></td></tr>
<tr class="separator:adb467efcf7a46af60bc7aa3d8bf6ae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f4250c232594911b097206f184496e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_local_parameter.html">LocalParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad9f4250c232594911b097206f184496e">createKineticLawLocalParameter</a> ()</td></tr>
<tr class="memdesc:ad9f4250c232594911b097206f184496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_local_parameter.html">LocalParameter</a> inside the <a class="el" href="class_kinetic_law.html">KineticLaw</a> object of the last <a class="el" href="class_reaction.html">Reaction</a> created inside this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#ad9f4250c232594911b097206f184496e">More...</a><br /></td></tr>
<tr class="separator:ad9f4250c232594911b097206f184496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9994fffdc23096fb9f9aea3e8c67af4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a9994fffdc23096fb9f9aea3e8c67af4c">createKineticLawParameter</a> ()</td></tr>
<tr class="memdesc:a9994fffdc23096fb9f9aea3e8c67af4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new local <a class="el" href="class_parameter.html">Parameter</a> inside the <a class="el" href="class_kinetic_law.html">KineticLaw</a> object of the last <a class="el" href="class_reaction.html">Reaction</a> created inside this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#a9994fffdc23096fb9f9aea3e8c67af4c">More...</a><br /></td></tr>
<tr class="separator:a9994fffdc23096fb9f9aea3e8c67af4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b7055c6c98dcb54915ceab1635a462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab4b7055c6c98dcb54915ceab1635a462">createModifier</a> ()</td></tr>
<tr class="memdesc:ab4b7055c6c98dcb54915ceab1635a462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> object for a modifier species inside the last <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#ab4b7055c6c98dcb54915ceab1635a462">More...</a><br /></td></tr>
<tr class="separator:ab4b7055c6c98dcb54915ceab1635a462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2403f3ace7c21885d977fc20002a77e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac2403f3ace7c21885d977fc20002a77e">createParameter</a> ()</td></tr>
<tr class="memdesc:ac2403f3ace7c21885d977fc20002a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_parameter.html">Parameter</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#ac2403f3ace7c21885d977fc20002a77e">More...</a><br /></td></tr>
<tr class="separator:ac2403f3ace7c21885d977fc20002a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b2333903676da5ca76da93c582b614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_reference.html">SpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a42b2333903676da5ca76da93c582b614">createProduct</a> ()</td></tr>
<tr class="memdesc:a42b2333903676da5ca76da93c582b614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_species_reference.html">SpeciesReference</a> object for a product inside the last <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#a42b2333903676da5ca76da93c582b614">More...</a><br /></td></tr>
<tr class="separator:a42b2333903676da5ca76da93c582b614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074be8297824ecee69b66f8c37f1695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rate_rule.html">RateRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5074be8297824ecee69b66f8c37f1695">createRateRule</a> ()</td></tr>
<tr class="memdesc:a5074be8297824ecee69b66f8c37f1695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_rate_rule.html">RateRule</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a5074be8297824ecee69b66f8c37f1695">More...</a><br /></td></tr>
<tr class="separator:a5074be8297824ecee69b66f8c37f1695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd3e76323c37f27e23c8f27b82dd272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_reference.html">SpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aefd3e76323c37f27e23c8f27b82dd272">createReactant</a> ()</td></tr>
<tr class="memdesc:aefd3e76323c37f27e23c8f27b82dd272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_species_reference.html">SpeciesReference</a> object for a reactant inside the last <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#aefd3e76323c37f27e23c8f27b82dd272">More...</a><br /></td></tr>
<tr class="separator:aefd3e76323c37f27e23c8f27b82dd272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f670d91516c1817c1e81b4be710e0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1">createReaction</a> ()</td></tr>
<tr class="memdesc:a7f670d91516c1817c1e81b4be710e0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_reaction.html">Reaction</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1">More...</a><br /></td></tr>
<tr class="separator:a7f670d91516c1817c1e81b4be710e0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafcd74740d9cad9e2526467f6019d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e">createSpecies</a> ()</td></tr>
<tr class="memdesc:aaafcd74740d9cad9e2526467f6019d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_species.html">Species</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e">More...</a><br /></td></tr>
<tr class="separator:aaafcd74740d9cad9e2526467f6019d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f61b298f1ed7acf02e3d65cc3989d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af5f61b298f1ed7acf02e3d65cc3989d2">createSpeciesType</a> ()</td></tr>
<tr class="memdesc:af5f61b298f1ed7acf02e3d65cc3989d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_species_type.html">SpeciesType</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#af5f61b298f1ed7acf02e3d65cc3989d2">More...</a><br /></td></tr>
<tr class="separator:af5f61b298f1ed7acf02e3d65cc3989d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a47abb957aad742e36bbcbe32f21eda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_trigger.html">Trigger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1a47abb957aad742e36bbcbe32f21eda">createTrigger</a> ()</td></tr>
<tr class="memdesc:a1a47abb957aad742e36bbcbe32f21eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_trigger.html">Trigger</a> inside the last <a class="el" href="class_event.html">Event</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it.  <a href="class_model.html#a1a47abb957aad742e36bbcbe32f21eda">More...</a><br /></td></tr>
<tr class="separator:a1a47abb957aad742e36bbcbe32f21eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e2da521e50cee4f66f1a56d1cc3203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit.html">Unit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab5e2da521e50cee4f66f1a56d1cc3203">createUnit</a> ()</td></tr>
<tr class="memdesc:ab5e2da521e50cee4f66f1a56d1cc3203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_unit.html">Unit</a> object within the last <a class="el" href="class_unit_definition.html">UnitDefinition</a> object created in this model and returns a pointer to it.  <a href="class_model.html#ab5e2da521e50cee4f66f1a56d1cc3203">More...</a><br /></td></tr>
<tr class="separator:ab5e2da521e50cee4f66f1a56d1cc3203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c105a7f5362459eee4e765f7429d5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3c105a7f5362459eee4e765f7429d5b7">createUnitDefinition</a> ()</td></tr>
<tr class="memdesc:a3c105a7f5362459eee4e765f7429d5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_unit_definition.html">UnitDefinition</a> inside this <a class="el" href="class_model.html">Model</a> and returns it.  <a href="class_model.html#a3c105a7f5362459eee4e765f7429d5b7">More...</a><br /></td></tr>
<tr class="separator:a3c105a7f5362459eee4e765f7429d5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39cfac9d726a12e0f05c6e393953888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac39cfac9d726a12e0f05c6e393953888">deleteDisabledPlugins</a> (bool recursive=true)</td></tr>
<tr class="memdesc:ac39cfac9d726a12e0f05c6e393953888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all information stored in disabled plugins.  <a href="class_s_base.html#ac39cfac9d726a12e0f05c6e393953888">More...</a><br /></td></tr>
<tr class="separator:ac39cfac9d726a12e0f05c6e393953888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0e86c2c28a3226ddc42972241bddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd">disablePackage</a> (const std::string &amp;pkgURI, const std::string &amp;pkgPrefix)</td></tr>
<tr class="memdesc:a5fe0e86c2c28a3226ddc42972241bddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the given SBML Level&#160;3 package on this object.  <a href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd">More...</a><br /></td></tr>
<tr class="separator:a5fe0e86c2c28a3226ddc42972241bddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89a4757c093b8f9c491338bcb278921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae89a4757c093b8f9c491338bcb278921">enablePackage</a> (const std::string &amp;pkgURI, const std::string &amp;pkgPrefix, bool flag)</td></tr>
<tr class="memdesc:ae89a4757c093b8f9c491338bcb278921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the given SBML Level&#160;3 package on this object.  <a href="class_s_base.html#ae89a4757c093b8f9c491338bcb278921">More...</a><br /></td></tr>
<tr class="separator:ae89a4757c093b8f9c491338bcb278921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429026066b1ac0576886268101257122"><td class="memItemLeft" align="right" valign="top">IdList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a429026066b1ac0576886268101257122">getAllElementIdList</a> () const</td></tr>
<tr class="memdesc:a429026066b1ac0576886268101257122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal list of the identifiers of all elements within this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#a429026066b1ac0576886268101257122">More...</a><br /></td></tr>
<tr class="separator:a429026066b1ac0576886268101257122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e278fef0bac04e05929eb1c02fac194"><td class="memItemLeft" align="right" valign="top">IdList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0e278fef0bac04e05929eb1c02fac194">getAllElementMetaIdList</a> () const</td></tr>
<tr class="memdesc:a0e278fef0bac04e05929eb1c02fac194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal list of the metaids of all elements within this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#a0e278fef0bac04e05929eb1c02fac194">More...</a><br /></td></tr>
<tr class="separator:a0e278fef0bac04e05929eb1c02fac194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c36c64d3d15f1e39b603794a8f722e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af5c36c64d3d15f1e39b603794a8f722e">getAllElements</a> (<a class="el" href="class_element_filter.html">ElementFilter</a> *filter=NULL)</td></tr>
<tr class="memdesc:af5c36c64d3d15f1e39b603794a8f722e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_list.html">List</a> of all child objects.  <a href="class_model.html#af5c36c64d3d15f1e39b603794a8f722e">More...</a><br /></td></tr>
<tr class="separator:af5c36c64d3d15f1e39b603794a8f722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143961ca5188d00203c99eef1de854e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a0143961ca5188d00203c99eef1de854e">getAllElementsFromPlugins</a> (<a class="el" href="class_element_filter.html">ElementFilter</a> *filter=NULL)</td></tr>
<tr class="memdesc:a0143961ca5188d00203c99eef1de854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_list.html">List</a> of all child <a class="el" href="class_s_base.html">SBase</a> objects contained in SBML package plug-ins.  <a href="class_s_base.html#a0143961ca5188d00203c99eef1de854e">More...</a><br /></td></tr>
<tr class="separator:a0143961ca5188d00203c99eef1de854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1db4c7f15e643a3cb27fe3b85e22f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac1db4c7f15e643a3cb27fe3b85e22f05">getAncestorOfType</a> (int type, const std::string &amp;pkgName=&quot;core&quot;)</td></tr>
<tr class="memdesc:ac1db4c7f15e643a3cb27fe3b85e22f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ancestor object that has the given SBML type code from the given package.  <a href="class_s_base.html#ac1db4c7f15e643a3cb27fe3b85e22f05">More...</a><br /></td></tr>
<tr class="separator:ac1db4c7f15e643a3cb27fe3b85e22f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a0611fba68fb2d56db3565425f65a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa9a0611fba68fb2d56db3565425f65a0">getAncestorOfType</a> (int type, const std::string pkgName=&quot;core&quot;) const</td></tr>
<tr class="memdesc:aa9a0611fba68fb2d56db3565425f65a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ancestor object that has the given SBML type code from the given package.  <a href="class_s_base.html#aa9a0611fba68fb2d56db3565425f65a0">More...</a><br /></td></tr>
<tr class="separator:aa9a0611fba68fb2d56db3565425f65a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbf6701023075573bd76fa0bd276291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291">getAnnotation</a> ()</td></tr>
<tr class="memdesc:a4fbf6701023075573bd76fa0bd276291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.  <a href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291">More...</a><br /></td></tr>
<tr class="separator:a4fbf6701023075573bd76fa0bd276291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0edc025514ba75d15e6c6b5a831b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2f0edc025514ba75d15e6c6b5a831b66">getAnnotation</a> () const</td></tr>
<tr class="memdesc:a2f0edc025514ba75d15e6c6b5a831b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.  <a href="class_s_base.html#a2f0edc025514ba75d15e6c6b5a831b66">More...</a><br /></td></tr>
<tr class="separator:a2f0edc025514ba75d15e6c6b5a831b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbff50c6c73c044a5c8e29e6b5dcefc6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6">getAnnotationString</a> ()</td></tr>
<tr class="memdesc:adbff50c6c73c044a5c8e29e6b5dcefc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a character string.  <a href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6">More...</a><br /></td></tr>
<tr class="separator:adbff50c6c73c044a5c8e29e6b5dcefc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bca707ae547873a5dea083038c8ccda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5bca707ae547873a5dea083038c8ccda">getAnnotationString</a> () const</td></tr>
<tr class="memdesc:a5bca707ae547873a5dea083038c8ccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a character string.  <a href="class_s_base.html#a5bca707ae547873a5dea083038c8ccda">More...</a><br /></td></tr>
<tr class="separator:a5bca707ae547873a5dea083038c8ccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8770129ecd3def97ec2cd19e155f4468"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a8770129ecd3def97ec2cd19e155f4468">getAreaUnits</a> () const</td></tr>
<tr class="memdesc:a8770129ecd3def97ec2cd19e155f4468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a8770129ecd3def97ec2cd19e155f4468">More...</a><br /></td></tr>
<tr class="separator:a8770129ecd3def97ec2cd19e155f4468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c5939adb92c3f839e07234e1e15f59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assignment_rule.html">AssignmentRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ae9c5939adb92c3f839e07234e1e15f59">getAssignmentRule</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:ae9c5939adb92c3f839e07234e1e15f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#ae9c5939adb92c3f839e07234e1e15f59">More...</a><br /></td></tr>
<tr class="separator:ae9c5939adb92c3f839e07234e1e15f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fd165e2e59c9965fe5c3d2e36cee4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_assignment_rule.html">AssignmentRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a44fd165e2e59c9965fe5c3d2e36cee4c">getAssignmentRule</a> (const std::string &amp;variable) const</td></tr>
<tr class="memdesc:a44fd165e2e59c9965fe5c3d2e36cee4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a44fd165e2e59c9965fe5c3d2e36cee4c">More...</a><br /></td></tr>
<tr class="separator:a44fd165e2e59c9965fe5c3d2e36cee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379bb28a4b10a7e8d7f319b76d3b51c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assignment_rule.html">AssignmentRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a379bb28a4b10a7e8d7f319b76d3b51c2">getAssignmentRuleByVariable</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:a379bb28a4b10a7e8d7f319b76d3b51c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a379bb28a4b10a7e8d7f319b76d3b51c2">More...</a><br /></td></tr>
<tr class="separator:a379bb28a4b10a7e8d7f319b76d3b51c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004c9d2f1c94b3b13133e89691d1469e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_assignment_rule.html">AssignmentRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a004c9d2f1c94b3b13133e89691d1469e">getAssignmentRuleByVariable</a> (const std::string &amp;variable) const</td></tr>
<tr class="memdesc:a004c9d2f1c94b3b13133e89691d1469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a004c9d2f1c94b3b13133e89691d1469e">More...</a><br /></td></tr>
<tr class="separator:a004c9d2f1c94b3b13133e89691d1469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21766ad77868a914ec0780653d0e924f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a21766ad77868a914ec0780653d0e924f">getColumn</a> () const</td></tr>
<tr class="memdesc:a21766ad77868a914ec0780653d0e924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column number where this object first appears in the XML representation of the SBML document.  <a href="class_s_base.html#a21766ad77868a914ec0780653d0e924f">More...</a><br /></td></tr>
<tr class="separator:a21766ad77868a914ec0780653d0e924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668a6f8993d505ba52ed30f53871b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab668a6f8993d505ba52ed30f53871b87">getCompartment</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:ab668a6f8993d505ba52ed30f53871b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_compartment.html">Compartment</a> object based on its identifier.  <a href="class_model.html#ab668a6f8993d505ba52ed30f53871b87">More...</a><br /></td></tr>
<tr class="separator:ab668a6f8993d505ba52ed30f53871b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320447bb4a9fe53d5bc5fe9de8feb46e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a320447bb4a9fe53d5bc5fe9de8feb46e">getCompartment</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a320447bb4a9fe53d5bc5fe9de8feb46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_compartment.html">Compartment</a> object based on its identifier.  <a href="class_model.html#a320447bb4a9fe53d5bc5fe9de8feb46e">More...</a><br /></td></tr>
<tr class="separator:a320447bb4a9fe53d5bc5fe9de8feb46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f8f5cbffd5264fa1e0382d9f53a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a8e6f8f5cbffd5264fa1e0382d9f53a9f">getCompartment</a> (unsigned int n)</td></tr>
<tr class="memdesc:a8e6f8f5cbffd5264fa1e0382d9f53a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_compartment.html">Compartment</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a8e6f8f5cbffd5264fa1e0382d9f53a9f">More...</a><br /></td></tr>
<tr class="separator:a8e6f8f5cbffd5264fa1e0382d9f53a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58cb463a116792bf0796788770471c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab58cb463a116792bf0796788770471c6">getCompartment</a> (unsigned int n) const</td></tr>
<tr class="memdesc:ab58cb463a116792bf0796788770471c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_compartment.html">Compartment</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ab58cb463a116792bf0796788770471c6">More...</a><br /></td></tr>
<tr class="separator:ab58cb463a116792bf0796788770471c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb6d8e60398a63c492f6710b7c7a23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#adfb6d8e60398a63c492f6710b7c7a23f">getCompartmentType</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:adfb6d8e60398a63c492f6710b7c7a23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_compartment_type.html">CompartmentType</a> object based on its identifier.  <a href="class_model.html#adfb6d8e60398a63c492f6710b7c7a23f">More...</a><br /></td></tr>
<tr class="separator:adfb6d8e60398a63c492f6710b7c7a23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a58d1d1f18e5a5488c085768d4f95dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a9a58d1d1f18e5a5488c085768d4f95dd">getCompartmentType</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a9a58d1d1f18e5a5488c085768d4f95dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_compartment_type.html">CompartmentType</a> object based on its identifier.  <a href="class_model.html#a9a58d1d1f18e5a5488c085768d4f95dd">More...</a><br /></td></tr>
<tr class="separator:a9a58d1d1f18e5a5488c085768d4f95dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c02944f51e118d97c18201687e9060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a32c02944f51e118d97c18201687e9060">getCompartmentType</a> (unsigned int n)</td></tr>
<tr class="memdesc:a32c02944f51e118d97c18201687e9060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a32c02944f51e118d97c18201687e9060">More...</a><br /></td></tr>
<tr class="separator:a32c02944f51e118d97c18201687e9060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed23e54294b82e2fc596828ba62b88d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aeed23e54294b82e2fc596828ba62b88d">getCompartmentType</a> (unsigned int n) const</td></tr>
<tr class="memdesc:aeed23e54294b82e2fc596828ba62b88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aeed23e54294b82e2fc596828ba62b88d">More...</a><br /></td></tr>
<tr class="separator:aeed23e54294b82e2fc596828ba62b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9e03c5376df4b359d65b9411b7c635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_constraint.html">Constraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4c9e03c5376df4b359d65b9411b7c635">getConstraint</a> (unsigned int n)</td></tr>
<tr class="memdesc:a4c9e03c5376df4b359d65b9411b7c635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_constraint.html">Constraint</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a4c9e03c5376df4b359d65b9411b7c635">More...</a><br /></td></tr>
<tr class="separator:a4c9e03c5376df4b359d65b9411b7c635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6790afd29ad0451d0a81087bf4588e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_constraint.html">Constraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad6790afd29ad0451d0a81087bf4588e7">getConstraint</a> (unsigned int n) const</td></tr>
<tr class="memdesc:ad6790afd29ad0451d0a81087bf4588e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_constraint.html">Constraint</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ad6790afd29ad0451d0a81087bf4588e7">More...</a><br /></td></tr>
<tr class="separator:ad6790afd29ad0451d0a81087bf4588e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a9869a21e3b2c214a1173337af5285"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a80a9869a21e3b2c214a1173337af5285">getConversionFactor</a> () const</td></tr>
<tr class="memdesc:a80a9869a21e3b2c214a1173337af5285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a80a9869a21e3b2c214a1173337af5285">More...</a><br /></td></tr>
<tr class="separator:a80a9869a21e3b2c214a1173337af5285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b8d724dd9cb8d4cdfcf3f5176dfd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_date.html">Date</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a253b8d724dd9cb8d4cdfcf3f5176dfd2">getCreatedDate</a> ()</td></tr>
<tr class="memdesc:a253b8d724dd9cb8d4cdfcf3f5176dfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "creation date" portion of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object.  <a href="class_s_base.html#a253b8d724dd9cb8d4cdfcf3f5176dfd2">More...</a><br /></td></tr>
<tr class="separator:a253b8d724dd9cb8d4cdfcf3f5176dfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e322246cd669131af4bd325a99ac0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_date.html">Date</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2e322246cd669131af4bd325a99ac0fd">getCreatedDate</a> () const</td></tr>
<tr class="memdesc:a2e322246cd669131af4bd325a99ac0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "creation date" portion of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object.  <a href="class_s_base.html#a2e322246cd669131af4bd325a99ac0fd">More...</a><br /></td></tr>
<tr class="separator:a2e322246cd669131af4bd325a99ac0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ccf83cfe580d386088d88b61e60ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_term.html">CVTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae07ccf83cfe580d386088d88b61e60ff">getCVTerm</a> (unsigned int n)</td></tr>
<tr class="memdesc:ae07ccf83cfe580d386088d88b61e60ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth <a class="el" href="class_c_v_term.html">CVTerm</a> in the list of CVTerms of this SBML object.  <a href="class_s_base.html#ae07ccf83cfe580d386088d88b61e60ff">More...</a><br /></td></tr>
<tr class="separator:ae07ccf83cfe580d386088d88b61e60ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9dcb83f0b3da9466817e3d32f197f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a9b9dcb83f0b3da9466817e3d32f197f0">getCVTerms</a> ()</td></tr>
<tr class="memdesc:a9b9dcb83f0b3da9466817e3d32f197f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects in the annotations of this SBML object.  <a href="class_s_base.html#a9b9dcb83f0b3da9466817e3d32f197f0">More...</a><br /></td></tr>
<tr class="separator:a9b9dcb83f0b3da9466817e3d32f197f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269ee4b549ed8c0fd3f44157500575c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a269ee4b549ed8c0fd3f44157500575c7">getCVTerms</a> () const</td></tr>
<tr class="memdesc:a269ee4b549ed8c0fd3f44157500575c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects in the annotations of this SBML object.  <a href="class_s_base.html#a269ee4b549ed8c0fd3f44157500575c7">More...</a><br /></td></tr>
<tr class="separator:a269ee4b549ed8c0fd3f44157500575c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8012eba52b904a1fcfb2a483eef94810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8012eba52b904a1fcfb2a483eef94810">getDisabledPlugin</a> (unsigned int n)</td></tr>
<tr class="memdesc:a8012eba52b904a1fcfb2a483eef94810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="class_s_base.html#a8012eba52b904a1fcfb2a483eef94810">More...</a><br /></td></tr>
<tr class="separator:a8012eba52b904a1fcfb2a483eef94810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a6692a180f9281c071b77f908dce0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a02a6692a180f9281c071b77f908dce0e">getDisabledPlugin</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a02a6692a180f9281c071b77f908dce0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="class_s_base.html#a02a6692a180f9281c071b77f908dce0e">More...</a><br /></td></tr>
<tr class="separator:a02a6692a180f9281c071b77f908dce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7059f3863360e329ccade685199805"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#afb7059f3863360e329ccade685199805">getElementByMetaId</a> (const std::string &amp;metaid)</td></tr>
<tr class="memdesc:afb7059f3863360e329ccade685199805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with the given <code>metaid</code>.  <a href="class_model.html#afb7059f3863360e329ccade685199805">More...</a><br /></td></tr>
<tr class="separator:afb7059f3863360e329ccade685199805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33897f0c6bf974b8a2418589360ae916"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a33897f0c6bf974b8a2418589360ae916">getElementByMetaId</a> (const std::string &amp;metaid) const</td></tr>
<tr class="memdesc:a33897f0c6bf974b8a2418589360ae916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found.  <a href="class_s_base.html#a33897f0c6bf974b8a2418589360ae916">More...</a><br /></td></tr>
<tr class="separator:a33897f0c6bf974b8a2418589360ae916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6bd54475f4df29acf0e71399ce372"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a68f6bd54475f4df29acf0e71399ce372">getElementBySId</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a68f6bd54475f4df29acf0e71399ce372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element found that has the given <code>id</code>.  <a href="class_model.html#a68f6bd54475f4df29acf0e71399ce372">More...</a><br /></td></tr>
<tr class="separator:a68f6bd54475f4df29acf0e71399ce372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77068f549f7aa55f56a072cda2960183"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a77068f549f7aa55f56a072cda2960183">getElementBySId</a> (const std::string &amp;id) const</td></tr>
<tr class="memdesc:a77068f549f7aa55f56a072cda2960183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element found that has the given <code>id</code> in the model-wide <code>SId</code> namespace, or <code>NULL</code> if no such object is found.  <a href="class_s_base.html#a77068f549f7aa55f56a072cda2960183">More...</a><br /></td></tr>
<tr class="separator:a77068f549f7aa55f56a072cda2960183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b49b964d1f467861fee03c0fd6f5a4"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ae5b49b964d1f467861fee03c0fd6f5a4">getElementName</a> () const</td></tr>
<tr class="memdesc:ae5b49b964d1f467861fee03c0fd6f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML element name of this object, which for <a class="el" href="class_model.html">Model</a>, is always <code>"model"</code>.  <a href="class_model.html#ae5b49b964d1f467861fee03c0fd6f5a4">More...</a><br /></td></tr>
<tr class="separator:ae5b49b964d1f467861fee03c0fd6f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20fde599ec08a56b823f194634e1b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa20fde599ec08a56b823f194634e1b97">getEvent</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:aa20fde599ec08a56b823f194634e1b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="class_event.html">Event</a> object based on its identifier.  <a href="class_model.html#aa20fde599ec08a56b823f194634e1b97">More...</a><br /></td></tr>
<tr class="separator:aa20fde599ec08a56b823f194634e1b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ccb4fe2f17ad025455957a7ed684e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af2ccb4fe2f17ad025455957a7ed684e2">getEvent</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:af2ccb4fe2f17ad025455957a7ed684e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="class_event.html">Event</a> object based on its identifier.  <a href="class_model.html#af2ccb4fe2f17ad025455957a7ed684e2">More...</a><br /></td></tr>
<tr class="separator:af2ccb4fe2f17ad025455957a7ed684e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5bac85150e07a2c23730fcf6a74b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7d5bac85150e07a2c23730fcf6a74b4b">getEvent</a> (unsigned int n)</td></tr>
<tr class="memdesc:a7d5bac85150e07a2c23730fcf6a74b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_event.html">Event</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a7d5bac85150e07a2c23730fcf6a74b4b">More...</a><br /></td></tr>
<tr class="separator:a7d5bac85150e07a2c23730fcf6a74b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b2c2973812e2fef8725af8d577c4ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad8b2c2973812e2fef8725af8d577c4ba">getEvent</a> (unsigned int n) const</td></tr>
<tr class="memdesc:ad8b2c2973812e2fef8725af8d577c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_event.html">Event</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ad8b2c2973812e2fef8725af8d577c4ba">More...</a><br /></td></tr>
<tr class="separator:ad8b2c2973812e2fef8725af8d577c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6988e6c3e3a491fa4fb8dd43a95f941"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac6988e6c3e3a491fa4fb8dd43a95f941">getExtentUnits</a> () const</td></tr>
<tr class="memdesc:ac6988e6c3e3a491fa4fb8dd43a95f941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ac6988e6c3e3a491fa4fb8dd43a95f941">More...</a><br /></td></tr>
<tr class="separator:ac6988e6c3e3a491fa4fb8dd43a95f941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e44396ad8d31384cca789964086e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a227e44396ad8d31384cca789964086e8">getFunctionDefinition</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a227e44396ad8d31384cca789964086e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object based on its identifier.  <a href="class_model.html#a227e44396ad8d31384cca789964086e8">More...</a><br /></td></tr>
<tr class="separator:a227e44396ad8d31384cca789964086e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab544d2bfb325cf140f018109242c1a93"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab544d2bfb325cf140f018109242c1a93">getFunctionDefinition</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:ab544d2bfb325cf140f018109242c1a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object based on its identifier.  <a href="class_model.html#ab544d2bfb325cf140f018109242c1a93">More...</a><br /></td></tr>
<tr class="separator:ab544d2bfb325cf140f018109242c1a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78201bd0c82d46a377cbf3811f19907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab78201bd0c82d46a377cbf3811f19907">getFunctionDefinition</a> (unsigned int n)</td></tr>
<tr class="memdesc:ab78201bd0c82d46a377cbf3811f19907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth FunctionDefinitions object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ab78201bd0c82d46a377cbf3811f19907">More...</a><br /></td></tr>
<tr class="separator:ab78201bd0c82d46a377cbf3811f19907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f50d8d312f2bed5cee8883328c1147"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af0f50d8d312f2bed5cee8883328c1147">getFunctionDefinition</a> (unsigned int n) const</td></tr>
<tr class="memdesc:af0f50d8d312f2bed5cee8883328c1147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth FunctionDefinitions object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#af0f50d8d312f2bed5cee8883328c1147">More...</a><br /></td></tr>
<tr class="separator:af0f50d8d312f2bed5cee8883328c1147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af231d01db6a91e25812995f524476b75"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75">getId</a> () const</td></tr>
<tr class="memdesc:af231d01db6a91e25812995f524476b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "id" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#af231d01db6a91e25812995f524476b75">More...</a><br /></td></tr>
<tr class="separator:af231d01db6a91e25812995f524476b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ffefa4d9901ca0d55f2343c08bb057"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057">getIdAttribute</a> () const</td></tr>
<tr class="memdesc:ad5ffefa4d9901ca0d55f2343c08bb057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "id" attribute of this SBML object.  <a href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057">More...</a><br /></td></tr>
<tr class="separator:ad5ffefa4d9901ca0d55f2343c08bb057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4548193a746f8380b86c8301b484fba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4548193a746f8380b86c8301b484fba2">getInitialAssignment</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a4548193a746f8380b86c8301b484fba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value.  <a href="class_model.html#a4548193a746f8380b86c8301b484fba2">More...</a><br /></td></tr>
<tr class="separator:a4548193a746f8380b86c8301b484fba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0be51d19c074c8d9d353a06f8342c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0b0be51d19c074c8d9d353a06f8342c7">getInitialAssignment</a> (const std::string &amp;symbol) const</td></tr>
<tr class="memdesc:a0b0be51d19c074c8d9d353a06f8342c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value.  <a href="class_model.html#a0b0be51d19c074c8d9d353a06f8342c7">More...</a><br /></td></tr>
<tr class="separator:a0b0be51d19c074c8d9d353a06f8342c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30761b86b96d5e0342f35211d15dea4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a30761b86b96d5e0342f35211d15dea4f">getInitialAssignment</a> (unsigned int n)</td></tr>
<tr class="memdesc:a30761b86b96d5e0342f35211d15dea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a30761b86b96d5e0342f35211d15dea4f">More...</a><br /></td></tr>
<tr class="separator:a30761b86b96d5e0342f35211d15dea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4328b3fe39ac2f1b5f3464365029ec5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4328b3fe39ac2f1b5f3464365029ec5c">getInitialAssignment</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a4328b3fe39ac2f1b5f3464365029ec5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a4328b3fe39ac2f1b5f3464365029ec5c">More...</a><br /></td></tr>
<tr class="separator:a4328b3fe39ac2f1b5f3464365029ec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21b8d2463919bf348f666ace9c3afc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab21b8d2463919bf348f666ace9c3afc2">getInitialAssignmentBySymbol</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:ab21b8d2463919bf348f666ace9c3afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value.  <a href="class_model.html#ab21b8d2463919bf348f666ace9c3afc2">More...</a><br /></td></tr>
<tr class="separator:ab21b8d2463919bf348f666ace9c3afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15b4c0457c8e1778bdda7ceec653278"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af15b4c0457c8e1778bdda7ceec653278">getInitialAssignmentBySymbol</a> (const std::string &amp;symbol) const</td></tr>
<tr class="memdesc:af15b4c0457c8e1778bdda7ceec653278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value.  <a href="class_model.html#af15b4c0457c8e1778bdda7ceec653278">More...</a><br /></td></tr>
<tr class="separator:af15b4c0457c8e1778bdda7ceec653278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1234f39a6631fc0d32539a11ce479270"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1234f39a6631fc0d32539a11ce479270">getLengthUnits</a> () const</td></tr>
<tr class="memdesc:a1234f39a6631fc0d32539a11ce479270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a1234f39a6631fc0d32539a11ce479270">More...</a><br /></td></tr>
<tr class="separator:a1234f39a6631fc0d32539a11ce479270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a70ab6f715e912c6431072c4339f2c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#af0a70ab6f715e912c6431072c4339f2c">getLevel</a> () const</td></tr>
<tr class="memdesc:af0a70ab6f715e912c6431072c4339f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SBML Level of the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing <em>this</em> object.  <a href="class_s_base.html#af0a70ab6f715e912c6431072c4339f2c">More...</a><br /></td></tr>
<tr class="separator:af0a70ab6f715e912c6431072c4339f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad43f3efb39b3c56ec0db212b6e97cf4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aad43f3efb39b3c56ec0db212b6e97cf4">getLine</a> () const</td></tr>
<tr class="memdesc:aad43f3efb39b3c56ec0db212b6e97cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number where this object first appears in the XML representation of the SBML document.  <a href="class_s_base.html#aad43f3efb39b3c56ec0db212b6e97cf4">More...</a><br /></td></tr>
<tr class="separator:aad43f3efb39b3c56ec0db212b6e97cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e60ce9e3b69b9b10345b324d8f6b665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3e60ce9e3b69b9b10345b324d8f6b665">getListOfCompartments</a> ()</td></tr>
<tr class="memdesc:a3e60ce9e3b69b9b10345b324d8f6b665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a3e60ce9e3b69b9b10345b324d8f6b665">More...</a><br /></td></tr>
<tr class="separator:a3e60ce9e3b69b9b10345b324d8f6b665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65c390e35d1158dc50e917cbc3917f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ae65c390e35d1158dc50e917cbc3917f5">getListOfCompartments</a> () const</td></tr>
<tr class="memdesc:ae65c390e35d1158dc50e917cbc3917f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ae65c390e35d1158dc50e917cbc3917f5">More...</a><br /></td></tr>
<tr class="separator:ae65c390e35d1158dc50e917cbc3917f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833d36397b038c031cbe17bc53b1fcc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a833d36397b038c031cbe17bc53b1fcc4">getListOfCompartmentTypes</a> ()</td></tr>
<tr class="memdesc:a833d36397b038c031cbe17bc53b1fcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a833d36397b038c031cbe17bc53b1fcc4">More...</a><br /></td></tr>
<tr class="separator:a833d36397b038c031cbe17bc53b1fcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8934750712a9fb627cbe53a7801173bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a8934750712a9fb627cbe53a7801173bc">getListOfCompartmentTypes</a> () const</td></tr>
<tr class="memdesc:a8934750712a9fb627cbe53a7801173bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a8934750712a9fb627cbe53a7801173bc">More...</a><br /></td></tr>
<tr class="separator:a8934750712a9fb627cbe53a7801173bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad104a119c8cc304aef18734509631140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad104a119c8cc304aef18734509631140">getListOfConstraints</a> ()</td></tr>
<tr class="memdesc:ad104a119c8cc304aef18734509631140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ad104a119c8cc304aef18734509631140">More...</a><br /></td></tr>
<tr class="separator:ad104a119c8cc304aef18734509631140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328f0386f6b7bb60aa29cb6e2a24af42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a328f0386f6b7bb60aa29cb6e2a24af42">getListOfConstraints</a> () const</td></tr>
<tr class="memdesc:a328f0386f6b7bb60aa29cb6e2a24af42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a328f0386f6b7bb60aa29cb6e2a24af42">More...</a><br /></td></tr>
<tr class="separator:a328f0386f6b7bb60aa29cb6e2a24af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5db067d00e836f36993e76a1ce530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_events.html">ListOfEvents</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5ef5db067d00e836f36993e76a1ce530">getListOfEvents</a> ()</td></tr>
<tr class="memdesc:a5ef5db067d00e836f36993e76a1ce530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_events.html">ListOfEvents</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a5ef5db067d00e836f36993e76a1ce530">More...</a><br /></td></tr>
<tr class="separator:a5ef5db067d00e836f36993e76a1ce530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20acb87823395e758a2b7a58c8387858"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_events.html">ListOfEvents</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a20acb87823395e758a2b7a58c8387858">getListOfEvents</a> () const</td></tr>
<tr class="memdesc:a20acb87823395e758a2b7a58c8387858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_events.html">ListOfEvents</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a20acb87823395e758a2b7a58c8387858">More...</a><br /></td></tr>
<tr class="separator:a20acb87823395e758a2b7a58c8387858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438ce0ff480d4730f1a785ef5a8419cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a438ce0ff480d4730f1a785ef5a8419cb">getListOfFunctionDefinitions</a> ()</td></tr>
<tr class="memdesc:a438ce0ff480d4730f1a785ef5a8419cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a438ce0ff480d4730f1a785ef5a8419cb">More...</a><br /></td></tr>
<tr class="separator:a438ce0ff480d4730f1a785ef5a8419cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d9dffd7ce681885e6c045b2f5319e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a30d9dffd7ce681885e6c045b2f5319e5">getListOfFunctionDefinitions</a> () const</td></tr>
<tr class="memdesc:a30d9dffd7ce681885e6c045b2f5319e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a30d9dffd7ce681885e6c045b2f5319e5">More...</a><br /></td></tr>
<tr class="separator:a30d9dffd7ce681885e6c045b2f5319e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae008968a9a51196fb76f1f814ef17093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ae008968a9a51196fb76f1f814ef17093">getListOfInitialAssignments</a> ()</td></tr>
<tr class="memdesc:ae008968a9a51196fb76f1f814ef17093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ae008968a9a51196fb76f1f814ef17093">More...</a><br /></td></tr>
<tr class="separator:ae008968a9a51196fb76f1f814ef17093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9156ed87db2da282de204226af1efe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a6c9156ed87db2da282de204226af1efe">getListOfInitialAssignments</a> () const</td></tr>
<tr class="memdesc:a6c9156ed87db2da282de204226af1efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a6c9156ed87db2da282de204226af1efe">More...</a><br /></td></tr>
<tr class="separator:a6c9156ed87db2da282de204226af1efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be3b7c501e4d73a2194ae5162a9892c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_parameters.html">ListOfParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a2be3b7c501e4d73a2194ae5162a9892c">getListOfParameters</a> ()</td></tr>
<tr class="memdesc:a2be3b7c501e4d73a2194ae5162a9892c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_parameters.html">ListOfParameters</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a2be3b7c501e4d73a2194ae5162a9892c">More...</a><br /></td></tr>
<tr class="separator:a2be3b7c501e4d73a2194ae5162a9892c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9543ad8964d61709318b111ff19a6666"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_parameters.html">ListOfParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a9543ad8964d61709318b111ff19a6666">getListOfParameters</a> () const</td></tr>
<tr class="memdesc:a9543ad8964d61709318b111ff19a6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_parameters.html">ListOfParameters</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a9543ad8964d61709318b111ff19a6666">More...</a><br /></td></tr>
<tr class="separator:a9543ad8964d61709318b111ff19a6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989ef0092019f0a85a085eacbdfe93a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_reactions.html">ListOfReactions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a989ef0092019f0a85a085eacbdfe93a3">getListOfReactions</a> ()</td></tr>
<tr class="memdesc:a989ef0092019f0a85a085eacbdfe93a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_reactions.html">ListOfReactions</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a989ef0092019f0a85a085eacbdfe93a3">More...</a><br /></td></tr>
<tr class="separator:a989ef0092019f0a85a085eacbdfe93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb66d52e2ab5407031461dc02accf32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_reactions.html">ListOfReactions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aebb66d52e2ab5407031461dc02accf32">getListOfReactions</a> () const</td></tr>
<tr class="memdesc:aebb66d52e2ab5407031461dc02accf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_reactions.html">ListOfReactions</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aebb66d52e2ab5407031461dc02accf32">More...</a><br /></td></tr>
<tr class="separator:aebb66d52e2ab5407031461dc02accf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7511667f816c9f0a9ad4437f0767c6b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_rules.html">ListOfRules</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7511667f816c9f0a9ad4437f0767c6b1">getListOfRules</a> ()</td></tr>
<tr class="memdesc:a7511667f816c9f0a9ad4437f0767c6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_rules.html">ListOfRules</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a7511667f816c9f0a9ad4437f0767c6b1">More...</a><br /></td></tr>
<tr class="separator:a7511667f816c9f0a9ad4437f0767c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba010894d7b0af538b5a23c0ed1e2ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_rules.html">ListOfRules</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3ba010894d7b0af538b5a23c0ed1e2ff">getListOfRules</a> () const</td></tr>
<tr class="memdesc:a3ba010894d7b0af538b5a23c0ed1e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_rules.html">ListOfRules</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a3ba010894d7b0af538b5a23c0ed1e2ff">More...</a><br /></td></tr>
<tr class="separator:a3ba010894d7b0af538b5a23c0ed1e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed19ee42ed754eb667185ece1f8c57fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_species.html">ListOfSpecies</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aed19ee42ed754eb667185ece1f8c57fd">getListOfSpecies</a> ()</td></tr>
<tr class="memdesc:aed19ee42ed754eb667185ece1f8c57fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_species.html">ListOfSpecies</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aed19ee42ed754eb667185ece1f8c57fd">More...</a><br /></td></tr>
<tr class="separator:aed19ee42ed754eb667185ece1f8c57fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67c0c4df2a3fb7254c058f3b9f766e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_species.html">ListOfSpecies</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac67c0c4df2a3fb7254c058f3b9f766e5">getListOfSpecies</a> () const</td></tr>
<tr class="memdesc:ac67c0c4df2a3fb7254c058f3b9f766e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_species.html">ListOfSpecies</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ac67c0c4df2a3fb7254c058f3b9f766e5">More...</a><br /></td></tr>
<tr class="separator:ac67c0c4df2a3fb7254c058f3b9f766e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ffd3b6ebb4ba3a7ac6153365d8e6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a96ffd3b6ebb4ba3a7ac6153365d8e6ae">getListOfSpeciesTypes</a> ()</td></tr>
<tr class="memdesc:a96ffd3b6ebb4ba3a7ac6153365d8e6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a96ffd3b6ebb4ba3a7ac6153365d8e6ae">More...</a><br /></td></tr>
<tr class="separator:a96ffd3b6ebb4ba3a7ac6153365d8e6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a700eb1b248e5e777d3367883eb744"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a30a700eb1b248e5e777d3367883eb744">getListOfSpeciesTypes</a> () const</td></tr>
<tr class="memdesc:a30a700eb1b248e5e777d3367883eb744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a30a700eb1b248e5e777d3367883eb744">More...</a><br /></td></tr>
<tr class="separator:a30a700eb1b248e5e777d3367883eb744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae878c530a55722e8b2ef2d6bdacdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5ae878c530a55722e8b2ef2d6bdacdb5">getListOfUnitDefinitions</a> ()</td></tr>
<tr class="memdesc:a5ae878c530a55722e8b2ef2d6bdacdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a5ae878c530a55722e8b2ef2d6bdacdb5">More...</a><br /></td></tr>
<tr class="separator:a5ae878c530a55722e8b2ef2d6bdacdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5d9baf0bffb9b4d6e6bdfca8d29a5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1b5d9baf0bffb9b4d6e6bdfca8d29a5c">getListOfUnitDefinitions</a> () const</td></tr>
<tr class="memdesc:a1b5d9baf0bffb9b4d6e6bdfca8d29a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a1b5d9baf0bffb9b4d6e6bdfca8d29a5c">More...</a><br /></td></tr>
<tr class="separator:a1b5d9baf0bffb9b4d6e6bdfca8d29a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2880c1c6a2df519371637a9234ed68a4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4">getMetaId</a> ()</td></tr>
<tr class="memdesc:a2880c1c6a2df519371637a9234ed68a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "metaid" attribute of this SBML object.  <a href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4">More...</a><br /></td></tr>
<tr class="separator:a2880c1c6a2df519371637a9234ed68a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0b37251e4b259cb09a6fca2f9d03bb"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ada0b37251e4b259cb09a6fca2f9d03bb">getMetaId</a> () const</td></tr>
<tr class="memdesc:ada0b37251e4b259cb09a6fca2f9d03bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "metaid" attribute of this SBML object.  <a href="class_s_base.html#ada0b37251e4b259cb09a6fca2f9d03bb">More...</a><br /></td></tr>
<tr class="separator:ada0b37251e4b259cb09a6fca2f9d03bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e0b06ec3f0dd2bfdafeec6c9d7cc2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_model.html">Model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2">getModel</a> () const</td></tr>
<tr class="memdesc:a776e0b06ec3f0dd2bfdafeec6c9d7cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_model.html">Model</a> object for the SBML Document in which the current object is located.  <a href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2">More...</a><br /></td></tr>
<tr class="separator:a776e0b06ec3f0dd2bfdafeec6c9d7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027dbf22b8bf74bbb0ce5cd4453851c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_model_history.html">ModelHistory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a027dbf22b8bf74bbb0ce5cd4453851c7">getModelHistory</a> ()</td></tr>
<tr class="memdesc:a027dbf22b8bf74bbb0ce5cd4453851c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_model_history.html">ModelHistory</a> object, if any, attached to this object.  <a href="class_s_base.html#a027dbf22b8bf74bbb0ce5cd4453851c7">More...</a><br /></td></tr>
<tr class="separator:a027dbf22b8bf74bbb0ce5cd4453851c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f1d849c7f806d075836b21d322150f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_model_history.html">ModelHistory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a60f1d849c7f806d075836b21d322150f">getModelHistory</a> () const</td></tr>
<tr class="memdesc:a60f1d849c7f806d075836b21d322150f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_model_history.html">ModelHistory</a> object, if any, attached to this object.  <a href="class_s_base.html#a60f1d849c7f806d075836b21d322150f">More...</a><br /></td></tr>
<tr class="separator:a60f1d849c7f806d075836b21d322150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c66e9efaa9f3724a3254802330ede6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_date.html">Date</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a69c66e9efaa9f3724a3254802330ede6">getModifiedDate</a> (unsigned int n)</td></tr>
<tr class="memdesc:a69c66e9efaa9f3724a3254802330ede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_date.html">Date</a> object in the list of "modified date" values stored in the <a class="el" href="class_model_history.html">ModelHistory</a> of this object.  <a href="class_s_base.html#a69c66e9efaa9f3724a3254802330ede6">More...</a><br /></td></tr>
<tr class="separator:a69c66e9efaa9f3724a3254802330ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bb2d63da5f2ecc1734aad0b3e70f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a61bb2d63da5f2ecc1734aad0b3e70f33">getModifierSpeciesReference</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a61bb2d63da5f2ecc1734aad0b3e70f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> object based on its identifier.  <a href="class_model.html#a61bb2d63da5f2ecc1734aad0b3e70f33">More...</a><br /></td></tr>
<tr class="separator:a61bb2d63da5f2ecc1734aad0b3e70f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376858bd7e129594dfc5298d34d82f12"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a376858bd7e129594dfc5298d34d82f12">getModifierSpeciesReference</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a376858bd7e129594dfc5298d34d82f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> object based on its identifier.  <a href="class_model.html#a376858bd7e129594dfc5298d34d82f12">More...</a><br /></td></tr>
<tr class="separator:a376858bd7e129594dfc5298d34d82f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2792c4eb1d7509af701f555290c3890"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac2792c4eb1d7509af701f555290c3890">getName</a> () const</td></tr>
<tr class="memdesc:ac2792c4eb1d7509af701f555290c3890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "name" attribute of this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#ac2792c4eb1d7509af701f555290c3890">More...</a><br /></td></tr>
<tr class="separator:ac2792c4eb1d7509af701f555290c3890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb90be26c77f519375553365af009a58"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#adb90be26c77f519375553365af009a58">getNamespaces</a> () const</td></tr>
<tr class="memdesc:adb90be26c77f519375553365af009a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the XML Namespaces declared on the SBML document owning this object.  <a href="class_s_base.html#adb90be26c77f519375553365af009a58">More...</a><br /></td></tr>
<tr class="separator:adb90be26c77f519375553365af009a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34eff3877f512b8bf31facff83c4483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483">getNotes</a> ()</td></tr>
<tr class="memdesc:ac34eff3877f512b8bf31facff83c4483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.  <a href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483">More...</a><br /></td></tr>
<tr class="separator:ac34eff3877f512b8bf31facff83c4483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f2358ae580d6ed278789698f80209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab65f2358ae580d6ed278789698f80209">getNotes</a> () const</td></tr>
<tr class="memdesc:ab65f2358ae580d6ed278789698f80209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.  <a href="class_s_base.html#ab65f2358ae580d6ed278789698f80209">More...</a><br /></td></tr>
<tr class="separator:ab65f2358ae580d6ed278789698f80209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee96ee206a55837c0d7b936f20f14d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d">getNotesString</a> ()</td></tr>
<tr class="memdesc:a6eee96ee206a55837c0d7b936f20f14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a string.  <a href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d">More...</a><br /></td></tr>
<tr class="separator:a6eee96ee206a55837c0d7b936f20f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ec2702ebbdf35aef0a0626b0ffd52f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a07ec2702ebbdf35aef0a0626b0ffd52f">getNotesString</a> () const</td></tr>
<tr class="memdesc:a07ec2702ebbdf35aef0a0626b0ffd52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a string.  <a href="class_s_base.html#a07ec2702ebbdf35aef0a0626b0ffd52f">More...</a><br /></td></tr>
<tr class="separator:a07ec2702ebbdf35aef0a0626b0ffd52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8f60919460dc3856d0432a240cade5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#abb8f60919460dc3856d0432a240cade5">getNumCompartments</a> () const</td></tr>
<tr class="memdesc:abb8f60919460dc3856d0432a240cade5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_compartment.html">Compartment</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#abb8f60919460dc3856d0432a240cade5">More...</a><br /></td></tr>
<tr class="separator:abb8f60919460dc3856d0432a240cade5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2935ff1f5539657581fefbbb550e37"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7f2935ff1f5539657581fefbbb550e37">getNumCompartmentTypes</a> () const</td></tr>
<tr class="memdesc:a7f2935ff1f5539657581fefbbb550e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_compartment_type.html">CompartmentType</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a7f2935ff1f5539657581fefbbb550e37">More...</a><br /></td></tr>
<tr class="separator:a7f2935ff1f5539657581fefbbb550e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd27979d85c9870289d4c4ad28947b2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#afbd27979d85c9870289d4c4ad28947b2">getNumConstraints</a> () const</td></tr>
<tr class="memdesc:afbd27979d85c9870289d4c4ad28947b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_constraint.html">Constraint</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#afbd27979d85c9870289d4c4ad28947b2">More...</a><br /></td></tr>
<tr class="separator:afbd27979d85c9870289d4c4ad28947b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997486d0a21de5d8d07bd764cd6cb21c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a997486d0a21de5d8d07bd764cd6cb21c">getNumCVTerms</a> () const</td></tr>
<tr class="memdesc:a997486d0a21de5d8d07bd764cd6cb21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="class_c_v_term.html">CVTerm</a> objects in the annotations of this SBML object.  <a href="class_s_base.html#a997486d0a21de5d8d07bd764cd6cb21c">More...</a><br /></td></tr>
<tr class="separator:a997486d0a21de5d8d07bd764cd6cb21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf923bf768a4b2a8a7aee09854f797"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a63bf923bf768a4b2a8a7aee09854f797">getNumDisabledPlugins</a> () const</td></tr>
<tr class="memdesc:a63bf923bf768a4b2a8a7aee09854f797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extensions known.  <a href="class_s_base.html#a63bf923bf768a4b2a8a7aee09854f797">More...</a><br /></td></tr>
<tr class="separator:a63bf923bf768a4b2a8a7aee09854f797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff053452a7ad32e33022ccb9133da1d6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aff053452a7ad32e33022ccb9133da1d6">getNumEvents</a> () const</td></tr>
<tr class="memdesc:aff053452a7ad32e33022ccb9133da1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_event.html">Event</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aff053452a7ad32e33022ccb9133da1d6">More...</a><br /></td></tr>
<tr class="separator:aff053452a7ad32e33022ccb9133da1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b9277141fa0df08ea1e07a702bb19"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a068b9277141fa0df08ea1e07a702bb19">getNumFunctionDefinitions</a> () const</td></tr>
<tr class="memdesc:a068b9277141fa0df08ea1e07a702bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_function_definition.html">FunctionDefinition</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a068b9277141fa0df08ea1e07a702bb19">More...</a><br /></td></tr>
<tr class="separator:a068b9277141fa0df08ea1e07a702bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b326343ac5b663ebc84421f5725be"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4d7b326343ac5b663ebc84421f5725be">getNumInitialAssignments</a> () const</td></tr>
<tr class="memdesc:a4d7b326343ac5b663ebc84421f5725be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_initial_assignment.html">InitialAssignment</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a4d7b326343ac5b663ebc84421f5725be">More...</a><br /></td></tr>
<tr class="separator:a4d7b326343ac5b663ebc84421f5725be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973c76cb7a7370cb221911591a73460a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a973c76cb7a7370cb221911591a73460a">getNumModifiedDates</a> ()</td></tr>
<tr class="memdesc:a973c76cb7a7370cb221911591a73460a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_date.html">Date</a> objects in the <a class="el" href="class_model_history.html">ModelHistory</a> of this Iobject's list of "modified dates".  <a href="class_s_base.html#a973c76cb7a7370cb221911591a73460a">More...</a><br /></td></tr>
<tr class="separator:a973c76cb7a7370cb221911591a73460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d44a21afa6b27162fc7b3c589815f96"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1d44a21afa6b27162fc7b3c589815f96">getNumParameters</a> () const</td></tr>
<tr class="memdesc:a1d44a21afa6b27162fc7b3c589815f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_parameter.html">Parameter</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a1d44a21afa6b27162fc7b3c589815f96">More...</a><br /></td></tr>
<tr class="separator:a1d44a21afa6b27162fc7b3c589815f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7463b70032c344b42454f0291e2e204"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad7463b70032c344b42454f0291e2e204">getNumPlugins</a> () const</td></tr>
<tr class="memdesc:ad7463b70032c344b42454f0291e2e204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions known.  <a href="class_s_base.html#ad7463b70032c344b42454f0291e2e204">More...</a><br /></td></tr>
<tr class="separator:ad7463b70032c344b42454f0291e2e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b39971406b8bcb6a020db6d0b728d9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac5b39971406b8bcb6a020db6d0b728d9">getNumReactions</a> () const</td></tr>
<tr class="memdesc:ac5b39971406b8bcb6a020db6d0b728d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_reaction.html">Reaction</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ac5b39971406b8bcb6a020db6d0b728d9">More...</a><br /></td></tr>
<tr class="separator:ac5b39971406b8bcb6a020db6d0b728d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400e574b923a45bc01a7c83b68d3de13"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a400e574b923a45bc01a7c83b68d3de13">getNumRules</a> () const</td></tr>
<tr class="memdesc:a400e574b923a45bc01a7c83b68d3de13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_rule.html">Rule</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a400e574b923a45bc01a7c83b68d3de13">More...</a><br /></td></tr>
<tr class="separator:a400e574b923a45bc01a7c83b68d3de13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035d37d5a6cd0616666919d5222fdf37"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a035d37d5a6cd0616666919d5222fdf37">getNumSpecies</a> () const</td></tr>
<tr class="memdesc:a035d37d5a6cd0616666919d5222fdf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_species.html">Species</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a035d37d5a6cd0616666919d5222fdf37">More...</a><br /></td></tr>
<tr class="separator:a035d37d5a6cd0616666919d5222fdf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b39ed2833288b9fd2a8e002946bb9f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a20b39ed2833288b9fd2a8e002946bb9f">getNumSpeciesTypes</a> () const</td></tr>
<tr class="memdesc:a20b39ed2833288b9fd2a8e002946bb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_species_type.html">SpeciesType</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a20b39ed2833288b9fd2a8e002946bb9f">More...</a><br /></td></tr>
<tr class="separator:a20b39ed2833288b9fd2a8e002946bb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7013fa0e459a2196c84be5e5f334dfd0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7013fa0e459a2196c84be5e5f334dfd0">getNumSpeciesWithBoundaryCondition</a> () const</td></tr>
<tr class="memdesc:a7013fa0e459a2196c84be5e5f334dfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_species.html">Species</a> in this <a class="el" href="class_model.html">Model</a> having their "boundaryCondition" attribute value set to <code>true</code>.  <a href="class_model.html#a7013fa0e459a2196c84be5e5f334dfd0">More...</a><br /></td></tr>
<tr class="separator:a7013fa0e459a2196c84be5e5f334dfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41fa0586c006f1f2875ac523ecf4512"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab41fa0586c006f1f2875ac523ecf4512">getNumUnitDefinitions</a> () const</td></tr>
<tr class="memdesc:ab41fa0586c006f1f2875ac523ecf4512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="class_unit_definition.html">UnitDefinition</a> objects in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ab41fa0586c006f1f2875ac523ecf4512">More...</a><br /></td></tr>
<tr class="separator:ab41fa0586c006f1f2875ac523ecf4512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4de53b00ecec3e135fcb9d36fb1bf3b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab4de53b00ecec3e135fcb9d36fb1bf3b">getPackageCoreVersion</a> () const</td></tr>
<tr class="memdesc:ab4de53b00ecec3e135fcb9d36fb1bf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SBML Core Version within the SBML Level of the actual object.  <a href="class_s_base.html#ab4de53b00ecec3e135fcb9d36fb1bf3b">More...</a><br /></td></tr>
<tr class="separator:ab4de53b00ecec3e135fcb9d36fb1bf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031d1da6a39bae8afd5201677fb32c02"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a031d1da6a39bae8afd5201677fb32c02">getPackageName</a> () const</td></tr>
<tr class="memdesc:a031d1da6a39bae8afd5201677fb32c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the SBML Level&#160;3 package in which this element is defined.  <a href="class_s_base.html#a031d1da6a39bae8afd5201677fb32c02">More...</a><br /></td></tr>
<tr class="separator:a031d1da6a39bae8afd5201677fb32c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3428c9a9705777183a0ded66981b504"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab3428c9a9705777183a0ded66981b504">getPackageVersion</a> () const</td></tr>
<tr class="memdesc:ab3428c9a9705777183a0ded66981b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Version of the SBML Level&#160;3 package to which this element belongs to.  <a href="class_s_base.html#ab3428c9a9705777183a0ded66981b504">More...</a><br /></td></tr>
<tr class="separator:ab3428c9a9705777183a0ded66981b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d7d892a3cb920c360d903141fdc71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a12d7d892a3cb920c360d903141fdc71b">getParameter</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a12d7d892a3cb920c360d903141fdc71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_parameter.html">Parameter</a> object based on its identifier.  <a href="class_model.html#a12d7d892a3cb920c360d903141fdc71b">More...</a><br /></td></tr>
<tr class="separator:a12d7d892a3cb920c360d903141fdc71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d227e0b16df21449fb411c946f0943"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a48d227e0b16df21449fb411c946f0943">getParameter</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a48d227e0b16df21449fb411c946f0943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_parameter.html">Parameter</a> object based on its identifier.  <a href="class_model.html#a48d227e0b16df21449fb411c946f0943">More...</a><br /></td></tr>
<tr class="separator:a48d227e0b16df21449fb411c946f0943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b503c1bb2fc52089f5383afefd1ad41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a2b503c1bb2fc52089f5383afefd1ad41">getParameter</a> (unsigned int n)</td></tr>
<tr class="memdesc:a2b503c1bb2fc52089f5383afefd1ad41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_parameter.html">Parameter</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a2b503c1bb2fc52089f5383afefd1ad41">More...</a><br /></td></tr>
<tr class="separator:a2b503c1bb2fc52089f5383afefd1ad41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f4145ed39578a1b70f04e46eff76b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a71f4145ed39578a1b70f04e46eff76b6">getParameter</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a71f4145ed39578a1b70f04e46eff76b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_parameter.html">Parameter</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a71f4145ed39578a1b70f04e46eff76b6">More...</a><br /></td></tr>
<tr class="separator:a71f4145ed39578a1b70f04e46eff76b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5912bd9dc06f63029b86dbda467bb3c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5">getParentSBMLObject</a> ()</td></tr>
<tr class="memdesc:a5912bd9dc06f63029b86dbda467bb3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent SBML object containing this object.  <a href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5">More...</a><br /></td></tr>
<tr class="separator:a5912bd9dc06f63029b86dbda467bb3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70becec9ecd5ecf42973a8e0d4609487"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a70becec9ecd5ecf42973a8e0d4609487">getParentSBMLObject</a> () const</td></tr>
<tr class="memdesc:a70becec9ecd5ecf42973a8e0d4609487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent SBML object containing this object.  <a href="class_s_base.html#a70becec9ecd5ecf42973a8e0d4609487">More...</a><br /></td></tr>
<tr class="separator:a70becec9ecd5ecf42973a8e0d4609487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8d8b8cb1ae5980d228174073fc5abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc">getPlugin</a> (const std::string &amp;package)</td></tr>
<tr class="memdesc:aee8d8b8cb1ae5980d228174073fc5abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI.  <a href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc">More...</a><br /></td></tr>
<tr class="separator:aee8d8b8cb1ae5980d228174073fc5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944bad557986b43d8328d5727d1aa890"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a944bad557986b43d8328d5727d1aa890">getPlugin</a> (const std::string &amp;package) const</td></tr>
<tr class="memdesc:a944bad557986b43d8328d5727d1aa890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI.  <a href="class_s_base.html#a944bad557986b43d8328d5727d1aa890">More...</a><br /></td></tr>
<tr class="separator:a944bad557986b43d8328d5727d1aa890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcd32c8ab7537433f7f7851818c60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed">getPlugin</a> (unsigned int n)</td></tr>
<tr class="memdesc:a2bcd32c8ab7537433f7f7851818c60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed">More...</a><br /></td></tr>
<tr class="separator:a2bcd32c8ab7537433f7f7851818c60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a14de158d4139b4c28130eb7d8aa60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad0a14de158d4139b4c28130eb7d8aa60">getPlugin</a> (unsigned int n) const</td></tr>
<tr class="memdesc:ad0a14de158d4139b4c28130eb7d8aa60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="class_s_base.html#ad0a14de158d4139b4c28130eb7d8aa60">More...</a><br /></td></tr>
<tr class="separator:ad0a14de158d4139b4c28130eb7d8aa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea0697e71112c6b2e004820960afc84"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#adea0697e71112c6b2e004820960afc84">getPrefix</a> () const</td></tr>
<tr class="memdesc:adea0697e71112c6b2e004820960afc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace prefix of this element.  <a href="class_s_base.html#adea0697e71112c6b2e004820960afc84">More...</a><br /></td></tr>
<tr class="separator:adea0697e71112c6b2e004820960afc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b150a40b12e8d9b050482dbc021b259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rate_rule.html">RateRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0b150a40b12e8d9b050482dbc021b259">getRateRule</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:a0b150a40b12e8d9b050482dbc021b259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a0b150a40b12e8d9b050482dbc021b259">More...</a><br /></td></tr>
<tr class="separator:a0b150a40b12e8d9b050482dbc021b259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c465ee9340dde15368277bbe4b1205d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rate_rule.html">RateRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5c465ee9340dde15368277bbe4b1205d">getRateRule</a> (const std::string &amp;variable) const</td></tr>
<tr class="memdesc:a5c465ee9340dde15368277bbe4b1205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a5c465ee9340dde15368277bbe4b1205d">More...</a><br /></td></tr>
<tr class="separator:a5c465ee9340dde15368277bbe4b1205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e64bcdbf44ab32964cc917f25197ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rate_rule.html">RateRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a8e64bcdbf44ab32964cc917f25197ef0">getRateRuleByVariable</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:a8e64bcdbf44ab32964cc917f25197ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a8e64bcdbf44ab32964cc917f25197ef0">More...</a><br /></td></tr>
<tr class="separator:a8e64bcdbf44ab32964cc917f25197ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9694778de9417cdacba08c053933f642"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rate_rule.html">RateRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a9694778de9417cdacba08c053933f642">getRateRuleByVariable</a> (const std::string &amp;variable) const</td></tr>
<tr class="memdesc:a9694778de9417cdacba08c053933f642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a9694778de9417cdacba08c053933f642">More...</a><br /></td></tr>
<tr class="separator:a9694778de9417cdacba08c053933f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dee681a2d7aa0249357e601aaf9ef9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4dee681a2d7aa0249357e601aaf9ef9d">getReaction</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a4dee681a2d7aa0249357e601aaf9ef9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_reaction.html">Reaction</a> object based on its identifier.  <a href="class_model.html#a4dee681a2d7aa0249357e601aaf9ef9d">More...</a><br /></td></tr>
<tr class="separator:a4dee681a2d7aa0249357e601aaf9ef9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610ab44a41b27c87e544204e534f87c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a610ab44a41b27c87e544204e534f87c9">getReaction</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a610ab44a41b27c87e544204e534f87c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_reaction.html">Reaction</a> object based on its identifier.  <a href="class_model.html#a610ab44a41b27c87e544204e534f87c9">More...</a><br /></td></tr>
<tr class="separator:a610ab44a41b27c87e544204e534f87c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837839393e18f73ebf49d406e045452a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a837839393e18f73ebf49d406e045452a">getReaction</a> (unsigned int n)</td></tr>
<tr class="memdesc:a837839393e18f73ebf49d406e045452a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a837839393e18f73ebf49d406e045452a">More...</a><br /></td></tr>
<tr class="separator:a837839393e18f73ebf49d406e045452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f49f128fe8fbaae0854c07b204c932"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a72f49f128fe8fbaae0854c07b204c932">getReaction</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a72f49f128fe8fbaae0854c07b204c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a72f49f128fe8fbaae0854c07b204c932">More...</a><br /></td></tr>
<tr class="separator:a72f49f128fe8fbaae0854c07b204c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fea5f04d8d0a59aef58fa6fc8236b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18">BiolQualifierType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a31fea5f04d8d0a59aef58fa6fc8236b7">getResourceBiologicalQualifier</a> (std::string resource) const</td></tr>
<tr class="memdesc:a31fea5f04d8d0a59aef58fa6fc8236b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MIRIAM <em>biological qualifier</em> associated with the given resource.  <a href="class_s_base.html#a31fea5f04d8d0a59aef58fa6fc8236b7">More...</a><br /></td></tr>
<tr class="separator:a31fea5f04d8d0a59aef58fa6fc8236b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92975919a08b70b0ded5f1364f5ec44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d">ModelQualifierType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac92975919a08b70b0ded5f1364f5ec44">getResourceModelQualifier</a> (std::string resource) const</td></tr>
<tr class="memdesc:ac92975919a08b70b0ded5f1364f5ec44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MIRIAM <em>model qualifier</em> associated with the given resource.  <a href="class_s_base.html#ac92975919a08b70b0ded5f1364f5ec44">More...</a><br /></td></tr>
<tr class="separator:ac92975919a08b70b0ded5f1364f5ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf6c88423e97ff58612d04ae102ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa7bf6c88423e97ff58612d04ae102ea8">getRule</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:aa7bf6c88423e97ff58612d04ae102ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#aa7bf6c88423e97ff58612d04ae102ea8">More...</a><br /></td></tr>
<tr class="separator:aa7bf6c88423e97ff58612d04ae102ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916c1ed0deae85ddfa73422678f2ab7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a916c1ed0deae85ddfa73422678f2ab7d">getRule</a> (const std::string &amp;variable) const</td></tr>
<tr class="memdesc:a916c1ed0deae85ddfa73422678f2ab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#a916c1ed0deae85ddfa73422678f2ab7d">More...</a><br /></td></tr>
<tr class="separator:a916c1ed0deae85ddfa73422678f2ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd77b68c151fa2496e9771923c622f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0bd77b68c151fa2496e9771923c622f0">getRule</a> (unsigned int n)</td></tr>
<tr class="memdesc:a0bd77b68c151fa2496e9771923c622f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_rule.html">Rule</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a0bd77b68c151fa2496e9771923c622f0">More...</a><br /></td></tr>
<tr class="separator:a0bd77b68c151fa2496e9771923c622f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d97b73106ee54cbce751e0c30f4f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a074d97b73106ee54cbce751e0c30f4f1">getRule</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a074d97b73106ee54cbce751e0c30f4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_rule.html">Rule</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a074d97b73106ee54cbce751e0c30f4f1">More...</a><br /></td></tr>
<tr class="separator:a074d97b73106ee54cbce751e0c30f4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb367a8928edfe6f17126bf3d1a00e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#adb367a8928edfe6f17126bf3d1a00e4a">getRuleByVariable</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:adb367a8928edfe6f17126bf3d1a00e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#adb367a8928edfe6f17126bf3d1a00e4a">More...</a><br /></td></tr>
<tr class="separator:adb367a8928edfe6f17126bf3d1a00e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeedb8e17d84adb2abb0413e9d433ac1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aaeedb8e17d84adb2abb0413e9d433ac1">getRuleByVariable</a> (const std::string &amp;variable) const</td></tr>
<tr class="memdesc:aaeedb8e17d84adb2abb0413e9d433ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value.  <a href="class_model.html#aaeedb8e17d84adb2abb0413e9d433ac1">More...</a><br /></td></tr>
<tr class="separator:aaeedb8e17d84adb2abb0413e9d433ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1725f1b98e08e54485ec52404d579a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a">getSBMLDocument</a> ()</td></tr>
<tr class="memdesc:a7e1725f1b98e08e54485ec52404d579a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing this object instance.  <a href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a">More...</a><br /></td></tr>
<tr class="separator:a7e1725f1b98e08e54485ec52404d579a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c576e7dfaa4651bca4a782c9e09ac20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8c576e7dfaa4651bca4a782c9e09ac20">getSBMLDocument</a> () const</td></tr>
<tr class="memdesc:a8c576e7dfaa4651bca4a782c9e09ac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing this object instance.  <a href="class_s_base.html#a8c576e7dfaa4651bca4a782c9e09ac20">More...</a><br /></td></tr>
<tr class="separator:a8c576e7dfaa4651bca4a782c9e09ac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d34cc625c18425a35a5513b88851a73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7d34cc625c18425a35a5513b88851a73">getSBOTerm</a> () const</td></tr>
<tr class="memdesc:a7d34cc625c18425a35a5513b88851a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer portion of the value of the "sboTerm" attribute of this object.  <a href="class_s_base.html#a7d34cc625c18425a35a5513b88851a73">More...</a><br /></td></tr>
<tr class="separator:a7d34cc625c18425a35a5513b88851a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed6545c2fab20f6dc44ae0c282c4fbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8ed6545c2fab20f6dc44ae0c282c4fbf">getSBOTermAsURL</a> () const</td></tr>
<tr class="memdesc:a8ed6545c2fab20f6dc44ae0c282c4fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the URL representation of the "sboTerm" attribute of this object.  <a href="class_s_base.html#a8ed6545c2fab20f6dc44ae0c282c4fbf">More...</a><br /></td></tr>
<tr class="separator:a8ed6545c2fab20f6dc44ae0c282c4fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57cbc2da2e34a8c829e42743e68dd85"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae57cbc2da2e34a8c829e42743e68dd85">getSBOTermID</a> () const</td></tr>
<tr class="memdesc:ae57cbc2da2e34a8c829e42743e68dd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the "sboTerm" attribute of this object.  <a href="class_s_base.html#ae57cbc2da2e34a8c829e42743e68dd85">More...</a><br /></td></tr>
<tr class="separator:ae57cbc2da2e34a8c829e42743e68dd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c57c79a886696cd33aa0aca4671ff59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a2c57c79a886696cd33aa0aca4671ff59">getSpecies</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a2c57c79a886696cd33aa0aca4671ff59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_species.html">Species</a> object based on its identifier.  <a href="class_model.html#a2c57c79a886696cd33aa0aca4671ff59">More...</a><br /></td></tr>
<tr class="separator:a2c57c79a886696cd33aa0aca4671ff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4578b30237a83f2e8c8f791f30a8e3b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad4578b30237a83f2e8c8f791f30a8e3b">getSpecies</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:ad4578b30237a83f2e8c8f791f30a8e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_species.html">Species</a> object based on its identifier.  <a href="class_model.html#ad4578b30237a83f2e8c8f791f30a8e3b">More...</a><br /></td></tr>
<tr class="separator:ad4578b30237a83f2e8c8f791f30a8e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf646dea01f37c5671478eca44b9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1ebf646dea01f37c5671478eca44b9c9">getSpecies</a> (unsigned int n)</td></tr>
<tr class="memdesc:a1ebf646dea01f37c5671478eca44b9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_species.html">Species</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a1ebf646dea01f37c5671478eca44b9c9">More...</a><br /></td></tr>
<tr class="separator:a1ebf646dea01f37c5671478eca44b9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f5a10054812b4c7eab4ff9266d4c2d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a19f5a10054812b4c7eab4ff9266d4c2d">getSpecies</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a19f5a10054812b4c7eab4ff9266d4c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_species.html">Species</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a19f5a10054812b4c7eab4ff9266d4c2d">More...</a><br /></td></tr>
<tr class="separator:a19f5a10054812b4c7eab4ff9266d4c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e075f403fee78de3bbb3cc92e20d17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_reference.html">SpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac5e075f403fee78de3bbb3cc92e20d17">getSpeciesReference</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:ac5e075f403fee78de3bbb3cc92e20d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_species_reference.html">SpeciesReference</a> object based on its identifier.  <a href="class_model.html#ac5e075f403fee78de3bbb3cc92e20d17">More...</a><br /></td></tr>
<tr class="separator:ac5e075f403fee78de3bbb3cc92e20d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc20ad127946139bdc3be9f0c7e6917"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_species_reference.html">SpeciesReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#acfc20ad127946139bdc3be9f0c7e6917">getSpeciesReference</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:acfc20ad127946139bdc3be9f0c7e6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_species_reference.html">SpeciesReference</a> object based on its identifier.  <a href="class_model.html#acfc20ad127946139bdc3be9f0c7e6917">More...</a><br /></td></tr>
<tr class="separator:acfc20ad127946139bdc3be9f0c7e6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389c658e90e7032b20d1e3d5b8934db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a389c658e90e7032b20d1e3d5b8934db4">getSpeciesType</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a389c658e90e7032b20d1e3d5b8934db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_species_type.html">SpeciesType</a> object based on its identifier.  <a href="class_model.html#a389c658e90e7032b20d1e3d5b8934db4">More...</a><br /></td></tr>
<tr class="separator:a389c658e90e7032b20d1e3d5b8934db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc8870c97cd47b351cc63652e3d0bc7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5dc8870c97cd47b351cc63652e3d0bc7">getSpeciesType</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a5dc8870c97cd47b351cc63652e3d0bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_species_type.html">SpeciesType</a> object based on its identifier.  <a href="class_model.html#a5dc8870c97cd47b351cc63652e3d0bc7">More...</a><br /></td></tr>
<tr class="separator:a5dc8870c97cd47b351cc63652e3d0bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65322b81388c4d5eaddf00a2e72f6ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a65322b81388c4d5eaddf00a2e72f6ded">getSpeciesType</a> (unsigned int n)</td></tr>
<tr class="memdesc:a65322b81388c4d5eaddf00a2e72f6ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_species_type.html">SpeciesType</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a65322b81388c4d5eaddf00a2e72f6ded">More...</a><br /></td></tr>
<tr class="separator:a65322b81388c4d5eaddf00a2e72f6ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c02ea7f3970279eda8d8912ddc4a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a665c02ea7f3970279eda8d8912ddc4a6">getSpeciesType</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a665c02ea7f3970279eda8d8912ddc4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_species_type.html">SpeciesType</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a665c02ea7f3970279eda8d8912ddc4a6">More...</a><br /></td></tr>
<tr class="separator:a665c02ea7f3970279eda8d8912ddc4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57332c13813ff013031f5233d7d9abdd"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a57332c13813ff013031f5233d7d9abdd">getSubstanceUnits</a> () const</td></tr>
<tr class="memdesc:a57332c13813ff013031f5233d7d9abdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a57332c13813ff013031f5233d7d9abdd">More...</a><br /></td></tr>
<tr class="separator:a57332c13813ff013031f5233d7d9abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84b98b545432d1cc5d1f029ecebf7de"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af84b98b545432d1cc5d1f029ecebf7de">getTimeUnits</a> () const</td></tr>
<tr class="memdesc:af84b98b545432d1cc5d1f029ecebf7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#af84b98b545432d1cc5d1f029ecebf7de">More...</a><br /></td></tr>
<tr class="separator:af84b98b545432d1cc5d1f029ecebf7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d3e3ffc648349c8f0472313ded4827"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab3d3e3ffc648349c8f0472313ded4827">getTypeCode</a> () const</td></tr>
<tr class="memdesc:ab3d3e3ffc648349c8f0472313ded4827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the libSBML type code for this SBML object.  <a href="class_model.html#ab3d3e3ffc648349c8f0472313ded4827">More...</a><br /></td></tr>
<tr class="separator:ab3d3e3ffc648349c8f0472313ded4827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2dc2d40ce1b6cb85369518c61e55bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0c2dc2d40ce1b6cb85369518c61e55bb">getUnitDefinition</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a0c2dc2d40ce1b6cb85369518c61e55bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_unit_definition.html">UnitDefinition</a> based on its identifier.  <a href="class_model.html#a0c2dc2d40ce1b6cb85369518c61e55bb">More...</a><br /></td></tr>
<tr class="separator:a0c2dc2d40ce1b6cb85369518c61e55bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520c86d0b8fa54ee12931090d138f52a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a520c86d0b8fa54ee12931090d138f52a">getUnitDefinition</a> (const std::string &amp;sid) const</td></tr>
<tr class="memdesc:a520c86d0b8fa54ee12931090d138f52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="class_unit_definition.html">UnitDefinition</a> based on its identifier.  <a href="class_model.html#a520c86d0b8fa54ee12931090d138f52a">More...</a><br /></td></tr>
<tr class="separator:a520c86d0b8fa54ee12931090d138f52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7b166e618471e10e914a8327b6ccf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a9d7b166e618471e10e914a8327b6ccf4">getUnitDefinition</a> (unsigned int n)</td></tr>
<tr class="memdesc:a9d7b166e618471e10e914a8327b6ccf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a9d7b166e618471e10e914a8327b6ccf4">More...</a><br /></td></tr>
<tr class="separator:a9d7b166e618471e10e914a8327b6ccf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eaad5846c659dd915ae64ea2c2556f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a77eaad5846c659dd915ae64ea2c2556f">getUnitDefinition</a> (unsigned int n) const</td></tr>
<tr class="memdesc:a77eaad5846c659dd915ae64ea2c2556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> object in this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a77eaad5846c659dd915ae64ea2c2556f">More...</a><br /></td></tr>
<tr class="separator:a77eaad5846c659dd915ae64ea2c2556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3e54c62bc34c720d96b421c9798dde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8e3e54c62bc34c720d96b421c9798dde">getURI</a> () const</td></tr>
<tr class="memdesc:a8e3e54c62bc34c720d96b421c9798dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the namespace URI to which this element belongs to.  <a href="class_s_base.html#a8e3e54c62bc34c720d96b421c9798dde">More...</a><br /></td></tr>
<tr class="separator:a8e3e54c62bc34c720d96b421c9798dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da81b22af670c12375835a6f992c5db"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2da81b22af670c12375835a6f992c5db">getUserData</a> () const</td></tr>
<tr class="memdesc:a2da81b22af670c12375835a6f992c5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user data that has been previously set via <a class="el" href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb" title="Sets the user data of this element.">setUserData()</a>.  <a href="class_s_base.html#a2da81b22af670c12375835a6f992c5db">More...</a><br /></td></tr>
<tr class="separator:a2da81b22af670c12375835a6f992c5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8f42e0f220bd85af8d01b51d87aeff"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aed8f42e0f220bd85af8d01b51d87aeff">getVersion</a> () const</td></tr>
<tr class="memdesc:aed8f42e0f220bd85af8d01b51d87aeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Version within the SBML Level of the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing <em>this</em> object.  <a href="class_s_base.html#aed8f42e0f220bd85af8d01b51d87aeff">More...</a><br /></td></tr>
<tr class="separator:aed8f42e0f220bd85af8d01b51d87aeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4519053fbe17e5639df8ee7aab914c2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab4519053fbe17e5639df8ee7aab914c2">getVolumeUnits</a> () const</td></tr>
<tr class="memdesc:ab4519053fbe17e5639df8ee7aab914c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ab4519053fbe17e5639df8ee7aab914c2">More...</a><br /></td></tr>
<tr class="separator:ab4519053fbe17e5639df8ee7aab914c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3428a0985f707e08b3221e338f484866"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3428a0985f707e08b3221e338f484866">hasRequiredElements</a> () const</td></tr>
<tr class="memdesc:a3428a0985f707e08b3221e338f484866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if all the required elements for this <a class="el" href="class_model.html">Model</a> object have been set.  <a href="class_model.html#a3428a0985f707e08b3221e338f484866">More...</a><br /></td></tr>
<tr class="separator:a3428a0985f707e08b3221e338f484866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c78f1941d1d0fc804b6b4a1dd0db54e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4c78f1941d1d0fc804b6b4a1dd0db54e">hasValidLevelVersionNamespaceCombination</a> ()</td></tr>
<tr class="memdesc:a4c78f1941d1d0fc804b6b4a1dd0db54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's level/version and namespace values correspond to a valid SBML specification.  <a href="class_s_base.html#a4c78f1941d1d0fc804b6b4a1dd0db54e">More...</a><br /></td></tr>
<tr class="separator:a4c78f1941d1d0fc804b6b4a1dd0db54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66c6e186d50df79ce90492eeeb060e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad66c6e186d50df79ce90492eeeb060e2">isPackageEnabled</a> (const std::string &amp;pkgName) const</td></tr>
<tr class="memdesc:ad66c6e186d50df79ce90492eeeb060e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object.  <a href="class_s_base.html#ad66c6e186d50df79ce90492eeeb060e2">More...</a><br /></td></tr>
<tr class="separator:ad66c6e186d50df79ce90492eeeb060e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ac3f72984fb7e41ae5dc88f2a0504d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a30ac3f72984fb7e41ae5dc88f2a0504d">isPackageURIEnabled</a> (const std::string &amp;pkgURI) const</td></tr>
<tr class="memdesc:a30ac3f72984fb7e41ae5dc88f2a0504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object.  <a href="class_s_base.html#a30ac3f72984fb7e41ae5dc88f2a0504d">More...</a><br /></td></tr>
<tr class="separator:a30ac3f72984fb7e41ae5dc88f2a0504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df1a731505cbddfcb2c504bd86ba9c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a0df1a731505cbddfcb2c504bd86ba9c0">isPkgEnabled</a> (const std::string &amp;pkgName) const</td></tr>
<tr class="memdesc:a0df1a731505cbddfcb2c504bd86ba9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object.  <a href="class_s_base.html#a0df1a731505cbddfcb2c504bd86ba9c0">More...</a><br /></td></tr>
<tr class="separator:a0df1a731505cbddfcb2c504bd86ba9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9574c886d54be2db67210bbd8fcf18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7a9574c886d54be2db67210bbd8fcf18">isPkgURIEnabled</a> (const std::string &amp;pkgURI) const</td></tr>
<tr class="memdesc:a7a9574c886d54be2db67210bbd8fcf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object.  <a href="class_s_base.html#a7a9574c886d54be2db67210bbd8fcf18">More...</a><br /></td></tr>
<tr class="separator:a7a9574c886d54be2db67210bbd8fcf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7133538f5b6084a755ae7d03bda4a073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7133538f5b6084a755ae7d03bda4a073">isPopulatedAllElementIdList</a> () const</td></tr>
<tr class="memdesc:a7133538f5b6084a755ae7d03bda4a073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if libSBML has a list of the ids of all components of this model.  <a href="class_model.html#a7133538f5b6084a755ae7d03bda4a073">More...</a><br /></td></tr>
<tr class="separator:a7133538f5b6084a755ae7d03bda4a073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f35a0a0725d104b545e8b6ae543d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ab94f35a0a0725d104b545e8b6ae543d6">isPopulatedAllElementMetaIdList</a> () const</td></tr>
<tr class="memdesc:ab94f35a0a0725d104b545e8b6ae543d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if libSBML has a list of the metaids of all components of this model.  <a href="class_model.html#ab94f35a0a0725d104b545e8b6ae543d6">More...</a><br /></td></tr>
<tr class="separator:ab94f35a0a0725d104b545e8b6ae543d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935ca96791e9c46a46eef75000134db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a935ca96791e9c46a46eef75000134db4">isPopulatedListFormulaUnitsData</a> ()</td></tr>
<tr class="memdesc:a935ca96791e9c46a46eef75000134db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if libSBML has derived units for the components of this model.  <a href="class_model.html#a935ca96791e9c46a46eef75000134db4">More...</a><br /></td></tr>
<tr class="separator:a935ca96791e9c46a46eef75000134db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af865a159b3b1c5a16729bce7e4e3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2">isSetAnnotation</a> () const</td></tr>
<tr class="memdesc:a5af865a159b3b1c5a16729bce7e4e3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "annotation" subelement exists and has content.  <a href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2">More...</a><br /></td></tr>
<tr class="separator:a5af865a159b3b1c5a16729bce7e4e3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e54982a56ee89339590175bc9884fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a68e54982a56ee89339590175bc9884fe">isSetAreaUnits</a> () const</td></tr>
<tr class="memdesc:a68e54982a56ee89339590175bc9884fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "areaUnits" attribute is set.  <a href="class_model.html#a68e54982a56ee89339590175bc9884fe">More...</a><br /></td></tr>
<tr class="separator:a68e54982a56ee89339590175bc9884fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f3f327c7fd0ff19a0203e55bbf5601"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a29f3f327c7fd0ff19a0203e55bbf5601">isSetConversionFactor</a> () const</td></tr>
<tr class="memdesc:a29f3f327c7fd0ff19a0203e55bbf5601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "conversionFactor" attribute is set.  <a href="class_model.html#a29f3f327c7fd0ff19a0203e55bbf5601">More...</a><br /></td></tr>
<tr class="separator:a29f3f327c7fd0ff19a0203e55bbf5601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa585552960ae4b7e8d4cec0c301d670e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa585552960ae4b7e8d4cec0c301d670e">isSetCreatedDate</a> () const</td></tr>
<tr class="memdesc:aa585552960ae4b7e8d4cec0c301d670e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object has a <a class="el" href="class_model_history.html">ModelHistory</a> object attached to it and the created date is set.  <a href="class_s_base.html#aa585552960ae4b7e8d4cec0c301d670e">More...</a><br /></td></tr>
<tr class="separator:aa585552960ae4b7e8d4cec0c301d670e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc95334caffb352582e483efc3ef31a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#acc95334caffb352582e483efc3ef31a9">isSetExtentUnits</a> () const</td></tr>
<tr class="memdesc:acc95334caffb352582e483efc3ef31a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "extentUnits" attribute is set.  <a href="class_model.html#acc95334caffb352582e483efc3ef31a9">More...</a><br /></td></tr>
<tr class="separator:acc95334caffb352582e483efc3ef31a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a90c5f7f69760983ed2579b14e68ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce">isSetId</a> () const</td></tr>
<tr class="memdesc:ae9a90c5f7f69760983ed2579b14e68ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "id" attribute is set.  <a href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce">More...</a><br /></td></tr>
<tr class="separator:ae9a90c5f7f69760983ed2579b14e68ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb99b60d2f2f0427e818187cc6f6ad9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9">isSetIdAttribute</a> () const</td></tr>
<tr class="memdesc:a9fb99b60d2f2f0427e818187cc6f6ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "id" attribute is set.  <a href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9">More...</a><br /></td></tr>
<tr class="separator:a9fb99b60d2f2f0427e818187cc6f6ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec3af3f635d27c1eb1c8759993c8cde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0ec3af3f635d27c1eb1c8759993c8cde">isSetLengthUnits</a> () const</td></tr>
<tr class="memdesc:a0ec3af3f635d27c1eb1c8759993c8cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "lengthUnits" attribute is set.  <a href="class_model.html#a0ec3af3f635d27c1eb1c8759993c8cde">More...</a><br /></td></tr>
<tr class="separator:a0ec3af3f635d27c1eb1c8759993c8cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b43de27cb29136954af762fa91d4842"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7b43de27cb29136954af762fa91d4842">isSetMetaId</a> () const</td></tr>
<tr class="memdesc:a7b43de27cb29136954af762fa91d4842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "metaid" attribute is set.  <a href="class_s_base.html#a7b43de27cb29136954af762fa91d4842">More...</a><br /></td></tr>
<tr class="separator:a7b43de27cb29136954af762fa91d4842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8fa8e4911040c0fdf6cdd03a22f564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a0a8fa8e4911040c0fdf6cdd03a22f564">isSetModelHistory</a> () const</td></tr>
<tr class="memdesc:a0a8fa8e4911040c0fdf6cdd03a22f564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object has a <a class="el" href="class_model_history.html">ModelHistory</a> object attached to it.  <a href="class_s_base.html#a0a8fa8e4911040c0fdf6cdd03a22f564">More...</a><br /></td></tr>
<tr class="separator:a0a8fa8e4911040c0fdf6cdd03a22f564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a260cec1705d70d0fea2259b5665b92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7a260cec1705d70d0fea2259b5665b92">isSetModifiedDate</a> () const</td></tr>
<tr class="memdesc:a7a260cec1705d70d0fea2259b5665b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> or <code>false</code> depending on whether the <a class="el" href="class_model_history.html">ModelHistory</a>'s "modified date" of this object is set.  <a href="class_s_base.html#a7a260cec1705d70d0fea2259b5665b92">More...</a><br /></td></tr>
<tr class="separator:a7a260cec1705d70d0fea2259b5665b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c315424f527945e40d9a48a530b786"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa0c315424f527945e40d9a48a530b786">isSetName</a> () const</td></tr>
<tr class="memdesc:aa0c315424f527945e40d9a48a530b786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "name" attribute is set.  <a href="class_model.html#aa0c315424f527945e40d9a48a530b786">More...</a><br /></td></tr>
<tr class="separator:aa0c315424f527945e40d9a48a530b786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83909a09abfab77fea3429482c79e867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867">isSetNotes</a> () const</td></tr>
<tr class="memdesc:a83909a09abfab77fea3429482c79e867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "notes" subelement exists and has content.  <a href="class_s_base.html#a83909a09abfab77fea3429482c79e867">More...</a><br /></td></tr>
<tr class="separator:a83909a09abfab77fea3429482c79e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fed1bd6da28c0cc0ec118209f7327a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5fed1bd6da28c0cc0ec118209f7327a2">isSetSBOTerm</a> () const</td></tr>
<tr class="memdesc:a5fed1bd6da28c0cc0ec118209f7327a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "sboTerm" attribute is set.  <a href="class_s_base.html#a5fed1bd6da28c0cc0ec118209f7327a2">More...</a><br /></td></tr>
<tr class="separator:a5fed1bd6da28c0cc0ec118209f7327a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e33471b61e94798aa9fb466541580c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa3e33471b61e94798aa9fb466541580c">isSetSubstanceUnits</a> () const</td></tr>
<tr class="memdesc:aa3e33471b61e94798aa9fb466541580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "substanceUnits" attribute is set.  <a href="class_model.html#aa3e33471b61e94798aa9fb466541580c">More...</a><br /></td></tr>
<tr class="separator:aa3e33471b61e94798aa9fb466541580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaf85f3098c0a308498fd2e96bb9638"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#adbaf85f3098c0a308498fd2e96bb9638">isSetTimeUnits</a> () const</td></tr>
<tr class="memdesc:adbaf85f3098c0a308498fd2e96bb9638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "timeUnits" attribute is set.  <a href="class_model.html#adbaf85f3098c0a308498fd2e96bb9638">More...</a><br /></td></tr>
<tr class="separator:adbaf85f3098c0a308498fd2e96bb9638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd9e46d49ea191134832353b7b91c6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#abbd9e46d49ea191134832353b7b91c6d">isSetUserData</a> () const</td></tr>
<tr class="memdesc:abbd9e46d49ea191134832353b7b91c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning true or false depending on whether the user data of this element has been set.  <a href="class_s_base.html#abbd9e46d49ea191134832353b7b91c6d">More...</a><br /></td></tr>
<tr class="separator:abbd9e46d49ea191134832353b7b91c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944dc0fe625a4d690de0163d250778fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a944dc0fe625a4d690de0163d250778fc">isSetVolumeUnits</a> () const</td></tr>
<tr class="memdesc:a944dc0fe625a4d690de0163d250778fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "volumeUnits" attribute is set.  <a href="class_model.html#a944dc0fe625a4d690de0163d250778fc">More...</a><br /></td></tr>
<tr class="separator:a944dc0fe625a4d690de0163d250778fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ead78ebf80118b1027af5438f22516"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a94ead78ebf80118b1027af5438f22516">matchesRequiredSBMLNamespacesForAddition</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb)</td></tr>
<tr class="memdesc:a94ead78ebf80118b1027af5438f22516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces.  <a href="class_s_base.html#a94ead78ebf80118b1027af5438f22516">More...</a><br /></td></tr>
<tr class="separator:a94ead78ebf80118b1027af5438f22516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b3447a4eb8ddd9bac16b0fd5bfa6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad17b3447a4eb8ddd9bac16b0fd5bfa6d">matchesRequiredSBMLNamespacesForAddition</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb) const</td></tr>
<tr class="memdesc:ad17b3447a4eb8ddd9bac16b0fd5bfa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces.  <a href="class_s_base.html#ad17b3447a4eb8ddd9bac16b0fd5bfa6d">More...</a><br /></td></tr>
<tr class="separator:ad17b3447a4eb8ddd9bac16b0fd5bfa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f753a9032913c569dafa3642d8252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a936f753a9032913c569dafa3642d8252">matchesSBMLNamespaces</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb)</td></tr>
<tr class="memdesc:a936f753a9032913c569dafa3642d8252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces.  <a href="class_s_base.html#a936f753a9032913c569dafa3642d8252">More...</a><br /></td></tr>
<tr class="separator:a936f753a9032913c569dafa3642d8252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e0febad1c149b4a8455662afd845b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a39e0febad1c149b4a8455662afd845b4">matchesSBMLNamespaces</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb) const</td></tr>
<tr class="memdesc:a39e0febad1c149b4a8455662afd845b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces.  <a href="class_s_base.html#a39e0febad1c149b4a8455662afd845b4">More...</a><br /></td></tr>
<tr class="separator:a39e0febad1c149b4a8455662afd845b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdedf278781f785abeecf5f450e43653"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#afdedf278781f785abeecf5f450e43653">Model</a> (const <a class="el" href="class_model.html">Model</a> &amp;orig)</td></tr>
<tr class="memdesc:afdedf278781f785abeecf5f450e43653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; creates a (deep) copy of the given <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#afdedf278781f785abeecf5f450e43653">More...</a><br /></td></tr>
<tr class="separator:afdedf278781f785abeecf5f450e43653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a50233bd318713e11121c22b7cc7c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a53a50233bd318713e11121c22b7cc7c4">Model</a> (<a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *sbmlns)</td></tr>
<tr class="memdesc:a53a50233bd318713e11121c22b7cc7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_model.html">Model</a> using the given <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object <code>sbmlns</code>.  <a href="class_model.html#a53a50233bd318713e11121c22b7cc7c4">More...</a><br /></td></tr>
<tr class="separator:a53a50233bd318713e11121c22b7cc7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a6972e806a4c7a037bf3e835338801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa4a6972e806a4c7a037bf3e835338801">Model</a> (unsigned int level, unsigned int version)</td></tr>
<tr class="memdesc:aa4a6972e806a4c7a037bf3e835338801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_model.html">Model</a> using the given SBML <code>level</code> and <code>version</code> values.  <a href="class_model.html#aa4a6972e806a4c7a037bf3e835338801">More...</a><br /></td></tr>
<tr class="separator:aa4a6972e806a4c7a037bf3e835338801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cafbc1f38725eba56acc5f159c9aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_model.html">Model</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af5cafbc1f38725eba56acc5f159c9aa2">operator=</a> (const <a class="el" href="class_model.html">Model</a> &amp;rhs)</td></tr>
<tr class="memdesc:af5cafbc1f38725eba56acc5f159c9aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#af5cafbc1f38725eba56acc5f159c9aa2">More...</a><br /></td></tr>
<tr class="separator:af5cafbc1f38725eba56acc5f159c9aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bc6489994799d81c01a0ac01a1bf51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a13bc6489994799d81c01a0ac01a1bf51">populateAllElementIdList</a> ()</td></tr>
<tr class="memdesc:a13bc6489994799d81c01a0ac01a1bf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the internal list of the identifiers of all elements within this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#a13bc6489994799d81c01a0ac01a1bf51">More...</a><br /></td></tr>
<tr class="separator:a13bc6489994799d81c01a0ac01a1bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac79c0d2481a7099f947faa61732fd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#afac79c0d2481a7099f947faa61732fd9">populateAllElementMetaIdList</a> ()</td></tr>
<tr class="memdesc:afac79c0d2481a7099f947faa61732fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the internal list of the metaids of all elements within this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#afac79c0d2481a7099f947faa61732fd9">More...</a><br /></td></tr>
<tr class="separator:afac79c0d2481a7099f947faa61732fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0502de1661e4c15c52852dd4ea7b8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#af0502de1661e4c15c52852dd4ea7b8e7">populateListFormulaUnitsData</a> ()</td></tr>
<tr class="memdesc:af0502de1661e4c15c52852dd4ea7b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the internal list of derived units for this <a class="el" href="class_model.html">Model</a> object.  <a href="class_model.html#af0502de1661e4c15c52852dd4ea7b8e7">More...</a><br /></td></tr>
<tr class="separator:af0502de1661e4c15c52852dd4ea7b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e455a93329e407b4b1d8ad307c95a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8e455a93329e407b4b1d8ad307c95a22">read</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;node, <a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710">XMLErrorSeverityOverride_t</a> flag=<a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710add6235c114a38f4b2b00c4e79761d4c7">LIBSBML_OVERRIDE_DISABLED</a>)</td></tr>
<tr class="memdesc:a8e455a93329e407b4b1d8ad307c95a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads (initializes) this SBML object by reading from the given <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_s_base.html#a8e455a93329e407b4b1d8ad307c95a22">More...</a><br /></td></tr>
<tr class="separator:a8e455a93329e407b4b1d8ad307c95a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b01adc48251eab36392b8fc4fa209c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac4b01adc48251eab36392b8fc4fa209c">removeCompartment</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:ac4b01adc48251eab36392b8fc4fa209c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_compartment.html">Compartment</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#ac4b01adc48251eab36392b8fc4fa209c">More...</a><br /></td></tr>
<tr class="separator:ac4b01adc48251eab36392b8fc4fa209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17495089079cfbf755fb6b8608208fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment.html">Compartment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a17495089079cfbf755fb6b8608208fae">removeCompartment</a> (unsigned int n)</td></tr>
<tr class="memdesc:a17495089079cfbf755fb6b8608208fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_compartment.html">Compartment</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a17495089079cfbf755fb6b8608208fae">More...</a><br /></td></tr>
<tr class="separator:a17495089079cfbf755fb6b8608208fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca63f84ae8db9ebcc4b8e8e29dcab96c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aca63f84ae8db9ebcc4b8e8e29dcab96c">removeCompartmentType</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:aca63f84ae8db9ebcc4b8e8e29dcab96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_compartment_type.html">CompartmentType</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#aca63f84ae8db9ebcc4b8e8e29dcab96c">More...</a><br /></td></tr>
<tr class="separator:aca63f84ae8db9ebcc4b8e8e29dcab96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec7cdadde2db2810a8681c0b907d993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4ec7cdadde2db2810a8681c0b907d993">removeCompartmentType</a> (unsigned int n)</td></tr>
<tr class="memdesc:a4ec7cdadde2db2810a8681c0b907d993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a4ec7cdadde2db2810a8681c0b907d993">More...</a><br /></td></tr>
<tr class="separator:a4ec7cdadde2db2810a8681c0b907d993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024f15a16b74e43f3a2beb43a32b81d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_constraint.html">Constraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a024f15a16b74e43f3a2beb43a32b81d8">removeConstraint</a> (unsigned int n)</td></tr>
<tr class="memdesc:a024f15a16b74e43f3a2beb43a32b81d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_constraint.html">Constraint</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a024f15a16b74e43f3a2beb43a32b81d8">More...</a><br /></td></tr>
<tr class="separator:a024f15a16b74e43f3a2beb43a32b81d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5814610f657b6072506d0c7731b581cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5814610f657b6072506d0c7731b581cb">removeEvent</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a5814610f657b6072506d0c7731b581cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_event.html">Event</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a5814610f657b6072506d0c7731b581cb">More...</a><br /></td></tr>
<tr class="separator:a5814610f657b6072506d0c7731b581cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8e87daa535ffbe44581d6143c255a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_event.html">Event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5cf8e87daa535ffbe44581d6143c255a">removeEvent</a> (unsigned int n)</td></tr>
<tr class="memdesc:a5cf8e87daa535ffbe44581d6143c255a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_event.html">Event</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a5cf8e87daa535ffbe44581d6143c255a">More...</a><br /></td></tr>
<tr class="separator:a5cf8e87daa535ffbe44581d6143c255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d8abe17e84f928af67844352c3b5b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a7d1d8abe17e84f928af67844352c3b5b">removeFromParentAndDelete</a> ()</td></tr>
<tr class="memdesc:a7d1d8abe17e84f928af67844352c3b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this <a class="el" href="class_model.html">Model</a> from its parent <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object.  <a href="class_model.html#a7d1d8abe17e84f928af67844352c3b5b">More...</a><br /></td></tr>
<tr class="separator:a7d1d8abe17e84f928af67844352c3b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1ff2fb9637f83938f963fd5092fe63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a0e1ff2fb9637f83938f963fd5092fe63">removeFunctionDefinition</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a0e1ff2fb9637f83938f963fd5092fe63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a0e1ff2fb9637f83938f963fd5092fe63">More...</a><br /></td></tr>
<tr class="separator:a0e1ff2fb9637f83938f963fd5092fe63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21462b9a21d3a8639d5b4ec2f0a56659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a21462b9a21d3a8639d5b4ec2f0a56659">removeFunctionDefinition</a> (unsigned int n)</td></tr>
<tr class="memdesc:a21462b9a21d3a8639d5b4ec2f0a56659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_function_definition.html">FunctionDefinition</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a21462b9a21d3a8639d5b4ec2f0a56659">More...</a><br /></td></tr>
<tr class="separator:a21462b9a21d3a8639d5b4ec2f0a56659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226096a95d5a7e1b0e4a34cc0b5d262a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a226096a95d5a7e1b0e4a34cc0b5d262a">removeInitialAssignment</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a226096a95d5a7e1b0e4a34cc0b5d262a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object with the given "symbol" attribute from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a226096a95d5a7e1b0e4a34cc0b5d262a">More...</a><br /></td></tr>
<tr class="separator:a226096a95d5a7e1b0e4a34cc0b5d262a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf318fd2ad914c31d942f0210ca228c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aaf318fd2ad914c31d942f0210ca228c1">removeInitialAssignment</a> (unsigned int n)</td></tr>
<tr class="memdesc:aaf318fd2ad914c31d942f0210ca228c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#aaf318fd2ad914c31d942f0210ca228c1">More...</a><br /></td></tr>
<tr class="separator:aaf318fd2ad914c31d942f0210ca228c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed90b4ce5032d879063b332f2a191024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aed90b4ce5032d879063b332f2a191024">removeParameter</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:aed90b4ce5032d879063b332f2a191024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_parameter.html">Parameter</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#aed90b4ce5032d879063b332f2a191024">More...</a><br /></td></tr>
<tr class="separator:aed90b4ce5032d879063b332f2a191024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f79ad6f6b67b170d5500b9a1d1432fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parameter.html">Parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a6f79ad6f6b67b170d5500b9a1d1432fd">removeParameter</a> (unsigned int n)</td></tr>
<tr class="memdesc:a6f79ad6f6b67b170d5500b9a1d1432fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_parameter.html">Parameter</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a6f79ad6f6b67b170d5500b9a1d1432fd">More...</a><br /></td></tr>
<tr class="separator:a6f79ad6f6b67b170d5500b9a1d1432fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894c81f0ce6be976fb2b22e37b91cdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a894c81f0ce6be976fb2b22e37b91cdf5">removeReaction</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a894c81f0ce6be976fb2b22e37b91cdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_reaction.html">Reaction</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a894c81f0ce6be976fb2b22e37b91cdf5">More...</a><br /></td></tr>
<tr class="separator:a894c81f0ce6be976fb2b22e37b91cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ffd7a1d815b15fcc8ed7177e8ed8c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_reaction.html">Reaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a21ffd7a1d815b15fcc8ed7177e8ed8c2">removeReaction</a> (unsigned int n)</td></tr>
<tr class="memdesc:a21ffd7a1d815b15fcc8ed7177e8ed8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_reaction.html">Reaction</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a21ffd7a1d815b15fcc8ed7177e8ed8c2">More...</a><br /></td></tr>
<tr class="separator:a21ffd7a1d815b15fcc8ed7177e8ed8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517c692f894d1930eff2c0127bf012e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a517c692f894d1930eff2c0127bf012e0">removeRule</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:a517c692f894d1930eff2c0127bf012e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_rule.html">Rule</a> object with the given "variable" attribute from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a517c692f894d1930eff2c0127bf012e0">More...</a><br /></td></tr>
<tr class="separator:a517c692f894d1930eff2c0127bf012e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a93206f092becd12ae6af5b8aa6725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac6a93206f092becd12ae6af5b8aa6725">removeRule</a> (unsigned int n)</td></tr>
<tr class="memdesc:ac6a93206f092becd12ae6af5b8aa6725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_rule.html">Rule</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#ac6a93206f092becd12ae6af5b8aa6725">More...</a><br /></td></tr>
<tr class="separator:ac6a93206f092becd12ae6af5b8aa6725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dd6c9882c2caee5b2d9111ebd11fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a52dd6c9882c2caee5b2d9111ebd11fb6">removeRuleByVariable</a> (const std::string &amp;variable)</td></tr>
<tr class="memdesc:a52dd6c9882c2caee5b2d9111ebd11fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_rule.html">Rule</a> object with the given "variable" attribute from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a52dd6c9882c2caee5b2d9111ebd11fb6">More...</a><br /></td></tr>
<tr class="separator:a52dd6c9882c2caee5b2d9111ebd11fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017efd2ed9a2f713ffd02f41a07368b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a017efd2ed9a2f713ffd02f41a07368b9">removeSpecies</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a017efd2ed9a2f713ffd02f41a07368b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_species.html">Species</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a017efd2ed9a2f713ffd02f41a07368b9">More...</a><br /></td></tr>
<tr class="separator:a017efd2ed9a2f713ffd02f41a07368b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49b94737419c17dd302b2e049e8b564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species.html">Species</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ac49b94737419c17dd302b2e049e8b564">removeSpecies</a> (unsigned int n)</td></tr>
<tr class="memdesc:ac49b94737419c17dd302b2e049e8b564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_species.html">Species</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#ac49b94737419c17dd302b2e049e8b564">More...</a><br /></td></tr>
<tr class="separator:ac49b94737419c17dd302b2e049e8b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccf42b641ee15d27f607ab2da39c1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a4ccf42b641ee15d27f607ab2da39c1d6">removeSpeciesType</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a4ccf42b641ee15d27f607ab2da39c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_species_type.html">SpeciesType</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a4ccf42b641ee15d27f607ab2da39c1d6">More...</a><br /></td></tr>
<tr class="separator:a4ccf42b641ee15d27f607ab2da39c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3969f7d363f99f87b94d23e200c64203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a3969f7d363f99f87b94d23e200c64203">removeSpeciesType</a> (unsigned int n)</td></tr>
<tr class="memdesc:a3969f7d363f99f87b94d23e200c64203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_species_type.html">SpeciesType</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a3969f7d363f99f87b94d23e200c64203">More...</a><br /></td></tr>
<tr class="separator:a3969f7d363f99f87b94d23e200c64203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dba8a849dbda05d3f9f42000119dc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a40dba8a849dbda05d3f9f42000119dc5">removeTopLevelAnnotationElement</a> (const std::string &amp;elementName, const std::string elementURI=&quot;&quot;, bool removeEmpty=true)</td></tr>
<tr class="memdesc:a40dba8a849dbda05d3f9f42000119dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-level element within the "annotation" subelement of this SBML object with the given name and optional URI.  <a href="class_s_base.html#a40dba8a849dbda05d3f9f42000119dc5">More...</a><br /></td></tr>
<tr class="separator:a40dba8a849dbda05d3f9f42000119dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9fd5f9e77f064198baaab4ae6f271c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a6e9fd5f9e77f064198baaab4ae6f271c">removeUnitDefinition</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a6e9fd5f9e77f064198baaab4ae6f271c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#a6e9fd5f9e77f064198baaab4ae6f271c">More...</a><br /></td></tr>
<tr class="separator:a6e9fd5f9e77f064198baaab4ae6f271c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b3f619f68171eeb1a90948d4cad653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa4b3f619f68171eeb1a90948d4cad653">removeUnitDefinition</a> (unsigned int n)</td></tr>
<tr class="memdesc:aa4b3f619f68171eeb1a90948d4cad653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.  <a href="class_model.html#aa4b3f619f68171eeb1a90948d4cad653">More...</a><br /></td></tr>
<tr class="separator:aa4b3f619f68171eeb1a90948d4cad653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df4f196b8e11d08013c436c689465a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4df4f196b8e11d08013c436c689465a5">renameMetaIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="separator:a4df4f196b8e11d08013c436c689465a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7a74b199478041720566163c8af8b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a6a7a74b199478041720566163c8af8b5">renameSIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="separator:a6a7a74b199478041720566163c8af8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa729273b3b16be1eb75bff041b149c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aaa729273b3b16be1eb75bff041b149c5">renameUnitSIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="separator:aaa729273b3b16be1eb75bff041b149c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21580da1d75f4782effcc57b45ed37c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8">replaceTopLevelAnnotationElement</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a21580da1d75f4782effcc57b45ed37c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied.  <a href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8">More...</a><br /></td></tr>
<tr class="separator:a21580da1d75f4782effcc57b45ed37c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14876bd1b05a660593ed2cf46aece3ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee">replaceTopLevelAnnotationElement</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *annotation)</td></tr>
<tr class="memdesc:a14876bd1b05a660593ed2cf46aece3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied.  <a href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee">More...</a><br /></td></tr>
<tr class="separator:a14876bd1b05a660593ed2cf46aece3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d849cf4973bd4eef2dc69a16c69a75"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75">setAnnotation</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a99d849cf4973bd4eef2dc69a16c69a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "annotation" subelement of this SBML object to a copy of <code>annotation</code>.  <a href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75">More...</a><br /></td></tr>
<tr class="separator:a99d849cf4973bd4eef2dc69a16c69a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440da667491f2a78fa305460a63471a5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5">setAnnotation</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *annotation)</td></tr>
<tr class="memdesc:a440da667491f2a78fa305460a63471a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "annotation" subelement of this SBML object to a copy of <code>annotation</code>.  <a href="class_model.html#a440da667491f2a78fa305460a63471a5">More...</a><br /></td></tr>
<tr class="separator:a440da667491f2a78fa305460a63471a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5879a7f61af9d05faa6d3bdc0ff249a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a5879a7f61af9d05faa6d3bdc0ff249a0">setAreaUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:a5879a7f61af9d05faa6d3bdc0ff249a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a5879a7f61af9d05faa6d3bdc0ff249a0">More...</a><br /></td></tr>
<tr class="separator:a5879a7f61af9d05faa6d3bdc0ff249a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61985d3d3299d76b51d044a1d767947d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a61985d3d3299d76b51d044a1d767947d">setConversionFactor</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:a61985d3d3299d76b51d044a1d767947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a61985d3d3299d76b51d044a1d767947d">More...</a><br /></td></tr>
<tr class="separator:a61985d3d3299d76b51d044a1d767947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19efde8c152ee942e6d86d591a45ff0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a19efde8c152ee942e6d86d591a45ff0d">setCreatedDate</a> (<a class="el" href="class_date.html">Date</a> *date)</td></tr>
<tr class="memdesc:a19efde8c152ee942e6d86d591a45ff0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the creation date of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object.  <a href="class_s_base.html#a19efde8c152ee942e6d86d591a45ff0d">More...</a><br /></td></tr>
<tr class="separator:a19efde8c152ee942e6d86d591a45ff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43382ec1685bdbb9bf06ed496f4e48b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a43382ec1685bdbb9bf06ed496f4e48b8">setExtentUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:a43382ec1685bdbb9bf06ed496f4e48b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a43382ec1685bdbb9bf06ed496f4e48b8">More...</a><br /></td></tr>
<tr class="separator:a43382ec1685bdbb9bf06ed496f4e48b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5805553e7d385ced27c4065fa190fe"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a9f5805553e7d385ced27c4065fa190fe">setId</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a9f5805553e7d385ced27c4065fa190fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "id" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a9f5805553e7d385ced27c4065fa190fe">More...</a><br /></td></tr>
<tr class="separator:a9f5805553e7d385ced27c4065fa190fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a342a0f8387842fb6700c50c4c43344"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344">setIdAttribute</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a8a342a0f8387842fb6700c50c4c43344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "id" attribute of this SBML object.  <a href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344">More...</a><br /></td></tr>
<tr class="separator:a8a342a0f8387842fb6700c50c4c43344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfe991b74504663e0314298a6281fef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aabfe991b74504663e0314298a6281fef">setLengthUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:aabfe991b74504663e0314298a6281fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aabfe991b74504663e0314298a6281fef">More...</a><br /></td></tr>
<tr class="separator:aabfe991b74504663e0314298a6281fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050779a94ecdb2d73d7edfef73bc1e55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55">setMetaId</a> (const std::string &amp;metaid)</td></tr>
<tr class="memdesc:a050779a94ecdb2d73d7edfef73bc1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the meta-identifier attribute of this SBML object.  <a href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55">More...</a><br /></td></tr>
<tr class="separator:a050779a94ecdb2d73d7edfef73bc1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0ea49f9a3ad67d72edb2c1cf92ad82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aef0ea49f9a3ad67d72edb2c1cf92ad82">setModelHistory</a> (<a class="el" href="class_model_history.html">ModelHistory</a> *history)</td></tr>
<tr class="memdesc:aef0ea49f9a3ad67d72edb2c1cf92ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="class_model_history.html">ModelHistory</a> of this object.  <a href="class_s_base.html#aef0ea49f9a3ad67d72edb2c1cf92ad82">More...</a><br /></td></tr>
<tr class="separator:aef0ea49f9a3ad67d72edb2c1cf92ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f4b34956328dece618208f1f61f8e8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa9f4b34956328dece618208f1f61f8e8">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa9f4b34956328dece618208f1f61f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "name" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aa9f4b34956328dece618208f1f61f8e8">More...</a><br /></td></tr>
<tr class="separator:aa9f4b34956328dece618208f1f61f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dc5a02be520ea43c7cf71c5062c71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7a6dc5a02be520ea43c7cf71c5062c71">setNamespaces</a> (<a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *xmlns)</td></tr>
<tr class="memdesc:a7a6dc5a02be520ea43c7cf71c5062c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the namespaces relevant of this SBML object.  <a href="class_s_base.html#a7a6dc5a02be520ea43c7cf71c5062c71">More...</a><br /></td></tr>
<tr class="separator:a7a6dc5a02be520ea43c7cf71c5062c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478ad1e0e2bb2dc27a9de6ab9bac4bf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2">setNotes</a> (const std::string &amp;notes, bool addXHTMLMarkup=false)</td></tr>
<tr class="memdesc:a478ad1e0e2bb2dc27a9de6ab9bac4bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "notes" subelement of this SBML object to a copy of the string <code>notes</code>.  <a href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2">More...</a><br /></td></tr>
<tr class="separator:a478ad1e0e2bb2dc27a9de6ab9bac4bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a4bd98a4e32e3573980b2481ce77e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e">setNotes</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *notes)</td></tr>
<tr class="memdesc:a611a4bd98a4e32e3573980b2481ce77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "notes" subelement of this SBML object.  <a href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e">More...</a><br /></td></tr>
<tr class="separator:a611a4bd98a4e32e3573980b2481ce77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7b199563437a7977cc13cabb21ef63"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7b7b199563437a7977cc13cabb21ef63">setSBOTerm</a> (const std::string &amp;sboid)</td></tr>
<tr class="memdesc:a7b7b199563437a7977cc13cabb21ef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "sboTerm" attribute by string.  <a href="class_s_base.html#a7b7b199563437a7977cc13cabb21ef63">More...</a><br /></td></tr>
<tr class="separator:a7b7b199563437a7977cc13cabb21ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37287e48bd51353012b74e4d200bb446"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a37287e48bd51353012b74e4d200bb446">setSBOTerm</a> (int value)</td></tr>
<tr class="memdesc:a37287e48bd51353012b74e4d200bb446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "sboTerm" attribute.  <a href="class_s_base.html#a37287e48bd51353012b74e4d200bb446">More...</a><br /></td></tr>
<tr class="separator:a37287e48bd51353012b74e4d200bb446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe440b6a3a9c0495ca5474d954014814"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#afe440b6a3a9c0495ca5474d954014814">setSubstanceUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:afe440b6a3a9c0495ca5474d954014814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#afe440b6a3a9c0495ca5474d954014814">More...</a><br /></td></tr>
<tr class="separator:afe440b6a3a9c0495ca5474d954014814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43130571e9b2674460d0b66bdb57492a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a43130571e9b2674460d0b66bdb57492a">setTimeUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:a43130571e9b2674460d0b66bdb57492a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a43130571e9b2674460d0b66bdb57492a">More...</a><br /></td></tr>
<tr class="separator:a43130571e9b2674460d0b66bdb57492a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b1bbfe22bad0dbc577b61c529f37bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:ac3b1bbfe22bad0dbc577b61c529f37bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the user data of this element.  <a href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb">More...</a><br /></td></tr>
<tr class="separator:ac3b1bbfe22bad0dbc577b61c529f37bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719794fd221fad50d609307424fee4db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a719794fd221fad50d609307424fee4db">setVolumeUnits</a> (const std::string &amp;units)</td></tr>
<tr class="memdesc:a719794fd221fad50d609307424fee4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a719794fd221fad50d609307424fee4db">More...</a><br /></td></tr>
<tr class="separator:a719794fd221fad50d609307424fee4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8317d5157b70e4f1bc68e33e5c84001"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae8317d5157b70e4f1bc68e33e5c84001">toSBML</a> ()</td></tr>
<tr class="memdesc:ae8317d5157b70e4f1bc68e33e5c84001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string consisting of a partial SBML corresponding to just this object.  <a href="class_s_base.html#ae8317d5157b70e4f1bc68e33e5c84001">More...</a><br /></td></tr>
<tr class="separator:ae8317d5157b70e4f1bc68e33e5c84001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c949d524aca47b84b18b57b76e6ee0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5c949d524aca47b84b18b57b76e6ee0a">toXMLNode</a> ()</td></tr>
<tr class="memdesc:a5c949d524aca47b84b18b57b76e6ee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this element as an <a class="el" href="class_x_m_l_node.html">XMLNode</a>.  <a href="class_s_base.html#a5c949d524aca47b84b18b57b76e6ee0a">More...</a><br /></td></tr>
<tr class="separator:a5c949d524aca47b84b18b57b76e6ee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9121d6a4f7401fe957cc75647a1e95ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed">unsetAnnotation</a> ()</td></tr>
<tr class="memdesc:a9121d6a4f7401fe957cc75647a1e95ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "annotation" subelement of this SBML object.  <a href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed">More...</a><br /></td></tr>
<tr class="separator:a9121d6a4f7401fe957cc75647a1e95ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab42860039f74658ed3f79090e253ae8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aab42860039f74658ed3f79090e253ae8">unsetAreaUnits</a> ()</td></tr>
<tr class="memdesc:aab42860039f74658ed3f79090e253ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aab42860039f74658ed3f79090e253ae8">More...</a><br /></td></tr>
<tr class="separator:aab42860039f74658ed3f79090e253ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c0a07389748680d3ab9e5cf14a2496"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a51c0a07389748680d3ab9e5cf14a2496">unsetConversionFactor</a> ()</td></tr>
<tr class="memdesc:a51c0a07389748680d3ab9e5cf14a2496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a51c0a07389748680d3ab9e5cf14a2496">More...</a><br /></td></tr>
<tr class="separator:a51c0a07389748680d3ab9e5cf14a2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3be0bf5891c2b6bf4340cce12b8630f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad3be0bf5891c2b6bf4340cce12b8630f">unsetCreatedDate</a> ()</td></tr>
<tr class="memdesc:ad3be0bf5891c2b6bf4340cce12b8630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the created date of the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object.  <a href="class_s_base.html#ad3be0bf5891c2b6bf4340cce12b8630f">More...</a><br /></td></tr>
<tr class="separator:ad3be0bf5891c2b6bf4340cce12b8630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e89a7890f2fb291f1ba4c38866d1dcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a1e89a7890f2fb291f1ba4c38866d1dcc">unsetCVTerms</a> ()</td></tr>
<tr class="memdesc:a1e89a7890f2fb291f1ba4c38866d1dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects attached to this SBML object.  <a href="class_s_base.html#a1e89a7890f2fb291f1ba4c38866d1dcc">More...</a><br /></td></tr>
<tr class="separator:a1e89a7890f2fb291f1ba4c38866d1dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a19664845edfb52701aeb2dc70cf3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad5a19664845edfb52701aeb2dc70cf3c">unsetExtentUnits</a> ()</td></tr>
<tr class="memdesc:ad5a19664845edfb52701aeb2dc70cf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ad5a19664845edfb52701aeb2dc70cf3c">More...</a><br /></td></tr>
<tr class="separator:ad5a19664845edfb52701aeb2dc70cf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03389e655c02bcd4059098281272ecf3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a03389e655c02bcd4059098281272ecf3">unsetId</a> ()</td></tr>
<tr class="memdesc:a03389e655c02bcd4059098281272ecf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "id" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a03389e655c02bcd4059098281272ecf3">More...</a><br /></td></tr>
<tr class="separator:a03389e655c02bcd4059098281272ecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfd93ef72d0f624964fcfd7a8d5cdfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb">unsetIdAttribute</a> ()</td></tr>
<tr class="memdesc:a1bfd93ef72d0f624964fcfd7a8d5cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "id" attribute of this SBML object.  <a href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb">More...</a><br /></td></tr>
<tr class="separator:a1bfd93ef72d0f624964fcfd7a8d5cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b73768cae68ef60f560cd2a62ea6a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a09b73768cae68ef60f560cd2a62ea6a1">unsetLengthUnits</a> ()</td></tr>
<tr class="memdesc:a09b73768cae68ef60f560cd2a62ea6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a09b73768cae68ef60f560cd2a62ea6a1">More...</a><br /></td></tr>
<tr class="separator:a09b73768cae68ef60f560cd2a62ea6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c955421c92c28351610ea811ecb4fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a98c955421c92c28351610ea811ecb4fe">unsetMetaId</a> ()</td></tr>
<tr class="memdesc:a98c955421c92c28351610ea811ecb4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "metaid" attribute of this SBML object.  <a href="class_s_base.html#a98c955421c92c28351610ea811ecb4fe">More...</a><br /></td></tr>
<tr class="separator:a98c955421c92c28351610ea811ecb4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197c1c8a34df2cbd05a58f6cbc41841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa197c1c8a34df2cbd05a58f6cbc41841">unsetModelHistory</a> ()</td></tr>
<tr class="memdesc:aa197c1c8a34df2cbd05a58f6cbc41841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object.  <a href="class_s_base.html#aa197c1c8a34df2cbd05a58f6cbc41841">More...</a><br /></td></tr>
<tr class="separator:aa197c1c8a34df2cbd05a58f6cbc41841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fe8dd8b43718fbb3d0df8481c72058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a07fe8dd8b43718fbb3d0df8481c72058">unsetModifiedDates</a> ()</td></tr>
<tr class="memdesc:a07fe8dd8b43718fbb3d0df8481c72058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the modified dates of the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object.  <a href="class_s_base.html#a07fe8dd8b43718fbb3d0df8481c72058">More...</a><br /></td></tr>
<tr class="separator:a07fe8dd8b43718fbb3d0df8481c72058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c272e1c5658984d36c2db89a66b0af8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a1c272e1c5658984d36c2db89a66b0af8">unsetName</a> ()</td></tr>
<tr class="memdesc:a1c272e1c5658984d36c2db89a66b0af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "name" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a1c272e1c5658984d36c2db89a66b0af8">More...</a><br /></td></tr>
<tr class="separator:a1c272e1c5658984d36c2db89a66b0af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f626f2593df8e83da4cdbfe79142f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7">unsetNotes</a> ()</td></tr>
<tr class="memdesc:a89f626f2593df8e83da4cdbfe79142f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "notes" subelement of this SBML object.  <a href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7">More...</a><br /></td></tr>
<tr class="separator:a89f626f2593df8e83da4cdbfe79142f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317ea060a5c3f97576188a22e670e683"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a317ea060a5c3f97576188a22e670e683">unsetSBOTerm</a> ()</td></tr>
<tr class="memdesc:a317ea060a5c3f97576188a22e670e683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "sboTerm" attribute of this SBML object.  <a href="class_s_base.html#a317ea060a5c3f97576188a22e670e683">More...</a><br /></td></tr>
<tr class="separator:a317ea060a5c3f97576188a22e670e683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d379051ccef5502024d901974d9b98f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a2d379051ccef5502024d901974d9b98f">unsetSubstanceUnits</a> ()</td></tr>
<tr class="memdesc:a2d379051ccef5502024d901974d9b98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#a2d379051ccef5502024d901974d9b98f">More...</a><br /></td></tr>
<tr class="separator:a2d379051ccef5502024d901974d9b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9936186fb483098b3eb6060158ab93b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aa9936186fb483098b3eb6060158ab93b">unsetTimeUnits</a> ()</td></tr>
<tr class="memdesc:aa9936186fb483098b3eb6060158ab93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aa9936186fb483098b3eb6060158ab93b">More...</a><br /></td></tr>
<tr class="separator:aa9936186fb483098b3eb6060158ab93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd78c4290e103245ce49b92b5e229375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#abd78c4290e103245ce49b92b5e229375">unsetUserData</a> ()</td></tr>
<tr class="memdesc:abd78c4290e103245ce49b92b5e229375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the user data of this element.  <a href="class_s_base.html#abd78c4290e103245ce49b92b5e229375">More...</a><br /></td></tr>
<tr class="separator:abd78c4290e103245ce49b92b5e229375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb2a632640d14bb5d40b3db0212822e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#aadb2a632640d14bb5d40b3db0212822e">unsetVolumeUnits</a> ()</td></tr>
<tr class="memdesc:aadb2a632640d14bb5d40b3db0212822e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#aadb2a632640d14bb5d40b3db0212822e">More...</a><br /></td></tr>
<tr class="separator:aadb2a632640d14bb5d40b3db0212822e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ebd2062a0b823db841a0b88baac4c0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#ad6ebd2062a0b823db841a0b88baac4c0">~Model</a> ()</td></tr>
<tr class="memdesc:ad6ebd2062a0b823db841a0b88baac4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_model.html">Model</a>.  <a href="class_model.html#ad6ebd2062a0b823db841a0b88baac4c0">More...</a><br /></td></tr>
<tr class="separator:ad6ebd2062a0b823db841a0b88baac4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa78ef1ca7e89aa9be18302622aad221f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa78ef1ca7e89aa9be18302622aad221f">setElementText</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:aa78ef1ca7e89aa9be18302622aad221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When overridden allows <a class="el" href="class_s_base.html">SBase</a> elements to use the text included in between the elements tags.  <a href="class_s_base.html#aa78ef1ca7e89aa9be18302622aad221f">More...</a><br /></td></tr>
<tr class="separator:aa78ef1ca7e89aa9be18302622aad221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a878bda56c626c699ffa01db2d09386b1"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_model.html#a878bda56c626c699ffa01db2d09386b1">SBMLDocument</a></td></tr>
<tr class="separator:a878bda56c626c699ffa01db2d09386b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa4a6972e806a4c7a037bf3e835338801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a6972e806a4c7a037bf3e835338801">&#9670;&nbsp;</a></span>Model() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Model </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_model.html">Model</a> using the given SBML <code>level</code> and <code>version</code> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>an unsigned int, the SBML Level to assign to this <a class="el" href="class_model.html">Model</a>.</td></tr>
    <tr><td class="paramname">version</td><td>an unsigned int, the SBML Version to assign to this <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_b_m_l_constructor_exception.html">SBMLConstructorException</a></td><td>Thrown if the given <code>level</code> and <code>version</code> combination are invalid or if this object is incompatible with the given level and version.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a id="a53a50233bd318713e11121c22b7cc7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a50233bd318713e11121c22b7cc7c4">&#9670;&nbsp;</a></span>Model() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_model.html">Model</a> using the given <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object <code>sbmlns</code>. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td>an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_b_m_l_constructor_exception.html">SBMLConstructorException</a></td><td>Thrown if the given <code>sbmlns</code> is inconsistent or incompatible with this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a id="ad6ebd2062a0b823db841a0b88baac4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ebd2062a0b823db841a0b88baac4c0">&#9670;&nbsp;</a></span>~Model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Model::~Model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_model.html">Model</a>. </p>

</div>
</div>
<a id="afdedf278781f785abeecf5f450e43653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdedf278781f785abeecf5f450e43653">&#9670;&nbsp;</a></span>Model() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor; creates a (deep) copy of the given <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a75c4b9d309099c77a2c43b6188a95d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c4b9d309099c77a2c43b6188a95d92">&#9670;&nbsp;</a></span>addCompartment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addCompartment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_compartment.html">Compartment</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_compartment.html">Compartment</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the <a class="el" href="class_compartment.html">Compartment</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#aefe76cdc808d929b588d793e3d550115" title="Creates a new Compartment inside this Model and returns it.">createCompartment()</a> </dd></dl>

</div>
</div>
<a id="a06bf084b6219c2dc2f292751f14b003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bf084b6219c2dc2f292751f14b003e">&#9670;&nbsp;</a></span>addCompartmentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addCompartmentType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_compartment_type.html">CompartmentType</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_compartment_type.html">CompartmentType</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>the <a class="el" href="class_compartment_type.html">CompartmentType</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd>
<dd>
The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#afbd26cd5442b78b6fc4447debd3f413d" title="Creates a new CompartmentType inside this Model and returns it.">createCompartmentType()</a> </dd></dl>

</div>
</div>
<a id="a255f24c2e94521663a2bd00803a5e83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255f24c2e94521663a2bd00803a5e83a">&#9670;&nbsp;</a></span>addConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_constraint.html">Constraint</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_constraint.html">Constraint</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the <a class="el" href="class_constraint.html">Constraint</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a73ab6d88ef3df96b37cfbd3722f8def1" title="Creates a new Constraint inside this Model and returns it.">createConstraint()</a> </dd></dl>

</div>
</div>
<a id="a852e0bd8bfc64342750faf5cbccec65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852e0bd8bfc64342750faf5cbccec65e">&#9670;&nbsp;</a></span>addCVTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::addCVTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_v_term.html">CVTerm</a> *&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_c_v_term.html">CVTerm</a> object to this SBML object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the <a class="el" href="class_c_v_term.html">CVTerm</a> to assign.</td></tr>
    <tr><td class="paramname">newBag</td><td>if <code>true</code>, creates a new RDF bag with the same identifier as a previous bag, and if <code>false</code>, adds the term to an existing RDF bag with the same type of qualifier as the term being added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a>, if this object lacks a "metaid" attribute </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since the CV Term uses the "metaid" attribute of the object as a reference, if the object has no "metaid" attribute value set, then the <a class="el" href="class_c_v_term.html">CVTerm</a> will not be added.</dd>
<dd>
This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_c_v_terms_8cpp-example.html#a15">addCVTerms.cpp</a>, <a class="el" href="adding_evidence_codes_1_8cpp-example.html#a15">addingEvidenceCodes_1.cpp</a>, and <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a15">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa342c92c7b9f2599975422d56a4079f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa342c92c7b9f2599975422d56a4079f3">&#9670;&nbsp;</a></span>addEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_event.html">Event</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the <a class="el" href="class_event.html">Event</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a3be7c6f9f80fa95f9b47b70ac3bedd78" title="Creates a new Event inside this Model and returns it.">createEvent()</a> </dd></dl>

</div>
</div>
<a id="a3d1290871a56070866fcab4a039b16cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1290871a56070866fcab4a039b16cd">&#9670;&nbsp;</a></span>addFunctionDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_function_definition.html">FunctionDefinition</a> *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_function_definition.html">FunctionDefinition</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the <a class="el" href="class_function_definition.html">FunctionDefinition</a> to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a1817656dcda8ea92216522f2a3ea635e" title="Creates a new FunctionDefinition inside this Model and returns it.">createFunctionDefinition()</a> </dd></dl>

</div>
</div>
<a id="a2cb35ac94ab8320fcb1e266f0fd78311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb35ac94ab8320fcb1e266f0fd78311">&#9670;&nbsp;</a></span>addInitialAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> *&#160;</td>
          <td class="paramname"><em>ia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ia</td><td>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a271a78b495901e8ad471381c648812fe" title="Creates a new InitialAssignment inside this Model and returns it.">createInitialAssignment()</a> </dd></dl>

</div>
</div>
<a id="a0b02092069159bda9b7ff14ecacfca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b02092069159bda9b7ff14ecacfca5d">&#9670;&nbsp;</a></span>addModifiedDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::addModifiedDate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_date.html">Date</a> *&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a modified date to the <a class="el" href="class_model_history.html">ModelHistory</a> of this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>a <a class="el" href="class_date.html">Date</a> object representing the date to which the "modified
date" portion of this <a class="el" href="class_model_history.html">ModelHistory</a> should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3e1668494d46d267c23cadff8e72c5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1668494d46d267c23cadff8e72c5d2">&#9670;&nbsp;</a></span>addParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_parameter.html">Parameter</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_parameter.html">Parameter</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the <a class="el" href="class_parameter.html">Parameter</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ac2403f3ace7c21885d977fc20002a77e" title="Creates a new Parameter inside this Model and returns it.">createParameter()</a> </dd></dl>

</div>
</div>
<a id="ae945a58eec61bf2e1bc0269c8bf3b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae945a58eec61bf2e1bc0269c8bf3b830">&#9670;&nbsp;</a></span>addReaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addReaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_reaction.html">Reaction</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_reaction.html">Reaction</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the <a class="el" href="class_reaction.html">Reaction</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="spec_example1_8cpp-example.html#a34">spec_example1.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#a39">spec_example3.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a34">spec_example4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a31de64a99c51803afea41661695864ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31de64a99c51803afea41661695864ff">&#9670;&nbsp;</a></span>addRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_rule.html">Rule</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the <a class="el" href="class_rule.html">Rule</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a8fb00eae391f2edbb097b4efbb6b45fb" title="Creates a new AlgebraicRule inside this Model and returns it.">createAlgebraicRule()</a> </dd>
<dd>
<a class="el" href="class_model.html#aaa1d0023c589dafa52f8af6591974c71" title="Creates a new AssignmentRule inside this Model and returns it.">createAssignmentRule()</a> </dd>
<dd>
<a class="el" href="class_model.html#a5074be8297824ecee69b66f8c37f1695" title="Creates a new RateRule inside this Model and returns it.">createRateRule()</a> </dd></dl>

</div>
</div>
<a id="a2760726af3b7d89f9590e634154d8017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2760726af3b7d89f9590e634154d8017">&#9670;&nbsp;</a></span>addSpecies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addSpecies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_species.html">Species</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_species.html">Species</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the <a class="el" href="class_species.html">Species</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#aaafcd74740d9cad9e2526467f6019d1e" title="Creates a new Species inside this Model and returns it.">createSpecies()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="spec_example1_8cpp-example.html#a23">spec_example1.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#a28">spec_example3.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a23">spec_example4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adde1f7217efd0a9a5f4d00244bb816ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde1f7217efd0a9a5f4d00244bb816ed">&#9670;&nbsp;</a></span>addSpeciesType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addSpeciesType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_species_type.html">SpeciesType</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_species_type.html">SpeciesType</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>the <a class="el" href="class_species_type.html">SpeciesType</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd>
<dd>
The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#af5f61b298f1ed7acf02e3d65cc3989d2" title="Creates a new SpeciesType inside this Model and returns it.">createSpeciesType()</a> </dd></dl>

</div>
</div>
<a id="a6b6a8da867f27288c39d10e559ccb09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6a8da867f27288c39d10e559ccb09f">&#9670;&nbsp;</a></span>addUnitDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::addUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td>
          <td class="paramname"><em>ud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_unit_definition.html">UnitDefinition</a> object to this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ud</td><td>the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dab6101023a227d9dc2e709a7f5ea8752c">LIBSBML_LEVEL_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da6bbd9254393f163c3f05db7e7e05f5dc">LIBSBML_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da43c8862964e599ab96d63db53c454c98">LIBSBML_DUPLICATE_OBJECT_ID</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a3c105a7f5362459eee4e765f7429d5b7" title="Creates a new UnitDefinition inside this Model and returns it.">createUnitDefinition()</a> </dd></dl>

</div>
</div>
<a id="a866fda8a7ba2ba45bf861885fdac4dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866fda8a7ba2ba45bf861885fdac4dc1">&#9670;&nbsp;</a></span>appendAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::appendAnnotation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends annotation content to any existing content in the "annotation" subelement of this object. </p>
<p>The content in <code>annotation</code> is copied. Unlike <a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation()</a>, this method allows other annotations to be preserved when an application adds its own data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML string that is to be copied and appended to the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8">SBase</a>.</p>

</div>
</div>
<a id="ab2762b5bd0f32b5a4a1e9141ca9a5cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2762b5bd0f32b5a4a1e9141ca9a5cbf">&#9670;&nbsp;</a></span>appendAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::appendAnnotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends annotation content to any existing content in the "annotation" subelement of this object. </p>
<p>The content in <code>annotation</code> is copied. Unlike <a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation()</a>, this method allows other annotations to be preserved when an application adds its own data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML structure that is to be copied and appended to the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5">SBase</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="append_annotation_8cpp-example.html#a5">appendAnnotation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adce3de4a1664f4fb174dda177c746860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce3de4a1664f4fb174dda177c746860">&#9670;&nbsp;</a></span>appendFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::appendFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a given <a class="el" href="class_model.html">Model</a> object's subcomponents and appends the copies to the appropriate places in this <a class="el" href="class_model.html">Model</a>. </p>
<p>This method also calls the <code>appendFrom</code> method on all libSBML plug-in objects.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the <a class="el" href="class_model.html">Model</a> to merge with this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33da5a2b0b03cbe6af69730869e35212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33da5a2b0b03cbe6af69730869e35212">&#9670;&nbsp;</a></span>appendNotes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::appendNotes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>notes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>notes</code> to the "notes" subelement of this object. </p>
<p>The content of the parameter <code>notes</code> is copied.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML string that is to appended to the content of the "notes" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a id="adb8c800163c108a27880bd644d7767ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8c800163c108a27880bd644d7767ad">&#9670;&nbsp;</a></span>appendNotes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::appendNotes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>notes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>notes</code> to the "notes" subelement of this object. </p>
<p>The content of <code>notes</code> is copied.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML node structure that is to appended to the content of the "notes" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a id="a288edbb994d52c8de423ef925bac23e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288edbb994d52c8de423ef925bac23e9">&#9670;&nbsp;</a></span>clearAllElementIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::clearAllElementIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the internal list of the identifiers of all elements within this <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a13bc6489994799d81c01a0ac01a1bf51" title="Populates the internal list of the identifiers of all elements within this Model object.">populateAllElementIdList()</a> </dd>
<dd>
<a class="el" href="class_model.html#a7133538f5b6084a755ae7d03bda4a073" title="Predicate returning true if libSBML has a list of the ids of all components of this model.">isPopulatedAllElementIdList()</a> </dd></dl>

</div>
</div>
<a id="a5aac3fbf0838005f8f94453bd3079dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aac3fbf0838005f8f94453bd3079dbb">&#9670;&nbsp;</a></span>clearAllElementMetaIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::clearAllElementMetaIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the internal list of the metaids of all elements within this <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#afac79c0d2481a7099f947faa61732fd9" title="Populates the internal list of the metaids of all elements within this Model object.">populateAllElementMetaIdList()</a> </dd>
<dd>
<a class="el" href="class_model.html#ab94f35a0a0725d104b545e8b6ae543d6" title="Predicate returning true if libSBML has a list of the metaids of all components of this model.">isPopulatedAllElementMetaIdList()</a> </dd></dl>

</div>
</div>
<a id="a8e189fa4c10411e199f3791f977370e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e189fa4c10411e199f3791f977370e6">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_model.html">Model</a> * Model::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a deep copy of this <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the (deep) copy of this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

<p>Implements <a class="el" href="class_s_base.html#abd16e7459f2c84f1821e12bba1c2c7b5">SBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_model_definition.html#a0809e52dd232139e469d549e54a0bce6">ModelDefinition</a>.</p>

</div>
</div>
<a id="a8fb00eae391f2edbb097b4efbb6b45fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb00eae391f2edbb097b4efbb6b45fb">&#9670;&nbsp;</a></span>createAlgebraicRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_algebraic_rule.html">AlgebraicRule</a> * Model::createAlgebraicRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_algebraic_rule.html">AlgebraicRule</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_algebraic_rule.html">AlgebraicRule</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a31de64a99c51803afea41661695864ff" title="Adds a copy of the given Rule object to this Model.">addRule(const Rule* r)</a> </dd></dl>

</div>
</div>
<a id="aaa1d0023c589dafa52f8af6591974c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1d0023c589dafa52f8af6591974c71">&#9670;&nbsp;</a></span>createAssignmentRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assignment_rule.html">AssignmentRule</a> * Model::createAssignmentRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_assignment_rule.html">AssignmentRule</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_assignment_rule.html">AssignmentRule</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a31de64a99c51803afea41661695864ff" title="Adds a copy of the given Rule object to this Model.">addRule(const Rule* r)</a> </dd></dl>

</div>
</div>
<a id="aefe76cdc808d929b588d793e3d550115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe76cdc808d929b588d793e3d550115">&#9670;&nbsp;</a></span>createCompartment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment.html">Compartment</a> * Model::createCompartment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_compartment.html">Compartment</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment.html">Compartment</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a75c4b9d309099c77a2c43b6188a95d92" title="Adds a copy of the given Compartment object to this Model.">addCompartment(const Compartment *c)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a15">createExampleSBML.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#a8">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#a9">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#a16">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#a13">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#a15">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#a17">example3.cpp</a>, <a class="el" href="fbc_example1_8cpp-example.html#a6">fbc_example1.cpp</a>, <a class="el" href="groups_example1_8cpp-example.html#a6">groups_example1.cpp</a>, <a class="el" href="groups_example2_8cpp-example.html#a8">groups_example2.cpp</a>, <a class="el" href="qual_example1_8cpp-example.html#a6">qual_example1.cpp</a>, <a class="el" href="spec_example1_8cpp-example.html#a12">spec_example1.cpp</a>, <a class="el" href="spec_example2_8cpp-example.html#a20">spec_example2.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#a16">spec_example3.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a12">spec_example4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afbd26cd5442b78b6fc4447debd3f413d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd26cd5442b78b6fc4447debd3f413d">&#9670;&nbsp;</a></span>createCompartmentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::createCompartmentType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_compartment_type.html">CompartmentType</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment_type.html">CompartmentType</a> object created.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a06bf084b6219c2dc2f292751f14b003e" title="Adds a copy of the given CompartmentType object to this Model.">addCompartmentType(const CompartmentType* ct)</a> </dd></dl>

</div>
</div>
<a id="a73ab6d88ef3df96b37cfbd3722f8def1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ab6d88ef3df96b37cfbd3722f8def1">&#9670;&nbsp;</a></span>createConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_constraint.html">Constraint</a> * Model::createConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_constraint.html">Constraint</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_constraint.html">Constraint</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a255f24c2e94521663a2bd00803a5e83a" title="Adds a copy of the given Constraint object to this Model.">addConstraint(const Constraint *c)</a> </dd></dl>

</div>
</div>
<a id="a150451e2cf6a696edda9345e000bcd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150451e2cf6a696edda9345e000bcd02">&#9670;&nbsp;</a></span>createDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_delay.html">Delay</a> * Model::createDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_delay.html">Delay</a> inside the last <a class="el" href="class_event.html">Event</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_event.html">Event</a> object in this model was created is not significant. It could have been created in a variety of ways, for example by using <a class="el" href="class_model.html#a3be7c6f9f80fa95f9b47b70ac3bedd78" title="Creates a new Event inside this Model and returns it.">createEvent()</a>. If no <a class="el" href="class_event.html">Event</a> object exists in this <a class="el" href="class_model.html">Model</a> object, a new <a class="el" href="class_event_assignment.html">EventAssignment</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_delay.html">Delay</a> object created. </dd></dl>

</div>
</div>
<a id="a3be7c6f9f80fa95f9b47b70ac3bedd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be7c6f9f80fa95f9b47b70ac3bedd78">&#9670;&nbsp;</a></span>createEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_event.html">Event</a> * Model::createEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_event.html">Event</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_event.html">Event</a> object created. </dd></dl>

</div>
</div>
<a id="a541bdec2121e3de1919a8e81cb9c53d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541bdec2121e3de1919a8e81cb9c53d4">&#9670;&nbsp;</a></span>createEventAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_event_assignment.html">EventAssignment</a> * Model::createEventAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_event_assignment.html">EventAssignment</a> inside the last <a class="el" href="class_event.html">Event</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_event.html">Event</a> object in this model was created is not significant. It could have been created in a variety of ways, for example by using <a class="el" href="class_model.html#a3be7c6f9f80fa95f9b47b70ac3bedd78" title="Creates a new Event inside this Model and returns it.">createEvent()</a>. If no <a class="el" href="class_event.html">Event</a> object exists in this <a class="el" href="class_model.html">Model</a> object, a new <a class="el" href="class_event_assignment.html">EventAssignment</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_event_assignment.html">EventAssignment</a> object created. </dd></dl>

</div>
</div>
<a id="a1817656dcda8ea92216522f2a3ea635e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1817656dcda8ea92216522f2a3ea635e">&#9670;&nbsp;</a></span>createFunctionDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::createFunctionDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_function_definition.html">FunctionDefinition</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a3d1290871a56070866fcab4a039b16cd" title="Adds a copy of the given FunctionDefinition object to this Model.">addFunctionDefinition(const FunctionDefinition* fd)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a61">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a271a78b495901e8ad471381c648812fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271a78b495901e8ad471381c648812fe">&#9670;&nbsp;</a></span>createInitialAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::createInitialAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_initial_assignment.html">InitialAssignment</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a2cb35ac94ab8320fcb1e266f0fd78311" title="Adds a copy of the given InitialAssignment object to this Model.">addInitialAssignment(const InitialAssignment* ia)</a> </dd></dl>

</div>
</div>
<a id="adb467efcf7a46af60bc7aa3d8bf6ae09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb467efcf7a46af60bc7aa3d8bf6ae09">&#9670;&nbsp;</a></span>createKineticLaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kinetic_law.html">KineticLaw</a> * Model::createKineticLaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_kinetic_law.html">KineticLaw</a> inside the last <a class="el" href="class_reaction.html">Reaction</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_reaction.html">Reaction</a> object was created and added to this <a class="el" href="class_model.html">Model</a> is not significant. It could have been created in a variety of ways, for example using <a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a>. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_kinetic_law.html">KineticLaw</a> object created. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, or a <a class="el" href="class_reaction.html">Reaction</a> does exist but already has a <a class="el" href="class_kinetic_law.html">KineticLaw</a>, a new <a class="el" href="class_kinetic_law.html">KineticLaw</a> is <em>not</em> created and <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="ad9f4250c232594911b097206f184496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f4250c232594911b097206f184496e">&#9670;&nbsp;</a></span>createKineticLawLocalParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_local_parameter.html">LocalParameter</a> * Model::createKineticLawLocalParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_local_parameter.html">LocalParameter</a> inside the <a class="el" href="class_kinetic_law.html">KineticLaw</a> object of the last <a class="el" href="class_reaction.html">Reaction</a> created inside this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The last <a class="el" href="class_kinetic_law.html">KineticLaw</a> object in this <a class="el" href="class_model.html">Model</a> could have been created in a variety of ways. For example, it could have been added using <a class="el" href="class_model.html#adb467efcf7a46af60bc7aa3d8bf6ae09" title="Creates a new KineticLaw inside the last Reaction object created in this Model, and returns a pointer...">createKineticLaw()</a>, or it could be the result of using <a class="el" href="class_reaction.html#aed7c7caa8408b0682e9bd6ad93ab5c12" title="Creates a new KineticLaw object, installs it as this Reaction&#39;s &quot;kineticLaw&quot; subelement,...">Reaction::createKineticLaw()</a> on the <a class="el" href="class_reaction.html">Reaction</a> object created by a <a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a>. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, or the last <a class="el" href="class_reaction.html">Reaction</a> does not contain a <a class="el" href="class_kinetic_law.html">KineticLaw</a> object, a new <a class="el" href="class_parameter.html">Parameter</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> object created. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, or a <a class="el" href="class_kinetic_law.html">KineticLaw</a> for the <a class="el" href="class_reaction.html">Reaction</a> does not exist, a new <a class="el" href="class_parameter.html">Parameter</a> is <em>not</em> created and <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a9994fffdc23096fb9f9aea3e8c67af4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9994fffdc23096fb9f9aea3e8c67af4c">&#9670;&nbsp;</a></span>createKineticLawParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parameter.html">Parameter</a> * Model::createKineticLawParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new local <a class="el" href="class_parameter.html">Parameter</a> inside the <a class="el" href="class_kinetic_law.html">KineticLaw</a> object of the last <a class="el" href="class_reaction.html">Reaction</a> created inside this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The last <a class="el" href="class_kinetic_law.html">KineticLaw</a> object in this <a class="el" href="class_model.html">Model</a> could have been created in a variety of ways. For example, it could have been added using <a class="el" href="class_model.html#adb467efcf7a46af60bc7aa3d8bf6ae09" title="Creates a new KineticLaw inside the last Reaction object created in this Model, and returns a pointer...">createKineticLaw()</a>, or it could be the result of using <a class="el" href="class_reaction.html#aed7c7caa8408b0682e9bd6ad93ab5c12" title="Creates a new KineticLaw object, installs it as this Reaction&#39;s &quot;kineticLaw&quot; subelement,...">Reaction::createKineticLaw()</a> on the <a class="el" href="class_reaction.html">Reaction</a> object created by a <a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a>. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, or the last <a class="el" href="class_reaction.html">Reaction</a> does not contain a <a class="el" href="class_kinetic_law.html">KineticLaw</a> object, a new <a class="el" href="class_parameter.html">Parameter</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> object created. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, or a <a class="el" href="class_kinetic_law.html">KineticLaw</a> for the <a class="el" href="class_reaction.html">Reaction</a> does not exist, a new <a class="el" href="class_parameter.html">Parameter</a> is <em>not</em> created and <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="ab4b7055c6c98dcb54915ceab1635a462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b7055c6c98dcb54915ceab1635a462">&#9670;&nbsp;</a></span>createModifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> * Model::createModifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> object for a modifier species inside the last <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_reaction.html">Reaction</a> object was created and added to this <a class="el" href="class_model.html">Model</a> is not significant. It could have been created in a variety of ways, for example using <a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a>. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_reference.html">SpeciesReference</a> object created. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="ac2403f3ace7c21885d977fc20002a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2403f3ace7c21885d977fc20002a77e">&#9670;&nbsp;</a></span>createParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parameter.html">Parameter</a> * Model::createParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_parameter.html">Parameter</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a3e1668494d46d267c23cadff8e72c5d2" title="Adds a copy of the given Parameter object to this Model.">addParameter(const Parameter *p)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a51">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a42b2333903676da5ca76da93c582b614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b2333903676da5ca76da93c582b614">&#9670;&nbsp;</a></span>createProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_reference.html">SpeciesReference</a> * Model::createProduct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_species_reference.html">SpeciesReference</a> object for a product inside the last <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_reaction.html">Reaction</a> object was created and added to this <a class="el" href="class_model.html">Model</a> is not significant. It could have been created in a variety of ways, for example using <a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a>. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_reference.html">SpeciesReference</a> object created. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a5074be8297824ecee69b66f8c37f1695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5074be8297824ecee69b66f8c37f1695">&#9670;&nbsp;</a></span>createRateRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rate_rule.html">RateRule</a> * Model::createRateRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_rate_rule.html">RateRule</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rate_rule.html">RateRule</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a31de64a99c51803afea41661695864ff" title="Adds a copy of the given Rule object to this Model.">addRule(const Rule* r)</a> </dd></dl>

</div>
</div>
<a id="aefd3e76323c37f27e23c8f27b82dd272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd3e76323c37f27e23c8f27b82dd272">&#9670;&nbsp;</a></span>createReactant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_reference.html">SpeciesReference</a> * Model::createReactant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_species_reference.html">SpeciesReference</a> object for a reactant inside the last <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_reaction.html">Reaction</a> object was created and added to this <a class="el" href="class_model.html">Model</a> is not significant. It could have been created in a variety of ways, for example using <a class="el" href="class_model.html#a7f670d91516c1817c1e81b4be710e0c1" title="Creates a new Reaction inside this Model and returns it.">createReaction()</a>. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_reference.html">SpeciesReference</a> object created. If a <a class="el" href="class_reaction.html">Reaction</a> does not exist for this model, a new <a class="el" href="class_species_reference.html">SpeciesReference</a> is <em>not</em> created and <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a7f670d91516c1817c1e81b4be710e0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f670d91516c1817c1e81b4be710e0c1">&#9670;&nbsp;</a></span>createReaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_reaction.html">Reaction</a> * Model::createReaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_reaction.html">Reaction</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_reaction.html">Reaction</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ae945a58eec61bf2e1bc0269c8bf3b830" title="Adds a copy of the given Reaction object to this Model.">addReaction(const Reaction *r)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a27">createExampleSBML.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#a20">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#a17">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#a21">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#a17">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#a38">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#a40">example3.cpp</a>, <a class="el" href="fbc_example1_8cpp-example.html#a18">fbc_example1.cpp</a>, and <a class="el" href="groups_example2_8cpp-example.html#a20">groups_example2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aaafcd74740d9cad9e2526467f6019d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafcd74740d9cad9e2526467f6019d1e">&#9670;&nbsp;</a></span>createSpecies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species.html">Species</a> * Model::createSpecies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_species.html">Species</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species.html">Species</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a2760726af3b7d89f9590e634154d8017" title="Adds a copy of the given Species object to this Model.">addSpecies(const Species *s)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a19">createExampleSBML.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#a12">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#a12">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#a2">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#a2">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#a25">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#a27">example3.cpp</a>, <a class="el" href="fbc_example1_8cpp-example.html#a11">fbc_example1.cpp</a>, <a class="el" href="groups_example1_8cpp-example.html#a10">groups_example1.cpp</a>, <a class="el" href="groups_example2_8cpp-example.html#a12">groups_example2.cpp</a>, and <a class="el" href="spec_example2_8cpp-example.html#a31">spec_example2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af5f61b298f1ed7acf02e3d65cc3989d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f61b298f1ed7acf02e3d65cc3989d2">&#9670;&nbsp;</a></span>createSpeciesType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_type.html">SpeciesType</a> * Model::createSpeciesType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_species_type.html">SpeciesType</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_type.html">SpeciesType</a> object created.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#adde1f7217efd0a9a5f4d00244bb816ed" title="Adds a copy of the given SpeciesType object to this Model.">addSpeciesType(const SpeciesType* st)</a> </dd></dl>

</div>
</div>
<a id="a1a47abb957aad742e36bbcbe32f21eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a47abb957aad742e36bbcbe32f21eda">&#9670;&nbsp;</a></span>createTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_trigger.html">Trigger</a> * Model::createTrigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_trigger.html">Trigger</a> inside the last <a class="el" href="class_event.html">Event</a> object created in this <a class="el" href="class_model.html">Model</a>, and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section user"><dt></dt><dd>The mechanism by which the last <a class="el" href="class_event.html">Event</a> object in this model was created is not significant. It could have been created in a variety of ways, for example by using <a class="el" href="class_model.html#a3be7c6f9f80fa95f9b47b70ac3bedd78" title="Creates a new Event inside this Model and returns it.">createEvent()</a>. If no <a class="el" href="class_event.html">Event</a> object exists in this <a class="el" href="class_model.html">Model</a> object, a new <a class="el" href="class_event_assignment.html">EventAssignment</a> is <em>not</em> created and <code>NULL</code> is returned instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_trigger.html">Trigger</a> object created. </dd></dl>

</div>
</div>
<a id="ab5e2da521e50cee4f66f1a56d1cc3203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e2da521e50cee4f66f1a56d1cc3203">&#9670;&nbsp;</a></span>createUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit.html">Unit</a> * Model::createUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_unit.html">Unit</a> object within the last <a class="el" href="class_unit_definition.html">UnitDefinition</a> object created in this model and returns a pointer to it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<p>The mechanism by which the <a class="el" href="class_unit_definition.html">UnitDefinition</a> was created is not significant. If a <a class="el" href="class_unit_definition.html">UnitDefinition</a> object does not exist in this model, a new <a class="el" href="class_unit.html">Unit</a> is <em>not</em> created and <code>NULL</code> is returned instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_unit.html">Unit</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a6b6a8da867f27288c39d10e559ccb09f" title="Adds a copy of the given UnitDefinition object to this Model.">addUnitDefinition(const UnitDefinition* ud)</a> </dd></dl>

</div>
</div>
<a id="a3c105a7f5362459eee4e765f7429d5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c105a7f5362459eee4e765f7429d5b7">&#9670;&nbsp;</a></span>createUnitDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::createUnitDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_unit_definition.html">UnitDefinition</a> inside this <a class="el" href="class_model.html">Model</a> and returns it. </p>
<p>The SBML Level and Version of the enclosing <a class="el" href="class_model.html">Model</a> object, as well as any SBML package namespaces, are used to initialize this object's corresponding attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a6b6a8da867f27288c39d10e559ccb09f" title="Adds a copy of the given UnitDefinition object to this Model.">addUnitDefinition(const UnitDefinition* ud)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a6">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac39cfac9d726a12e0f05c6e393953888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39cfac9d726a12e0f05c6e393953888">&#9670;&nbsp;</a></span>deleteDisabledPlugins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::deleteDisabledPlugins </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all information stored in disabled plugins. </p>
<p>If the plugin is re-enabled later, it will then not have any previously-stored information.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recursive</td><td>if <code>true</code>, the disabled information will be deleted also from all child elements, otherwise only from this <a class="el" href="class_s_base.html">SBase</a> element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a63bf923bf768a4b2a8a7aee09854f797" title="Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extens...">getNumDisabledPlugins()</a> </dd></dl>

</div>
</div>
<a id="a5fe0e86c2c28a3226ddc42972241bddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe0e86c2c28a3226ddc42972241bddd">&#9670;&nbsp;</a></span>disablePackage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::disablePackage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgPrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the given SBML Level&#160;3 package on this object. </p>
<p>This method disables the specified package on this object and other objects connected by child-parent links in the same <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object.</p>
<p>An example of when this may be useful is during construction of model components when mixing existing and new models. Suppose your application read an SBML document containing a model that used the SBML Hierarchical Model Composition (&ldquo;comp&rdquo;) package, and extracted parts of that model in order to construct a new model in memory. The new, in-memory model will not accept a component drawn from an other <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> with different package namespace declarations. You could reconstruct the same namespaces in the in-memory model first, but as a shortcut, you could also disable the package namespace on the object being added. Here is a code example to help clarify this: </p><div class="fragment"><div class="line"><span class="comment">// We read in an SBML L3V1 model that uses the &#39;comp&#39;</span></div>
<div class="line"><span class="comment">// package namespace.</span></div>
<div class="line">doc = <a class="code" href="_s_b_m_l_reader_8h.html#a638d6486ad221b01e62d2d15d130a04e">readSBML</a>(<span class="stringliteral">&quot;sbml-file-with-comp-elements.xml&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We extract one of the species from the model.</span></div>
<div class="line"><a class="code" href="class_species.html">Species</a>* s1 = doc-&gt;<a class="code" href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2">getModel</a>()-&gt;<a class="code" href="class_model.html#a19f5a10054812b4c7eab4ff9266d4c2d">getSpecies</a>(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We construct a new model.  This model does not use the</span></div>
<div class="line"><span class="comment">// &#39;comp&#39; package.</span></div>
<div class="line"><a class="code" href="class_model.html">Model</a> * newModel = <span class="keyword">new</span> <a class="code" href="class_model.html#aa4a6972e806a4c7a037bf3e835338801">Model</a>(3,1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following will fail with an error, because addSpecies()</span></div>
<div class="line"><span class="comment">// will first check that the parent of the given object has</span></div>
<div class="line"><span class="comment">// namespaces declared, and will discover that s1 does but</span></div>
<div class="line"><span class="comment">// newModel does not.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// newModel-&gt;addSpecies(s1);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// However, if we disable the &#39;comp&#39; package on s1, then</span></div>
<div class="line"><span class="comment">// the call to addSpecies will work.</span></div>
<div class="line"> </div>
<div class="line">s1-&gt;<a class="code" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd">disablePackage</a>(<span class="stringliteral">&quot;http://www.sbml.org/sbml/level3/version1/comp/version1&quot;</span>,</div>
<div class="line">                   <span class="stringliteral">&quot;comp&quot;</span>);</div>
<div class="line">newModel-&gt;<a class="code" href="class_model.html#a2760726af3b7d89f9590e634154d8017">addSpecies</a>(s1);</div>
<div class="ttc" id="a_s_b_m_l_reader_8h_html_a638d6486ad221b01e62d2d15d130a04e"><div class="ttname"><a href="_s_b_m_l_reader_8h.html#a638d6486ad221b01e62d2d15d130a04e">readSBML</a></div><div class="ttdeci">SBMLDocument_t * readSBML(const char *filename)</div><div class="ttdoc">Reads an SBML document from the given file.</div></div>
<div class="ttc" id="aclass_model_html_a19f5a10054812b4c7eab4ff9266d4c2d"><div class="ttname"><a href="class_model.html#a19f5a10054812b4c7eab4ff9266d4c2d">Model::getSpecies</a></div><div class="ttdeci">const Species * getSpecies(unsigned int n) const</div><div class="ttdoc">Get the nth Species object in this Model.</div><div class="ttdef"><b>Definition:</b> Model.cpp:2564</div></div>
<div class="ttc" id="aclass_model_html_a2760726af3b7d89f9590e634154d8017"><div class="ttname"><a href="class_model.html#a2760726af3b7d89f9590e634154d8017">Model::addSpecies</a></div><div class="ttdeci">int addSpecies(const Species *s)</div><div class="ttdoc">Adds a copy of the given Species object to this Model.</div><div class="ttdef"><b>Definition:</b> Model.cpp:1265</div></div>
<div class="ttc" id="aclass_model_html_aa4a6972e806a4c7a037bf3e835338801"><div class="ttname"><a href="class_model.html#aa4a6972e806a4c7a037bf3e835338801">Model::Model</a></div><div class="ttdeci">Model(unsigned int level, unsigned int version)</div><div class="ttdoc">Creates a new Model using the given SBML level and version values.</div><div class="ttdef"><b>Definition:</b> Model.cpp:82</div></div>
<div class="ttc" id="aclass_s_base_html_a5fe0e86c2c28a3226ddc42972241bddd"><div class="ttname"><a href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd">SBase::disablePackage</a></div><div class="ttdeci">int disablePackage(const std::string &amp;pkgURI, const std::string &amp;pkgPrefix)</div><div class="ttdoc">Disables the given SBML Level&amp;#160;3 package on this object.</div><div class="ttdef"><b>Definition:</b> SBase.cpp:3642</div></div>
<div class="ttc" id="aclass_s_base_html_a776e0b06ec3f0dd2bfdafeec6c9d7cc2"><div class="ttname"><a href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2">SBase::getModel</a></div><div class="ttdeci">const Model * getModel() const</div><div class="ttdoc">Returns the Model object for the SBML Document in which the current object is located.</div><div class="ttdef"><b>Definition:</b> SBase.cpp:3117</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
    <tr><td class="paramname">pkgPrefix</td><td>the XML prefix of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da381940e93af9dacbae414c4413beae31">LIBSBML_PKG_UNKNOWN</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da55dc550fc2f744dd411b452afa55a52b">LIBSBML_PKG_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf4b39ff5e6c7e8073b19ab8b4f29fee1">LIBSBML_PKG_CONFLICTED_VERSION</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ae89a4757c093b8f9c491338bcb278921" title="Enables or disables the given SBML Level&#160;3 package on this object.">enablePackage(const std::string&amp; pkgURI, const std::string&amp; pkgPrefix, bool flag)</a> </dd></dl>

</div>
</div>
<a id="ae89a4757c093b8f9c491338bcb278921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89a4757c093b8f9c491338bcb278921">&#9670;&nbsp;</a></span>enablePackage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::enablePackage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables the given SBML Level&#160;3 package on this object. </p>
<p>This method enables the specified package on this object and other objects connected by child-parent links in the same <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. This method is the converse of <a class="el" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd" title="Disables the given SBML Level&#160;3 package on this object.">SBase::disablePackage(const std::string&amp; pkgURI, const std::string&amp; pkgPrefix)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
    <tr><td class="paramname">pkgPrefix</td><td>the XML prefix of the package.</td></tr>
    <tr><td class="paramname">flag</td><td>whether to enable (<code>true</code>) or disable (<code>false</code>) the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da381940e93af9dacbae414c4413beae31">LIBSBML_PKG_UNKNOWN</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da55dc550fc2f744dd411b452afa55a52b">LIBSBML_PKG_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf4b39ff5e6c7e8073b19ab8b4f29fee1">LIBSBML_PKG_CONFLICTED_VERSION</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd" title="Disables the given SBML Level&#160;3 package on this object.">disablePackage(const std::string&amp; pkgURI, const std::string&amp; pkgPrefix)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_layout_8cpp-example.html#a5">addLayout.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a429026066b1ac0576886268101257122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429026066b1ac0576886268101257122">&#9670;&nbsp;</a></span>getAllElementIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IdList Model::getAllElementIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal list of the identifiers of all elements within this <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>an IdList of all the identifiers in the model.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a13bc6489994799d81c01a0ac01a1bf51" title="Populates the internal list of the identifiers of all elements within this Model object.">populateAllElementIdList()</a> </dd>
<dd>
<a class="el" href="class_model.html#a7133538f5b6084a755ae7d03bda4a073" title="Predicate returning true if libSBML has a list of the ids of all components of this model.">isPopulatedAllElementIdList()</a> </dd></dl>

</div>
</div>
<a id="a0e278fef0bac04e05929eb1c02fac194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e278fef0bac04e05929eb1c02fac194">&#9670;&nbsp;</a></span>getAllElementMetaIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IdList Model::getAllElementMetaIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal list of the metaids of all elements within this <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>an IdList of all the metaids in the model.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#afac79c0d2481a7099f947faa61732fd9" title="Populates the internal list of the metaids of all elements within this Model object.">populateAllElementMetaIdList()</a> </dd>
<dd>
<a class="el" href="class_model.html#ab94f35a0a0725d104b545e8b6ae543d6" title="Predicate returning true if libSBML has a list of the metaids of all components of this model.">isPopulatedAllElementMetaIdList()</a> </dd></dl>

</div>
</div>
<a id="af5c36c64d3d15f1e39b603794a8f722e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c36c64d3d15f1e39b603794a8f722e">&#9670;&nbsp;</a></span>getAllElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * Model::getAllElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element_filter.html">ElementFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_list.html">List</a> of all child objects. </p>
<p>This returns all child objects nested to an arbitrary depth. If an optional element filter is provided, only those objects for which the <code>filter's</code> <code>filter()</code> method returns true will be added to the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>a pointer to an <a class="el" href="class_element_filter.html">ElementFilter</a>, which causes the function to return only elements that match a particular set of constraints. If NULL (the default), the function will return all child objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_list.html">List</a> of pointers to all children objects. </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#ab03cdef0daf939ae8f83b9a9ea24ff8a">SBase</a>.</p>

</div>
</div>
<a id="a0143961ca5188d00203c99eef1de854e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0143961ca5188d00203c99eef1de854e">&#9670;&nbsp;</a></span>getAllElementsFromPlugins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getAllElementsFromPlugins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element_filter.html">ElementFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_list.html">List</a> of all child <a class="el" href="class_s_base.html">SBase</a> objects contained in SBML package plug-ins. </p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<p>This method walks down the list of all SBML Level&#160;3 packages used by this object and returns all child objects defined by those packages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>a pointer to an <a class="el" href="class_element_filter.html">ElementFilter</a>, which causes the function to return only elements that match a particular set of constraints. If NULL (the default), the function will return all child objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_list.html">List</a> of pointers to all children objects from plug-ins. </dd></dl>

</div>
</div>
<a id="ac1db4c7f15e643a3cb27fe3b85e22f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1db4c7f15e643a3cb27fe3b85e22f05">&#9670;&nbsp;</a></span>getAncestorOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * SBase::getAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgName</em> = <code>&quot;core&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first ancestor object that has the given SBML type code from the given package. </p>
<p>LibSBML attaches an identifying code to every kind of SBML object. These are known as <em>SBML type codes</em>. The set of possible type codes is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types.">SBMLTypeCode_t</a>. The names of the type codes all begin with the characters <code>SBML_</code>.</p>
<p>This method searches the tree of objects that are parents of this object, and returns the first one that has the given SBML type code from the given <code>pkgName</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the SBML type code of the object sought.</td></tr>
    <tr><td class="paramname">pkgName</td><td>(optional) the short name of an SBML Level&#160;3 package to which the sought-after object must belong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ancestor SBML object of this SBML object that corresponds to the given <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types.">SBMLTypeCode_t</a> value, or <code>NULL</code> if no ancestor exists.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The optional argument <code>pkgName</code> must be used for all type codes from SBML Level&#160;3 packages. Otherwise, the function will search the "core" namespace alone, not find any corresponding elements, and return NULL. </dd></dl>

</div>
</div>
<a id="aa9a0611fba68fb2d56db3565425f65a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a0611fba68fb2d56db3565425f65a0">&#9670;&nbsp;</a></span>getAncestorOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>pkgName</em> = <code>&quot;core&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first ancestor object that has the given SBML type code from the given package. </p>
<p>LibSBML attaches an identifying code to every kind of SBML object. These are known as <em>SBML type codes</em>. The set of possible type codes is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types.">SBMLTypeCode_t</a>. The names of the type codes all begin with the characters <code>SBML_</code>.</p>
<p>This method searches the tree of objects that are parents of this object, and returns the first one that has the given SBML type code from the given <code>pkgName</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the SBML type code of the object sought.</td></tr>
    <tr><td class="paramname">pkgName</td><td>(optional) the short name of an SBML Level&#160;3 package to which the sought-after object must belong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ancestor SBML object of this SBML object that corresponds to the given <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types.">SBMLTypeCode_t</a> value, or <code>NULL</code> if no ancestor exists.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The optional argument <code>pkgName</code> must be used for all type codes from SBML Level&#160;3 packages. Otherwise, the function will search the "core" namespace alone, not find any corresponding elements, and return NULL. </dd></dl>

</div>
</div>
<a id="a4fbf6701023075573bd76fa0bd276291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbf6701023075573bd76fa0bd276291">&#9670;&nbsp;</a></span>getAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in XML form. LibSBML provides an object model and related interfaces for certain specific kinds of annotations, namely model history information and RDF content. See the <a class="el" href="class_model_history.html">ModelHistory</a>, <a class="el" href="class_c_v_term.html">CVTerm</a> and <a class="el" href="class_r_d_f_annotation_parser.html">RDFAnnotationParser</a> classes for more information about the facilities available.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a2f0edc025514ba75d15e6c6b5a831b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0edc025514ba75d15e6c6b5a831b66">&#9670;&nbsp;</a></span>getAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in XML form. LibSBML provides an object model and related interfaces for certain specific kinds of annotations, namely model history information and RDF content. See the <a class="el" href="class_model_history.html">ModelHistory</a>, <a class="el" href="class_c_v_term.html">CVTerm</a> and <a class="el" href="class_r_d_f_annotation_parser.html">RDFAnnotationParser</a> classes for more information about the facilities available.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="adbff50c6c73c044a5c8e29e6b5dcefc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbff50c6c73c044a5c8e29e6b5dcefc6">&#9670;&nbsp;</a></span>getAnnotationString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getAnnotationString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a character string. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in string form. See the method <a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> for a version that returns annotations in XML form.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a character string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object.">unsetAnnotation()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a5">printAnnotation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5bca707ae547873a5dea083038c8ccda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bca707ae547873a5dea083038c8ccda">&#9670;&nbsp;</a></span>getAnnotationString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getAnnotationString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a character string. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in string form. See the method <a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> for a version that returns annotations in XML form.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a character string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a8770129ecd3def97ec2cd19e155f4468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8770129ecd3def97ec2cd19e155f4468">&#9670;&nbsp;</a></span>getAreaUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getAreaUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the areaUnits of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "areaUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="ae9c5939adb92c3f839e07234e1e15f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c5939adb92c3f839e07234e1e15f59">&#9670;&nbsp;</a></span>getAssignmentRule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assignment_rule.html">AssignmentRule</a> * Model::getAssignmentRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a44fd165e2e59c9965fe5c3d2e36cee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fd165e2e59c9965fe5c3d2e36cee4c">&#9670;&nbsp;</a></span>getAssignmentRule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_assignment_rule.html">AssignmentRule</a> * Model::getAssignmentRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a379bb28a4b10a7e8d7f319b76d3b51c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379bb28a4b10a7e8d7f319b76d3b51c2">&#9670;&nbsp;</a></span>getAssignmentRuleByVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assignment_rule.html">AssignmentRule</a> * Model::getAssignmentRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a004c9d2f1c94b3b13133e89691d1469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004c9d2f1c94b3b13133e89691d1469e">&#9670;&nbsp;</a></span>getAssignmentRuleByVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_assignment_rule.html">AssignmentRule</a> * Model::getAssignmentRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a21766ad77868a914ec0780653d0e924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21766ad77868a914ec0780653d0e924f">&#9670;&nbsp;</a></span>getColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column number where this object first appears in the XML representation of the SBML document. </p>
<dl class="section return"><dt>Returns</dt><dd>the column number of this SBML object. If this object was created programmatically and not read from a file, this method will return the value <code>0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The column number for each construct in an SBML model is set upon reading the model. The accuracy of the column number depends on the correctness of the XML representation of the model, and on the particular XML parser library being used. The former limitation relates to the following problem: if the model is actually invalid XML, then the parser may not be able to interpret the data correctly and consequently may not be able to establish the real column number. The latter limitation is simply that different parsers seem to have their own accuracy limitations, and out of all the parsers supported by libSBML, none have been 100% accurate in all situations. (At this time, libSBML supports the use of <a href="http://xmlsoft.org" target="_blank">libxml2</a>, <a href="http://expat.sourceforge.net/" target="_blank">Expat</a> and <a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces</a>.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#aad43f3efb39b3c56ec0db212b6e97cf4" title="Returns the line number where this object first appears in the XML representation of the SBML documen...">getLine()</a> </dd></dl>

</div>
</div>
<a id="ab668a6f8993d505ba52ed30f53871b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab668a6f8993d505ba52ed30f53871b87">&#9670;&nbsp;</a></span>getCompartment() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment.html">Compartment</a> * Model::getCompartment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_compartment.html">Compartment</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment.html">Compartment</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_compartment.html">Compartment</a> exists. </dd></dl>

</div>
</div>
<a id="a320447bb4a9fe53d5bc5fe9de8feb46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320447bb4a9fe53d5bc5fe9de8feb46e">&#9670;&nbsp;</a></span>getCompartment() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_compartment.html">Compartment</a> * Model::getCompartment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_compartment.html">Compartment</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment.html">Compartment</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_compartment.html">Compartment</a> exists. </dd></dl>

</div>
</div>
<a id="a8e6f8f5cbffd5264fa1e0382d9f53a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6f8f5cbffd5264fa1e0382d9f53a9f">&#9670;&nbsp;</a></span>getCompartment() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment.html">Compartment</a> * Model::getCompartment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_compartment.html">Compartment</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_compartment.html">Compartment</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="ab58cb463a116792bf0796788770471c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58cb463a116792bf0796788770471c6">&#9670;&nbsp;</a></span>getCompartment() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_compartment.html">Compartment</a> * Model::getCompartment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_compartment.html">Compartment</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_compartment.html">Compartment</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a37">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a37">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a13">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a30">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a30">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adfb6d8e60398a63c492f6710b7c7a23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb6d8e60398a63c492f6710b7c7a23f">&#9670;&nbsp;</a></span>getCompartmentType() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::getCompartmentType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_compartment_type.html">CompartmentType</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment_type.html">CompartmentType</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_compartment_type.html">CompartmentType</a> exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a9a58d1d1f18e5a5488c085768d4f95dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a58d1d1f18e5a5488c085768d4f95dd">&#9670;&nbsp;</a></span>getCompartmentType() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::getCompartmentType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_compartment_type.html">CompartmentType</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment_type.html">CompartmentType</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_compartment_type.html">CompartmentType</a> exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a32c02944f51e118d97c18201687e9060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c02944f51e118d97c18201687e9060">&#9670;&nbsp;</a></span>getCompartmentType() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::getCompartmentType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="aeed23e54294b82e2fc596828ba62b88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed23e54294b82e2fc596828ba62b88d">&#9670;&nbsp;</a></span>getCompartmentType() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::getCompartmentType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a4c9e03c5376df4b359d65b9411b7c635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9e03c5376df4b359d65b9411b7c635">&#9670;&nbsp;</a></span>getConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_constraint.html">Constraint</a> * Model::getConstraint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_constraint.html">Constraint</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_constraint.html">Constraint</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="ad6790afd29ad0451d0a81087bf4588e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6790afd29ad0451d0a81087bf4588e7">&#9670;&nbsp;</a></span>getConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_constraint.html">Constraint</a> * Model::getConstraint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_constraint.html">Constraint</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_constraint.html">Constraint</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a69">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a69">printNotes.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a56">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a56">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a80a9869a21e3b2c214a1173337af5285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a9869a21e3b2c214a1173337af5285">&#9670;&nbsp;</a></span>getConversionFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getConversionFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the conversionFactor of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "conversionFactor" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a253b8d724dd9cb8d4cdfcf3f5176dfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b8d724dd9cb8d4cdfcf3f5176dfd2">&#9670;&nbsp;</a></span>getCreatedDate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_date.html">Date</a> * SBase::getCreatedDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "creation date" portion of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_date.html">Date</a> object representing the creation date stored in this <a class="el" href="class_model_history.html">ModelHistory</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a2e322246cd669131af4bd325a99ac0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e322246cd669131af4bd325a99ac0fd">&#9670;&nbsp;</a></span>getCreatedDate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_date.html">Date</a> * SBase::getCreatedDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the "creation date" portion of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_date.html">Date</a> object representing the creation date stored in this <a class="el" href="class_model_history.html">ModelHistory</a> object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="ae07ccf83cfe580d386088d88b61e60ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07ccf83cfe580d386088d88b61e60ff">&#9670;&nbsp;</a></span>getCVTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_term.html">CVTerm</a> * SBase::getCVTerm </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth <a class="el" href="class_c_v_term.html">CVTerm</a> in the list of CVTerms of this SBML object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>unsigned int the index of the <a class="el" href="class_c_v_term.html">CVTerm</a> to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_c_v_term.html">CVTerm</a> in the list of CVTerms for this SBML object. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a9b9dcb83f0b3da9466817e3d32f197f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9dcb83f0b3da9466817e3d32f197f0">&#9670;&nbsp;</a></span>getCVTerms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects in the annotations of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of CVTerms for this SBML object. </dd></dl>

</div>
</div>
<a id="a269ee4b549ed8c0fd3f44157500575c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269ee4b549ed8c0fd3f44157500575c7">&#9670;&nbsp;</a></span>getCVTerms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects in the annotations of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of CVTerms for this SBML object. </dd></dl>

</div>
</div>
<a id="a8012eba52b904a1fcfb2a483eef94810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8012eba52b904a1fcfb2a483eef94810">&#9670;&nbsp;</a></span>getDisabledPlugin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getDisabledPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the disabled plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth disabled plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a63bf923bf768a4b2a8a7aee09854f797" title="Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extens...">getNumDisabledPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a id="a02a6692a180f9281c071b77f908dce0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a6692a180f9281c071b77f908dce0e">&#9670;&nbsp;</a></span>getDisabledPlugin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getDisabledPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the disabled plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth disabled plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a63bf923bf768a4b2a8a7aee09854f797" title="Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extens...">getNumDisabledPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a id="afb7059f3863360e329ccade685199805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7059f3863360e329ccade685199805">&#9670;&nbsp;</a></span>getElementByMetaId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * Model::getElementByMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with the given <code>metaid</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>string representing the meta-identifier of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given <code>metaid</code>, or NULL if no such object is found. </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a5fd4be8061a6a0338ebc2b8018ffbd46">SBase</a>.</p>

</div>
</div>
<a id="a33897f0c6bf974b8a2418589360ae916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33897f0c6bf974b8a2418589360ae916">&#9670;&nbsp;</a></span>getElementByMetaId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getElementByMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>string representing the "metaid" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given meta-identifier. </dd></dl>

</div>
</div>
<a id="a68f6bd54475f4df29acf0e71399ce372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f6bd54475f4df29acf0e71399ce372">&#9670;&nbsp;</a></span>getElementBySId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * Model::getElementBySId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element found that has the given <code>id</code>. </p>
<p>This operation searches the model-wide <code>SId</code> identifier type namespace</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>string representing the id of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given <code>id</code>, or <code>NULL</code> if no such object is found. </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#ab9b81fdb8570c061842115f59d12ef99">SBase</a>.</p>

</div>
</div>
<a id="a77068f549f7aa55f56a072cda2960183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77068f549f7aa55f56a072cda2960183">&#9670;&nbsp;</a></span>getElementBySId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getElementBySId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element found that has the given <code>id</code> in the model-wide <code>SId</code> namespace, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>string representing the "id" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given identifier. </dd></dl>

</div>
</div>
<a id="ae5b49b964d1f467861fee03c0fd6f5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b49b964d1f467861fee03c0fd6f5a4">&#9670;&nbsp;</a></span>getElementName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Model::getElementName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML element name of this object, which for <a class="el" href="class_model.html">Model</a>, is always <code>"model"</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of this element, i.e., <code>"model"</code>. </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#af8a3728a37d96789031960e030a81e4c">SBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_model_definition.html#acb1ec16da03ea93dee8431b8d96d1972">ModelDefinition</a>.</p>

</div>
</div>
<a id="aa20fde599ec08a56b823f194634e1b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20fde599ec08a56b823f194634e1b97">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_event.html">Event</a> * Model::getEvent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="class_event.html">Event</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_event.html">Event</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_event.html">Event</a> exists. </dd></dl>

</div>
</div>
<a id="af2ccb4fe2f17ad025455957a7ed684e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ccb4fe2f17ad025455957a7ed684e2">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_event.html">Event</a> * Model::getEvent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="class_event.html">Event</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_event.html">Event</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_event.html">Event</a> exists. </dd></dl>

</div>
</div>
<a id="a7d5bac85150e07a2c23730fcf6a74b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5bac85150e07a2c23730fcf6a74b4b">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_event.html">Event</a> * Model::getEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_event.html">Event</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_event.html">Event</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="ad8b2c2973812e2fef8725af8d577c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b2c2973812e2fef8725af8d577c4ba">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_event.html">Event</a> * Model::getEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_event.html">Event</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_event.html">Event</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a54">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a40">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a54">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a26">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a47">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a47">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac6988e6c3e3a491fa4fb8dd43a95f941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6988e6c3e3a491fa4fb8dd43a95f941">&#9670;&nbsp;</a></span>getExtentUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getExtentUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the extentUnits of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "extentUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a227e44396ad8d31384cca789964086e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e44396ad8d31384cca789964086e8">&#9670;&nbsp;</a></span>getFunctionDefinition() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::getFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_function_definition.html">FunctionDefinition</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_function_definition.html">FunctionDefinition</a> exists. </dd></dl>

</div>
</div>
<a id="ab544d2bfb325cf140f018109242c1a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab544d2bfb325cf140f018109242c1a93">&#9670;&nbsp;</a></span>getFunctionDefinition() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::getFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_function_definition.html">FunctionDefinition</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_function_definition.html">FunctionDefinition</a> exists. </dd></dl>

</div>
</div>
<a id="ab78201bd0c82d46a377cbf3811f19907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78201bd0c82d46a377cbf3811f19907">&#9670;&nbsp;</a></span>getFunctionDefinition() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::getFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth FunctionDefinitions object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_function_definition.html">FunctionDefinition</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="af0f50d8d312f2bed5cee8883328c1147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f50d8d312f2bed5cee8883328c1147">&#9670;&nbsp;</a></span>getFunctionDefinition() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::getFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth FunctionDefinitions object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_function_definition.html">FunctionDefinition</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a40">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a34">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a40">printNotes.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a33">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a33">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af231d01db6a91e25812995f524476b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af231d01db6a91e25812995f524476b75">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; Model::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "id" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Because of the inconsistent behavior of this function with respect to assignments and rules, it is now recommended to use the <a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> function instead.</dd></dl>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>the id of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a129bf432fe076c854d9b6e7f44ed99b8">SBase</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a14">SBMLHttpResolverExample.cpp</a>, <a class="el" href="create_example_s_b_m_l_8cpp-example.html#a72">createExampleSBML.cpp</a>, and <a class="el" href="print_s_b_m_l_8cpp-example.html#a9">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad5ffefa4d9901ca0d55f2343c08bb057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ffefa4d9901ca0d55f2343c08bb057">&#9670;&nbsp;</a></span>getIdAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; SBase::getIdAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "id" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>the id of this SBML object, if set and valid for this level and version of SBML; an empty string otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because of the inconsistent behavior of this function with respect to assignments and rules, callers should use <a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd></dl>

</div>
</div>
<a id="a4548193a746f8380b86c8301b484fba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4548193a746f8380b86c8301b484fba2">&#9670;&nbsp;</a></span>getInitialAssignment() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::getInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> in this <a class="el" href="class_model.html">Model</a> with the given "symbol" attribute value or <code>NULL</code> if no such <a class="el" href="class_initial_assignment.html">InitialAssignment</a> exists. </dd></dl>

</div>
</div>
<a id="a0b0be51d19c074c8d9d353a06f8342c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0be51d19c074c8d9d353a06f8342c7">&#9670;&nbsp;</a></span>getInitialAssignment() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::getInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> in this <a class="el" href="class_model.html">Model</a> with the given "symbol" attribute value or <code>NULL</code> if no such <a class="el" href="class_initial_assignment.html">InitialAssignment</a> exists. </dd></dl>

</div>
</div>
<a id="a30761b86b96d5e0342f35211d15dea4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30761b86b96d5e0342f35211d15dea4f">&#9670;&nbsp;</a></span>getInitialAssignment() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::getInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a4328b3fe39ac2f1b5f3464365029ec5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4328b3fe39ac2f1b5f3464365029ec5c">&#9670;&nbsp;</a></span>getInitialAssignment() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::getInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a51">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a51">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a21">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a44">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a44">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab21b8d2463919bf348f666ace9c3afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21b8d2463919bf348f666ace9c3afc2">&#9670;&nbsp;</a></span>getInitialAssignmentBySymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::getInitialAssignmentBySymbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> in this <a class="el" href="class_model.html">Model</a> with the given "symbol" attribute value or <code>NULL</code> if no such <a class="el" href="class_initial_assignment.html">InitialAssignment</a> exists. </dd></dl>

</div>
</div>
<a id="af15b4c0457c8e1778bdda7ceec653278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15b4c0457c8e1778bdda7ceec653278">&#9670;&nbsp;</a></span>getInitialAssignmentBySymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::getInitialAssignmentBySymbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object based on the symbol to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> in this <a class="el" href="class_model.html">Model</a> with the given "symbol" attribute value or <code>NULL</code> if no such <a class="el" href="class_initial_assignment.html">InitialAssignment</a> exists. </dd></dl>

</div>
</div>
<a id="a1234f39a6631fc0d32539a11ce479270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1234f39a6631fc0d32539a11ce479270">&#9670;&nbsp;</a></span>getLengthUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getLengthUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the lengthUnits of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "lengthUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="af0a70ab6f715e912c6431072c4339f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a70ab6f715e912c6431072c4339f2c">&#9670;&nbsp;</a></span>getLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SBML Level of the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing <em>this</em> object. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the SBML level of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#aed8f42e0f220bd85af8d01b51d87aeff" title="Returns the Version within the SBML Level of the SBMLDocument object containing this object.">getVersion()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb90be26c77f519375553365af009a58" title="Returns a list of the XML Namespaces declared on the SBML document owning this object.">getNamespaces()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ab3428c9a9705777183a0ded66981b504" title="Returns the Version of the SBML Level&#160;3 package to which this element belongs to.">getPackageVersion()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_layout_8cpp-example.html#a4">addLayout.cpp</a>, <a class="el" href="convert_s_b_m_l_8cpp-example.html#a6">convertSBML.cpp</a>, and <a class="el" href="print_s_b_m_l_8cpp-example.html#a4">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aad43f3efb39b3c56ec0db212b6e97cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad43f3efb39b3c56ec0db212b6e97cf4">&#9670;&nbsp;</a></span>getLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line number where this object first appears in the XML representation of the SBML document. </p>
<dl class="section return"><dt>Returns</dt><dd>the line number of this SBML object. If this object was created programmatically and not read from a file, this method will return the value <code>0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The line number for each construct in an SBML model is set upon reading the model. The accuracy of the line number depends on the correctness of the XML representation of the model, and on the particular XML parser library being used. The former limitation relates to the following problem: if the model is actually invalid XML, then the parser may not be able to interpret the data correctly and consequently may not be able to establish the real line number. The latter limitation is simply that different parsers seem to have their own accuracy limitations, and out of all the parsers supported by libSBML, none have been 100% accurate in all situations. (At this time, libSBML supports the use of <a href="http://xmlsoft.org" target="_blank">libxml2</a>, <a href="http://expat.sourceforge.net/" target="_blank">Expat</a> and <a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces</a>.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a21766ad77868a914ec0780653d0e924f" title="Returns the column number where this object first appears in the XML representation of the SBML docum...">getColumn()</a> </dd></dl>

</div>
</div>
<a id="a3e60ce9e3b69b9b10345b324d8f6b665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e60ce9e3b69b9b10345b324d8f6b665">&#9670;&nbsp;</a></span>getListOfCompartments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> * Model::getListOfCompartments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Compartments for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="ae65c390e35d1158dc50e917cbc3917f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65c390e35d1158dc50e917cbc3917f5">&#9670;&nbsp;</a></span>getListOfCompartments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> * Model::getListOfCompartments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_compartments.html">ListOfCompartments</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Compartments for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a833d36397b038c031cbe17bc53b1fcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833d36397b038c031cbe17bc53b1fcc4">&#9670;&nbsp;</a></span>getListOfCompartmentTypes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> * Model::getListOfCompartmentTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of CompartmentTypes for this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a8934750712a9fb627cbe53a7801173bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8934750712a9fb627cbe53a7801173bc">&#9670;&nbsp;</a></span>getListOfCompartmentTypes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> * Model::getListOfCompartmentTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_compartment_types.html">ListOfCompartmentTypes</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of CompartmentTypes for this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="ad104a119c8cc304aef18734509631140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad104a119c8cc304aef18734509631140">&#9670;&nbsp;</a></span>getListOfConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> * Model::getListOfConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Constraints for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a328f0386f6b7bb60aa29cb6e2a24af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328f0386f6b7bb60aa29cb6e2a24af42">&#9670;&nbsp;</a></span>getListOfConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> * Model::getListOfConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_constraints.html">ListOfConstraints</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Constraints for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a5ef5db067d00e836f36993e76a1ce530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef5db067d00e836f36993e76a1ce530">&#9670;&nbsp;</a></span>getListOfEvents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_events.html">ListOfEvents</a> * Model::getListOfEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_events.html">ListOfEvents</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Events for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a20acb87823395e758a2b7a58c8387858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20acb87823395e758a2b7a58c8387858">&#9670;&nbsp;</a></span>getListOfEvents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_events.html">ListOfEvents</a> * Model::getListOfEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_events.html">ListOfEvents</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Events for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a438ce0ff480d4730f1a785ef5a8419cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438ce0ff480d4730f1a785ef5a8419cb">&#9670;&nbsp;</a></span>getListOfFunctionDefinitions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> * Model::getListOfFunctionDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of FunctionDefinitions for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a30d9dffd7ce681885e6c045b2f5319e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d9dffd7ce681885e6c045b2f5319e5">&#9670;&nbsp;</a></span>getListOfFunctionDefinitions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> * Model::getListOfFunctionDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_function_definitions.html">ListOfFunctionDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of FunctionDefinitions for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="ae008968a9a51196fb76f1f814ef17093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae008968a9a51196fb76f1f814ef17093">&#9670;&nbsp;</a></span>getListOfInitialAssignments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> * Model::getListOfInitialAssignments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of <a class="el" href="class_initial_assignment.html">InitialAssignment</a> for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a6c9156ed87db2da282de204226af1efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9156ed87db2da282de204226af1efe">&#9670;&nbsp;</a></span>getListOfInitialAssignments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> * Model::getListOfInitialAssignments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_initial_assignments.html">ListOfInitialAssignments</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of InitialAssignments for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a2be3b7c501e4d73a2194ae5162a9892c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be3b7c501e4d73a2194ae5162a9892c">&#9670;&nbsp;</a></span>getListOfParameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_parameters.html">ListOfParameters</a> * Model::getListOfParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_parameters.html">ListOfParameters</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Parameters for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a9543ad8964d61709318b111ff19a6666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9543ad8964d61709318b111ff19a6666">&#9670;&nbsp;</a></span>getListOfParameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_parameters.html">ListOfParameters</a> * Model::getListOfParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_parameters.html">ListOfParameters</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Parameters for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a989ef0092019f0a85a085eacbdfe93a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989ef0092019f0a85a085eacbdfe93a3">&#9670;&nbsp;</a></span>getListOfReactions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_reactions.html">ListOfReactions</a> * Model::getListOfReactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_reactions.html">ListOfReactions</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Reactions for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="aebb66d52e2ab5407031461dc02accf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb66d52e2ab5407031461dc02accf32">&#9670;&nbsp;</a></span>getListOfReactions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_reactions.html">ListOfReactions</a> * Model::getListOfReactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_reactions.html">ListOfReactions</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Reactions for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a7511667f816c9f0a9ad4437f0767c6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7511667f816c9f0a9ad4437f0767c6b1">&#9670;&nbsp;</a></span>getListOfRules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_rules.html">ListOfRules</a> * Model::getListOfRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_rules.html">ListOfRules</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Rules for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a3ba010894d7b0af538b5a23c0ed1e2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba010894d7b0af538b5a23c0ed1e2ff">&#9670;&nbsp;</a></span>getListOfRules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_rules.html">ListOfRules</a> * Model::getListOfRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_rules.html">ListOfRules</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of Rules for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="aed19ee42ed754eb667185ece1f8c57fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed19ee42ed754eb667185ece1f8c57fd">&#9670;&nbsp;</a></span>getListOfSpecies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_species.html">ListOfSpecies</a> * Model::getListOfSpecies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_species.html">ListOfSpecies</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of <a class="el" href="class_species.html">Species</a> for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="ac67c0c4df2a3fb7254c058f3b9f766e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67c0c4df2a3fb7254c058f3b9f766e5">&#9670;&nbsp;</a></span>getListOfSpecies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_species.html">ListOfSpecies</a> * Model::getListOfSpecies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_species.html">ListOfSpecies</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of <a class="el" href="class_species.html">Species</a> for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a96ffd3b6ebb4ba3a7ac6153365d8e6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ffd3b6ebb4ba3a7ac6153365d8e6ae">&#9670;&nbsp;</a></span>getListOfSpeciesTypes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> * Model::getListOfSpeciesTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of SpeciesTypes for this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a30a700eb1b248e5e777d3367883eb744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a700eb1b248e5e777d3367883eb744">&#9670;&nbsp;</a></span>getListOfSpeciesTypes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> * Model::getListOfSpeciesTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_species_types.html">ListOfSpeciesTypes</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of SpeciesTypes for this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a5ae878c530a55722e8b2ef2d6bdacdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae878c530a55722e8b2ef2d6bdacdb5">&#9670;&nbsp;</a></span>getListOfUnitDefinitions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> * Model::getListOfUnitDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of UnitDefinitions for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a1b5d9baf0bffb9b4d6e6bdfca8d29a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5d9baf0bffb9b4d6e6bdfca8d29a5c">&#9670;&nbsp;</a></span>getListOfUnitDefinitions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> * Model::getListOfUnitDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_list_of_unit_definitions.html">ListOfUnitDefinitions</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of UnitDefinitions for this <a class="el" href="class_model.html">Model</a>. </dd></dl>

</div>
</div>
<a id="a2880c1c6a2df519371637a9234ed68a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2880c1c6a2df519371637a9234ed68a4">&#9670;&nbsp;</a></span>getMetaId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; SBase::getMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "metaid" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the meta-identifier of this SBML object, as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7b43de27cb29136954af762fa91d4842" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set.">isSetMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55" title="Sets the value of the meta-identifier attribute of this SBML object.">setMetaId(const std::string&amp; metaid)</a> </dd></dl>

</div>
</div>
<a id="ada0b37251e4b259cb09a6fca2f9d03bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0b37251e4b259cb09a6fca2f9d03bb">&#9670;&nbsp;</a></span>getMetaId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; SBase::getMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "metaid" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the meta-identifier of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7b43de27cb29136954af762fa91d4842" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set.">isSetMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55" title="Sets the value of the meta-identifier attribute of this SBML object.">setMetaId(const std::string&amp; metaid)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a22">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a776e0b06ec3f0dd2bfdafeec6c9d7cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776e0b06ec3f0dd2bfdafeec6c9d7cc2">&#9670;&nbsp;</a></span>getModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_model.html">Model</a> * SBase::getModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_model.html">Model</a> object for the SBML Document in which the current object is located. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_model.html">Model</a> object for the SBML Document of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5" title="Returns the parent SBML object containing this object.">getParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance.">getSBMLDocument()</a> </dd></dl>

</div>
</div>
<a id="a027dbf22b8bf74bbb0ce5cd4453851c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027dbf22b8bf74bbb0ce5cd4453851c7">&#9670;&nbsp;</a></span>getModelHistory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_model_history.html">ModelHistory</a> * SBase::getModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_model_history.html">ModelHistory</a> object, if any, attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object, or <code>NULL</code> if none exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a60f1d849c7f806d075836b21d322150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f1d849c7f806d075836b21d322150f">&#9670;&nbsp;</a></span>getModelHistory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_model_history.html">ModelHistory</a> * SBase::getModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_model_history.html">ModelHistory</a> object, if any, attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object, or <code>NULL</code> if none exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a69c66e9efaa9f3724a3254802330ede6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c66e9efaa9f3724a3254802330ede6">&#9670;&nbsp;</a></span>getModifiedDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_date.html">Date</a> * SBase::getModifiedDate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_date.html">Date</a> object in the list of "modified date" values stored in the <a class="el" href="class_model_history.html">ModelHistory</a> of this object. </p>
<p>In the MIRIAM format for annotations, there can be multiple modification dates. The libSBML <a class="el" href="class_model_history.html">ModelHistory</a> class supports this by storing a list of "modified date" values.</p>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_date.html">Date</a> in the list of ModifiedDates of this <a class="el" href="class_model_history.html">ModelHistory</a> or <code>NULL</code> if no such object exists. </dd></dl>

</div>
</div>
<a id="a61bb2d63da5f2ecc1734aad0b3e70f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bb2d63da5f2ecc1734aad0b3e70f33">&#9670;&nbsp;</a></span>getModifierSpeciesReference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> * Model::getModifierSpeciesReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> exists. </dd></dl>

</div>
</div>
<a id="a376858bd7e129594dfc5298d34d82f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376858bd7e129594dfc5298d34d82f12">&#9670;&nbsp;</a></span>getModifierSpeciesReference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> * Model::getModifierSpeciesReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_modifier_species_reference.html">ModifierSpeciesReference</a> exists. </dd></dl>

</div>
</div>
<a id="ac2792c4eb1d7509af701f555290c3890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2792c4eb1d7509af701f555290c3890">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Model::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "name" attribute of this <a class="el" href="class_model.html">Model</a> object. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;3 Version&#160;2, the "id" and "name" attributes were moved to <a class="el" href="class_s_base.html">SBase</a> directly, instead of being defined individually for many (but not all) objects. LibSBML has for a long time provided functions defined on <a class="el" href="class_s_base.html">SBase</a> itself to get, set, and unset those attributes, which would fail or otherwise return empty strings if executed on any object for which those attributes were not defined. Now that all <a class="el" href="class_s_base.html">SBase</a> objects define those attributes, those functions now succeed for any object with the appropriate level and version.</dd></dl>
<p>The "name" attribute is optional and is not intended to be used for cross-referencing purposes within a model. Its purpose instead is to provide a human-readable label for the component. The data type of "name" is the type <code>string</code> defined in XML Schema. SBML imposes no restrictions as to the content of "name" attributes beyond those restrictions defined by the <code>string</code> type in XML Schema.</p>
<p>The recommended practice for handling "name" is as follows. If a software tool has the capability for displaying the content of "name" attributes, it should display this content to the user as a component's label instead of the component's "id". If the user interface does not have this capability (e.g., because it cannot display or use special characters in symbol names), or if the "name" attribute is missing on a given component, then the user interface should display the value of the "id" attribute instead. (Script language interpreters are especially likely to display "id" instead of "name".)</p>
<p>As a consequence of the above, authors of systems that automatically generate the values of "id" attributes should be aware some systems may display the "id"'s to the user. Authors therefore may wish to take some care to have their software create "id" values that are: (a) reasonably easy for humans to type and read; and (b) likely to be meaningful, for example by making the "id" attribute be an abbreviated form of the name attribute value.</p>
<p>An additional point worth mentioning is although there are restrictions on the uniqueness of "id" values, there are no restrictions on the uniqueness of "name" values in a model. This allows software applications leeway in assigning component identifiers.</p>
<p>Regardless of the level and version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have names). If the object in question does not posess a "name" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the name to be set, nor will it read or write "name" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this SBML object, or the empty string if not set or unsettable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_model.html#aa0c315424f527945e40d9a48a530b786" title="Predicate returning true if this Model&#39;s &quot;name&quot; attribute is set.">isSetName()</a> </dd>
<dd>
<a class="el" href="class_model.html#aa9f4b34956328dece618208f1f61f8e8" title="Sets the value of the &quot;name&quot; attribute of this Model.">setName(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_model.html#a1c272e1c5658984d36c2db89a66b0af8" title="Unsets the value of the &quot;name&quot; attribute of this Model.">unsetName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a90e4753ab8d4611987557b4d64129529">SBase</a>.</p>

</div>
</div>
<a id="adb90be26c77f519375553365af009a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb90be26c77f519375553365af009a58">&#9670;&nbsp;</a></span>getNamespaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> * SBase::getNamespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the XML Namespaces declared on the SBML document owning this object. </p>
<p>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core.</p>
<dl class="section return"><dt>Returns</dt><dd>the XML Namespaces associated with this SBML object, or <code>NULL</code> in certain very usual circumstances where a namespace is not set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#af0a70ab6f715e912c6431072c4339f2c" title="Returns the SBML Level of the SBMLDocument object containing this object.">getLevel()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aed8f42e0f220bd85af8d01b51d87aeff" title="Returns the Version within the SBML Level of the SBMLDocument object containing this object.">getVersion()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_s_b_m_l_document.html#a360398ae79ec79ba3c3623e1294cf601">SBMLDocument</a>.</p>

</div>
</div>
<a id="ac34eff3877f512b8bf31facff83c4483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34eff3877f512b8bf31facff83c4483">&#9670;&nbsp;</a></span>getNotes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>The "notes" element content returned by this method will be in XML form, but libSBML does not provide an object model specifically for the content of notes. Callers will need to traverse the XML tree structure using the facilities available on <a class="el" href="class_x_m_l_node.html">XMLNode</a> and related objects. For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a tree structure composed of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a id="ab65f2358ae580d6ed278789698f80209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65f2358ae580d6ed278789698f80209">&#9670;&nbsp;</a></span>getNotes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>The "notes" element content returned by this method will be in XML form, but libSBML does not provide an object model specifically for the content of notes. Callers will need to traverse the XML tree structure using the facilities available on <a class="el" href="class_x_m_l_node.html">XMLNode</a> and related objects. For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a tree structure composed of <a class="el" href="class_x_m_l_node.html">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a id="a6eee96ee206a55837c0d7b936f20f14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eee96ee206a55837c0d7b936f20f14d">&#9670;&nbsp;</a></span>getNotesString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getNotesString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a string. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a>, which returns the content as an <a class="el" href="class_x_m_l_node.html">XMLNode</a> tree structure. Depending on an application's needs, one or the other method may be more convenient.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a16">SBMLHttpResolverExample.cpp</a>, and <a class="el" href="print_notes_8cpp-example.html#a5">printNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a07ec2702ebbdf35aef0a0626b0ffd52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ec2702ebbdf35aef0a0626b0ffd52f">&#9670;&nbsp;</a></span>getNotesString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getNotesString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a string. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a>, which returns the content as an <a class="el" href="class_x_m_l_node.html">XMLNode</a> tree structure. Depending on an application's needs, one or the other method may be more convenient.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a id="abb8f60919460dc3856d0432a240cade5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8f60919460dc3856d0432a240cade5">&#9670;&nbsp;</a></span>getNumCompartments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumCompartments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_compartment.html">Compartment</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of Compartments in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a35">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a35">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a16">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a11">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a28">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a28">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7f2935ff1f5539657581fefbbb550e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2935ff1f5539657581fefbbb550e37">&#9670;&nbsp;</a></span>getNumCompartmentTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumCompartmentTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_compartment_type.html">CompartmentType</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of CompartmentTypes in this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_compartment_type.html">CompartmentType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_s_b_m_l_8cpp-example.html#a14">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afbd27979d85c9870289d4c4ad28947b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd27979d85c9870289d4c4ad28947b2">&#9670;&nbsp;</a></span>getNumConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_constraint.html">Constraint</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of Constraints in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a67">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a67">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a21">printSBML.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a54">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a54">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a997486d0a21de5d8d07bd764cd6cb21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997486d0a21de5d8d07bd764cd6cb21c">&#9670;&nbsp;</a></span>getNumCVTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="class_c_v_term.html">CVTerm</a> objects in the annotations of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of CVTerms for this SBML object. </dd></dl>

</div>
</div>
<a id="a63bf923bf768a4b2a8a7aee09854f797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf923bf768a4b2a8a7aee09854f797">&#9670;&nbsp;</a></span>getNumDisabledPlugins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumDisabledPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extensions known. </p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of disabled plug-in objects (extension interfaces) of package extensions known by this instance of libSBML. </dd></dl>

</div>
</div>
<a id="aff053452a7ad32e33022ccb9133da1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff053452a7ad32e33022ccb9133da1d6">&#9670;&nbsp;</a></span>getNumEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_event.html">Event</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of Events in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a52">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a39">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a52">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a23">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a24">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a45">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a45">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a068b9277141fa0df08ea1e07a702bb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068b9277141fa0df08ea1e07a702bb19">&#9670;&nbsp;</a></span>getNumFunctionDefinitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumFunctionDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_function_definition.html">FunctionDefinition</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of FunctionDefinitions in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a38">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a33">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a38">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a12">printSBML.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a31">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a31">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4d7b326343ac5b663ebc84421f5725be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7b326343ac5b663ebc84421f5725be">&#9670;&nbsp;</a></span>getNumInitialAssignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumInitialAssignments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_initial_assignment.html">InitialAssignment</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of InitialAssignments in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a49">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a49">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a19">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a19">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a42">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a42">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a973c76cb7a7370cb221911591a73460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973c76cb7a7370cb221911591a73460a">&#9670;&nbsp;</a></span>getNumModifiedDates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumModifiedDates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_date.html">Date</a> objects in the <a class="el" href="class_model_history.html">ModelHistory</a> of this Iobject's list of "modified dates". </p>
<p>In the MIRIAM format for annotations, there can be multiple modification dates. The libSBML <a class="el" href="class_model_history.html">ModelHistory</a> class supports this by storing a list of "modified date" values.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of ModifiedDates in this <a class="el" href="class_model_history.html">ModelHistory</a>. </dd></dl>

</div>
</div>
<a id="a1d44a21afa6b27162fc7b3c589815f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d44a21afa6b27162fc7b3c589815f96">&#9670;&nbsp;</a></span>getNumParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_parameter.html">Parameter</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of Parameters in this <a class="el" href="class_model.html">Model</a>. Parameters defined in KineticLaws are not included. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a44">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a44">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a18">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a15">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a37">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a37">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7463b70032c344b42454f0291e2e204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7463b70032c344b42454f0291e2e204">&#9670;&nbsp;</a></span>getNumPlugins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions known. </p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of plug-in objects (extension interfaces) of package extensions known by this instance of libSBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed" title="Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.">getPlugin(unsigned int n)</a> </dd></dl>

</div>
</div>
<a id="ac5b39971406b8bcb6a020db6d0b728d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b39971406b8bcb6a020db6d0b728d9">&#9670;&nbsp;</a></span>getNumReactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumReactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_reaction.html">Reaction</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of Reactions in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_1_8cpp-example.html#a6">addingEvidenceCodes_1.cpp</a>, <a class="el" href="print_annotation_8cpp-example.html#a13">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a37">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a13">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a22">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a36">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a8">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a8">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a400e574b923a45bc01a7c83b68d3de13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400e574b923a45bc01a7c83b68d3de13">&#9670;&nbsp;</a></span>getNumRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_rule.html">Rule</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of Rules in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a46">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a35">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a46">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a20">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a52">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a39">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a39">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a035d37d5a6cd0616666919d5222fdf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035d37d5a6cd0616666919d5222fdf37">&#9670;&nbsp;</a></span>getNumSpecies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumSpecies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_species.html">Species</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of <a class="el" href="class_species.html">Species</a> in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_c_v_terms_8cpp-example.html#a6">addCVTerms.cpp</a>, <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a6">addingEvidenceCodes_2.cpp</a>, <a class="el" href="append_annotation_8cpp-example.html#a6">appendAnnotation.cpp</a>, <a class="el" href="print_annotation_8cpp-example.html#a32">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a32">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a17">printSBML.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a6">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a25">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a25">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a20b39ed2833288b9fd2a8e002946bb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b39ed2833288b9fd2a8e002946bb9f">&#9670;&nbsp;</a></span>getNumSpeciesTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumSpeciesTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_species_type.html">SpeciesType</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of SpeciesTypes in this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a64">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a64">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a15">printSBML.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a51">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a51">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7013fa0e459a2196c84be5e5f334dfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7013fa0e459a2196c84be5e5f334dfd0">&#9670;&nbsp;</a></span>getNumSpeciesWithBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumSpeciesWithBoundaryCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_species.html">Species</a> in this <a class="el" href="class_model.html">Model</a> having their "boundaryCondition" attribute value set to <code>true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of <a class="el" href="class_species.html">Species</a> in this <a class="el" href="class_model.html">Model</a> with boundaryCondition set to true. </dd></dl>

</div>
</div>
<a id="ab41fa0586c006f1f2875ac523ecf4512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41fa0586c006f1f2875ac523ecf4512">&#9670;&nbsp;</a></span>getNumUnitDefinitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Model::getNumUnitDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="class_unit_definition.html">UnitDefinition</a> objects in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of UnitDefinitions in this <a class="el" href="class_model.html">Model</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a41">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a41">printNotes.cpp</a>, <a class="el" href="print_s_b_m_l_8cpp-example.html#a13">printSBML.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a34">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a34">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab4de53b00ecec3e135fcb9d36fb1bf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4de53b00ecec3e135fcb9d36fb1bf3b">&#9670;&nbsp;</a></span>getPackageCoreVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getPackageCoreVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SBML Core Version within the SBML Level of the actual object. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the SBML core version of this SBML object. </dd></dl>

</div>
</div>
<a id="a031d1da6a39bae8afd5201677fb32c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031d1da6a39bae8afd5201677fb32c02">&#9670;&nbsp;</a></span>getPackageName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; SBase::getPackageName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the SBML Level&#160;3 package in which this element is defined. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the SBML package in which this element is defined. The string <code>&quot;core&quot;</code> will be returned if this element is defined in SBML Level&#160;3 Core. The string <code>&quot;unknown&quot;</code> will be returned if this element is not defined in any SBML package. </dd></dl>

</div>
</div>
<a id="ab3428c9a9705777183a0ded66981b504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3428c9a9705777183a0ded66981b504">&#9670;&nbsp;</a></span>getPackageVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getPackageVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Version of the SBML Level&#160;3 package to which this element belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>the version of the SBML Level&#160;3 package to which this element belongs. The value <code>0</code> will be returned if this element belongs to the SBML Level&#160;3 Core package.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#af0a70ab6f715e912c6431072c4339f2c" title="Returns the SBML Level of the SBMLDocument object containing this object.">getLevel()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aed8f42e0f220bd85af8d01b51d87aeff" title="Returns the Version within the SBML Level of the SBMLDocument object containing this object.">getVersion()</a> </dd></dl>

</div>
</div>
<a id="a12d7d892a3cb920c360d903141fdc71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d7d892a3cb920c360d903141fdc71b">&#9670;&nbsp;</a></span>getParameter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parameter.html">Parameter</a> * Model::getParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_parameter.html">Parameter</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_parameter.html">Parameter</a> exists. </dd></dl>

</div>
</div>
<a id="a48d227e0b16df21449fb411c946f0943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d227e0b16df21449fb411c946f0943">&#9670;&nbsp;</a></span>getParameter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_parameter.html">Parameter</a> * Model::getParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_parameter.html">Parameter</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_parameter.html">Parameter</a> exists. </dd></dl>

</div>
</div>
<a id="a2b503c1bb2fc52089f5383afefd1ad41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b503c1bb2fc52089f5383afefd1ad41">&#9670;&nbsp;</a></span>getParameter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parameter.html">Parameter</a> * Model::getParameter </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_parameter.html">Parameter</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_parameter.html">Parameter</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a71f4145ed39578a1b70f04e46eff76b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f4145ed39578a1b70f04e46eff76b6">&#9670;&nbsp;</a></span>getParameter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_parameter.html">Parameter</a> * Model::getParameter </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_parameter.html">Parameter</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_parameter.html">Parameter</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a45">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a45">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a17">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a38">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a38">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5912bd9dc06f63029b86dbda467bb3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5912bd9dc06f63029b86dbda467bb3c5">&#9670;&nbsp;</a></span>getParentSBMLObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * SBase::getParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent SBML object containing this object. </p>
<p>This returns the immediately-containing object. This method is convenient when holding an object nested inside other objects in an SBML model.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent SBML object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance.">getSBMLDocument()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2" title="Returns the Model object for the SBML Document in which the current object is located.">getModel()</a> </dd></dl>

</div>
</div>
<a id="a70becec9ecd5ecf42973a8e0d4609487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70becec9ecd5ecf42973a8e0d4609487">&#9670;&nbsp;</a></span>getParentSBMLObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent SBML object containing this object. </p>
<p>This returns the immediately-containing object. This method is convenient when holding an object nested inside other objects in an SBML model.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent SBML object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance.">getSBMLDocument()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2" title="Returns the Model object for the SBML Document in which the current object is located.">getModel()</a> </dd></dl>

</div>
</div>
<a id="aee8d8b8cb1ae5980d228174073fc5abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8d8b8cb1ae5980d228174073fc5abc">&#9670;&nbsp;</a></span>getPlugin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>package</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">package</td><td>the name or URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension with the given package name or URI.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed" title="Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.">getPlugin(unsigned int n)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_layout_8cpp-example.html#a11">addLayout.cpp</a>, <a class="el" href="convert_layout_8cpp-example.html#a17">convertLayout.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#a33">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#a28">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#a34">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#a28">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#a8">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#a10">example3.cpp</a>, <a class="el" href="fbc_example1_8cpp-example.html#a29">fbc_example1.cpp</a>, <a class="el" href="groups_example1_8cpp-example.html#a18">groups_example1.cpp</a>, <a class="el" href="groups_example2_8cpp-example.html#a33">groups_example2.cpp</a>, <a class="el" href="qual_example1_8cpp-example.html#a10">qual_example1.cpp</a>, <a class="el" href="spec_example1_8cpp-example.html#a5">spec_example1.cpp</a>, <a class="el" href="spec_example2_8cpp-example.html#a5">spec_example2.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#a5">spec_example3.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a5">spec_example4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a944bad557986b43d8328d5727d1aa890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944bad557986b43d8328d5727d1aa890">&#9670;&nbsp;</a></span>getPlugin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>package</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">package</td><td>the name or URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension with the given package name or URI.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed" title="Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.">getPlugin(unsigned int n)</a> </dd></dl>

</div>
</div>
<a id="a2bcd32c8ab7537433f7f7851818c60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcd32c8ab7537433f7f7851818c60ed">&#9670;&nbsp;</a></span>getPlugin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad7463b70032c344b42454f0291e2e204" title="Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions kno...">getNumPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a id="ad0a14de158d4139b4c28130eb7d8aa60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a14de158d4139b4c28130eb7d8aa60">&#9670;&nbsp;</a></span>getPlugin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad7463b70032c344b42454f0291e2e204" title="Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions kno...">getNumPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a id="adea0697e71112c6b2e004820960afc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea0697e71112c6b2e004820960afc84">&#9670;&nbsp;</a></span>getPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML namespace prefix of this element. </p>
<p>This reports the XML namespace prefix chosen for this class of object in the current SBML document. This may be an empty string if the component has no explicit prefix (for instance, if it is a core SBML object placed in the default SBML namespace of the document). If it is not empty, then it corresponds to the XML namespace prefix used set the object, whatever that may be in a given SBML document.</p>
<dl class="section return"><dt>Returns</dt><dd>a text string representing the XML namespace prefix. </dd></dl>

</div>
</div>
<a id="a0b150a40b12e8d9b050482dbc021b259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b150a40b12e8d9b050482dbc021b259">&#9670;&nbsp;</a></span>getRateRule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rate_rule.html">RateRule</a> * Model::getRateRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a5c465ee9340dde15368277bbe4b1205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c465ee9340dde15368277bbe4b1205d">&#9670;&nbsp;</a></span>getRateRule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rate_rule.html">RateRule</a> * Model::getRateRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the symbol to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a8e64bcdbf44ab32964cc917f25197ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e64bcdbf44ab32964cc917f25197ef0">&#9670;&nbsp;</a></span>getRateRuleByVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rate_rule.html">RateRule</a> * Model::getRateRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a9694778de9417cdacba08c053933f642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9694778de9417cdacba08c053933f642">&#9670;&nbsp;</a></span>getRateRuleByVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rate_rule.html">RateRule</a> * Model::getRateRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a4dee681a2d7aa0249357e601aaf9ef9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dee681a2d7aa0249357e601aaf9ef9d">&#9670;&nbsp;</a></span>getReaction() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_reaction.html">Reaction</a> * Model::getReaction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_reaction.html">Reaction</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_reaction.html">Reaction</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_reaction.html">Reaction</a> exists. </dd></dl>

</div>
</div>
<a id="a610ab44a41b27c87e544204e534f87c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610ab44a41b27c87e544204e534f87c9">&#9670;&nbsp;</a></span>getReaction() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_reaction.html">Reaction</a> * Model::getReaction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_reaction.html">Reaction</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_reaction.html">Reaction</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_reaction.html">Reaction</a> exists. </dd></dl>

</div>
</div>
<a id="a837839393e18f73ebf49d406e045452a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837839393e18f73ebf49d406e045452a">&#9670;&nbsp;</a></span>getReaction() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_reaction.html">Reaction</a> * Model::getReaction </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_reaction.html">Reaction</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a72f49f128fe8fbaae0854c07b204c932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f49f128fe8fbaae0854c07b204c932">&#9670;&nbsp;</a></span>getReaction() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_reaction.html">Reaction</a> * Model::getReaction </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_reaction.html">Reaction</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_reaction.html">Reaction</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_1_8cpp-example.html#a7">addingEvidenceCodes_1.cpp</a>, <a class="el" href="print_annotation_8cpp-example.html#a15">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a38">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a15">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a38">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a10">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a10">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a31fea5f04d8d0a59aef58fa6fc8236b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fea5f04d8d0a59aef58fa6fc8236b7">&#9670;&nbsp;</a></span>getResourceBiologicalQualifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18">BiolQualifierType_t</a> SBase::getResourceBiologicalQualifier </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>resource</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the MIRIAM <em>biological qualifier</em> associated with the given resource. </p>
<p>In <a href="http://biomodels.net/miriam" target="_blank">MIRIAM</a>, qualifiers are an optional means of indicating the relationship between a model component and its annotations. There are two broad kinds of annotations: <em>model</em> and <em>biological</em>. The latter kind is used to qualify the relationship between a model component and a biological entity which it represents. Examples of relationships include "is" and "has part", but many others are possible. MIRIAM defines <a href="http://www.ebi.ac.uk/miriam/main/qualifiers/" target="_blank">numerous relationship qualifiers</a> to enable different software tools to qualify biological annotations in the same standardized way. In libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model element are represented using lists of <a class="el" href="class_c_v_term.html">CVTerm</a> objects, and the the MIRIAM biological qualifiers are represented using values from the enumeration type <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18" title="Enumeration of possible biological qualifiers used for annotations.">BiolQualifierType_t</a>.</p>
<p>This method searches the controlled-vocabulary annotations (i.e., the list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects) on the present object, then out of those that have biological qualifiers, looks for an annotation to the given <code>resource</code>. If such an annotation is found, it returns the type of biological qualifier associated with that resource as a value from the enumeration type <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18" title="Enumeration of possible biological qualifiers used for annotations.">BiolQualifierType_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>string representing the resource; e.g., <code>"http://www.geneontology.org/#GO:0005892"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the qualifier associated with the resource, or <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18af1cf563d5624cd63df7777702421046b">BQB_UNKNOWN</a> if the resource does not exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The set of MIRIAM biological qualifiers grows over time, although relatively slowly. The values in the enumeration <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18" title="Enumeration of possible biological qualifiers used for annotations.">BiolQualifierType_t</a> are up to date with MIRIAM at the time of a given libSBML release. The set of values may be expanded in later libSBML releases, to match the values defined by MIRIAM at that later time. </dd></dl>

</div>
</div>
<a id="ac92975919a08b70b0ded5f1364f5ec44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92975919a08b70b0ded5f1364f5ec44">&#9670;&nbsp;</a></span>getResourceModelQualifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d">ModelQualifierType_t</a> SBase::getResourceModelQualifier </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>resource</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the MIRIAM <em>model qualifier</em> associated with the given resource. </p>
<p>In <a href="http://biomodels.net/miriam" target="_blank">MIRIAM</a>, qualifiers are an optional means of indicating the relationship between a model component and its annotations. There are two broad kinds of annotations: <em>model</em> and <em>biological</em>. The former kind is used to qualify the relationship between a model component and another modeling object. An example qualifier is "isDerivedFrom", to indicate that a given component of the model is derived from the modeling object represented by the referenced resource. MIRIAM defines <a href="http://www.ebi.ac.uk/miriam/main/qualifiers/" target="_blank">numerous relationship qualifiers</a> to enable different software tools to qualify model annotations in the same standardized way. In libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model element are represented using lists of <a class="el" href="class_c_v_term.html">CVTerm</a> objects, and the the MIRIAM model qualifiers are represented using values from the enumeration type <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations.">ModelQualifierType_t</a>.</p>
<p>This method method searches the controlled-vocabulary annotations (i.e., the list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects) on the present object, then out of those that have model qualifiers, looks for an annotation to the given <code>resource</code>. If such an annotation is found, it returns the type of type of model qualifier associated with that resource as a value from the enumeration type <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations.">ModelQualifierType_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>string representing the resource; e.g., <code>"http://www.geneontology.org/#GO:0005892"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations.">ModelQualifierType_t</a> value associated with the resource, or <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9da8b1e2ab645e23a7f1c5dfde0b85e1b25">BQM_UNKNOWN</a> if the resource does not exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The set of MIRIAM biological qualifiers grows over time, although relatively slowly. The values in the enumeration <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations.">ModelQualifierType_t</a> are up to date with MIRIAM at the time of a given libSBML release. The set of values may be expanded in later libSBML releases, to match the values defined by MIRIAM at that later time. </dd></dl>

</div>
</div>
<a id="aa7bf6c88423e97ff58612d04ae102ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bf6c88423e97ff58612d04ae102ea8">&#9670;&nbsp;</a></span>getRule() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule.html">Rule</a> * Model::getRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a916c1ed0deae85ddfa73422678f2ab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916c1ed0deae85ddfa73422678f2ab7d">&#9670;&nbsp;</a></span>getRule() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rule.html">Rule</a> * Model::getRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a0bd77b68c151fa2496e9771923c622f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd77b68c151fa2496e9771923c622f0">&#9670;&nbsp;</a></span>getRule() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule.html">Rule</a> * Model::getRule </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_rule.html">Rule</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_rule.html">Rule</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a074d97b73106ee54cbce751e0c30f4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d97b73106ee54cbce751e0c30f4f1">&#9670;&nbsp;</a></span>getRule() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rule.html">Rule</a> * Model::getRule </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_rule.html">Rule</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_rule.html">Rule</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a48">printAnnotation.cpp</a>, <a class="el" href="print_math_8cpp-example.html#a36">printMath.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a48">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a54">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a41">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a41">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adb367a8928edfe6f17126bf3d1a00e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb367a8928edfe6f17126bf3d1a00e4a">&#9670;&nbsp;</a></span>getRuleByVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule.html">Rule</a> * Model::getRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="aaeedb8e17d84adb2abb0413e9d433ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeedb8e17d84adb2abb0413e9d433ac1">&#9670;&nbsp;</a></span>getRuleByVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rule.html">Rule</a> * Model::getRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_rule.html">Rule</a> object based on the variable to which it assigns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the variable to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> in this <a class="el" href="class_model.html">Model</a> with the given "variable" attribute value or <code>NULL</code> if no such <a class="el" href="class_rule.html">Rule</a> exists. </dd></dl>

</div>
</div>
<a id="a7e1725f1b98e08e54485ec52404d579a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1725f1b98e08e54485ec52404d579a">&#9670;&nbsp;</a></span>getSBMLDocument() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> * SBase::getSBMLDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing this object instance. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<p>This method allows the caller to obtain the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> for the current object.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5" title="Returns the parent SBML object containing this object.">getParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2" title="Returns the Model object for the SBML Document in which the current object is located.">getModel()</a> </dd></dl>

</div>
</div>
<a id="a8c576e7dfaa4651bca4a782c9e09ac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c576e7dfaa4651bca4a782c9e09ac20">&#9670;&nbsp;</a></span>getSBMLDocument() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> * SBase::getSBMLDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing this object instance. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<p>This method allows the caller to obtain the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> for the current object.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5" title="Returns the parent SBML object containing this object.">getParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a776e0b06ec3f0dd2bfdafeec6c9d7cc2" title="Returns the Model object for the SBML Document in which the current object is located.">getModel()</a> </dd></dl>

</div>
</div>
<a id="a7d34cc625c18425a35a5513b88851a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d34cc625c18425a35a5513b88851a73">&#9670;&nbsp;</a></span>getSBOTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::getSBOTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integer portion of the value of the "sboTerm" attribute of this object. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "sboTerm" attribute as an integer, or <code>-1</code> if the value is not set. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_s_b_m_l_8cpp-example.html#a11">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8ed6545c2fab20f6dc44ae0c282c4fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed6545c2fab20f6dc44ae0c282c4fbf">&#9670;&nbsp;</a></span>getSBOTermAsURL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getSBOTermAsURL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the URL representation of the "sboTerm" attribute of this object. </p>
<p>This method returns the entire <a class="el" href="class_s_b_o.html">SBO</a> identifier as a text string in the form <code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://identifiers.org/biomodels.sbo/SBO:NNNNNNN"</code>.</p>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "sboTerm" attribute as an identifiers.org URL, or an empty string if the value is not set. </dd></dl>

</div>
</div>
<a id="ae57cbc2da2e34a8c829e42743e68dd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57cbc2da2e34a8c829e42743e68dd85">&#9670;&nbsp;</a></span>getSBOTermID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getSBOTermID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the "sboTerm" attribute of this object. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "sboTerm" attribute as a string (its value will be of the form "SBO:NNNNNNN"), or an empty string if the value is not set. </dd></dl>

</div>
</div>
<a id="a2c57c79a886696cd33aa0aca4671ff59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c57c79a886696cd33aa0aca4671ff59">&#9670;&nbsp;</a></span>getSpecies() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species.html">Species</a> * Model::getSpecies </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_species.html">Species</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species.html">Species</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_species.html">Species</a> exists. </dd></dl>

</div>
</div>
<a id="ad4578b30237a83f2e8c8f791f30a8e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4578b30237a83f2e8c8f791f30a8e3b">&#9670;&nbsp;</a></span>getSpecies() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_species.html">Species</a> * Model::getSpecies </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_species.html">Species</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species.html">Species</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_species.html">Species</a> exists. </dd></dl>

</div>
</div>
<a id="a1ebf646dea01f37c5671478eca44b9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf646dea01f37c5671478eca44b9c9">&#9670;&nbsp;</a></span>getSpecies() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species.html">Species</a> * Model::getSpecies </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_species.html">Species</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_species.html">Species</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a19f5a10054812b4c7eab4ff9266d4c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f5a10054812b4c7eab4ff9266d4c2d">&#9670;&nbsp;</a></span>getSpecies() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_species.html">Species</a> * Model::getSpecies </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_species.html">Species</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_species.html">Species</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_c_v_terms_8cpp-example.html#a7">addCVTerms.cpp</a>, <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a7">addingEvidenceCodes_2.cpp</a>, <a class="el" href="append_annotation_8cpp-example.html#a7">appendAnnotation.cpp</a>, <a class="el" href="print_annotation_8cpp-example.html#a34">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a34">printNotes.cpp</a>, <a class="el" href="print_units_8cpp-example.html#a8">printUnits.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a27">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a27">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac5e075f403fee78de3bbb3cc92e20d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e075f403fee78de3bbb3cc92e20d17">&#9670;&nbsp;</a></span>getSpeciesReference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_reference.html">SpeciesReference</a> * Model::getSpeciesReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_species_reference.html">SpeciesReference</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_reference.html">SpeciesReference</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_species_reference.html">SpeciesReference</a> exists. </dd></dl>

</div>
</div>
<a id="acfc20ad127946139bdc3be9f0c7e6917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc20ad127946139bdc3be9f0c7e6917">&#9670;&nbsp;</a></span>getSpeciesReference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_species_reference.html">SpeciesReference</a> * Model::getSpeciesReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_species_reference.html">SpeciesReference</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_reference.html">SpeciesReference</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_species_reference.html">SpeciesReference</a> exists. </dd></dl>

</div>
</div>
<a id="a389c658e90e7032b20d1e3d5b8934db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389c658e90e7032b20d1e3d5b8934db4">&#9670;&nbsp;</a></span>getSpeciesType() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_type.html">SpeciesType</a> * Model::getSpeciesType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_species_type.html">SpeciesType</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_type.html">SpeciesType</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_species_type.html">SpeciesType</a> exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a5dc8870c97cd47b351cc63652e3d0bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc8870c97cd47b351cc63652e3d0bc7">&#9670;&nbsp;</a></span>getSpeciesType() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_species_type.html">SpeciesType</a> * Model::getSpeciesType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_species_type.html">SpeciesType</a> object based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_type.html">SpeciesType</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_species_type.html">SpeciesType</a> exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a65322b81388c4d5eaddf00a2e72f6ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65322b81388c4d5eaddf00a2e72f6ded">&#9670;&nbsp;</a></span>getSpeciesType() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_type.html">SpeciesType</a> * Model::getSpeciesType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_species_type.html">SpeciesType</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_species_type.html">SpeciesType</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>

</div>
</div>
<a id="a665c02ea7f3970279eda8d8912ddc4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c02ea7f3970279eda8d8912ddc4a6">&#9670;&nbsp;</a></span>getSpeciesType() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_species_type.html">SpeciesType</a> * Model::getSpeciesType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_species_type.html">SpeciesType</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_species_type.html">SpeciesType</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_species_type.html">SpeciesType</a> object class is only available in SBML Level&#160;2 Versions&#160;2&ndash;4. It is not available in Level&#160;1 nor Level&#160;3. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a66">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a66">printNotes.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a53">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a53">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a57332c13813ff013031f5233d7d9abdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57332c13813ff013031f5233d7d9abdd">&#9670;&nbsp;</a></span>getSubstanceUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getSubstanceUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the substanceUnits of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "substanceUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="af84b98b545432d1cc5d1f029ecebf7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84b98b545432d1cc5d1f029ecebf7de">&#9670;&nbsp;</a></span>getTimeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getTimeUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the timeUnits of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "timeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="ab3d3e3ffc648349c8f0472313ded4827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d3e3ffc648349c8f0472313ded4827">&#9670;&nbsp;</a></span>getTypeCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::getTypeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the libSBML type code for this SBML object. </p>
<dl class="section user"><dt></dt><dd>LibSBML attaches an identifying code to every kind of SBML object. These are integer constants known as <em>SBML type codes</em>. The names of all the codes begin with the characters <code>SBML_</code>. The set of possible type codes for core elements is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types.">SBMLTypeCode_t</a>, and in addition, libSBML plug-ins for SBML Level&#160;3 packages define their own extra enumerations of type codes (e.g., <a class="el" href="_layout_extension_8h.html#a6b80c825e1507341de5540b8e7de003d" title="SBMLFbcTypeCode_t Enumeration of possible types in the libSBML âlayoutâ package implementation.">SBMLLayoutTypeCode_t</a> for the Level&#160;3 <a class="el" href="class_layout.html">Layout</a> package). Note that different Level&#160;3 package plug-ins may use overlapping type codes; to identify the package to which a given object belongs, call the <code><a class="el" href="class_s_base.html#a031d1da6a39bae8afd5201677fb32c02" title="Returns the name of the SBML Level&#160;3 package in which this element is defined.">SBase::getPackageName()</a> </code> method on the object.</dd></dl>
<p>The exception to this is lists: all SBML-style list elements have the type <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaa111b52def73380487c84f062f47dadc">SBML_LIST_OF</a>, regardless of what package they are from.</p>
<dl class="section return"><dt>Returns</dt><dd>the SBML type code for this object: <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea3c866be107d7858b6dd1e978ed103028">SBML_MODEL</a> (default).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">The specific integer values of the possible type codes may be reused by different libSBML plug-ins for SBML Level&#160;3. packages, To fully identify the correct code, <b>it is necessary to invoke both <a class="el" href="class_s_base.html#a031d1da6a39bae8afd5201677fb32c02" title="Returns the name of the SBML Level&#160;3 package in which this element is defined.">getPackageName()</a> and <a class="el" href="class_model.html#ab3d3e3ffc648349c8f0472313ded4827" title="Returns the libSBML type code for this SBML object.">getTypeCode()</a></b> (or <a class="el" href="class_list_of.html#a58f2728f978ffba0d032c412901b824e" title="Get the type code of the objects contained in this ListOf.">ListOf::getItemTypeCode()</a>).</span></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ae5b49b964d1f467861fee03c0fd6f5a4" title="Returns the XML element name of this object, which for Model, is always &quot;model&quot;.">getElementName()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a031d1da6a39bae8afd5201677fb32c02" title="Returns the name of the SBML Level&#160;3 package in which this element is defined.">getPackageName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a4109c299320c6c59251fc84d6eeaec69">SBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_model_definition.html#a8912fb3fb242aae67d8952d0406f540c">ModelDefinition</a>.</p>

</div>
</div>
<a id="a0c2dc2d40ce1b6cb85369518c61e55bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2dc2d40ce1b6cb85369518c61e55bb">&#9670;&nbsp;</a></span>getUnitDefinition() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::getUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_unit_definition.html">UnitDefinition</a> based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_unit_definition.html">UnitDefinition</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_unit_definition.html">UnitDefinition</a> exists. </dd></dl>

</div>
</div>
<a id="a520c86d0b8fa54ee12931090d138f52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520c86d0b8fa54ee12931090d138f52a">&#9670;&nbsp;</a></span>getUnitDefinition() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::getUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="class_unit_definition.html">UnitDefinition</a> based on its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_unit_definition.html">UnitDefinition</a> in this <a class="el" href="class_model.html">Model</a> with the identifier <code>sid</code> or <code>NULL</code> if no such <a class="el" href="class_unit_definition.html">UnitDefinition</a> exists. </dd></dl>

</div>
</div>
<a id="a9d7b166e618471e10e914a8327b6ccf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7b166e618471e10e914a8327b6ccf4">&#9670;&nbsp;</a></span>getUnitDefinition() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::getUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a id="a77eaad5846c659dd915ae64ea2c2556f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77eaad5846c659dd915ae64ea2c2556f">&#9670;&nbsp;</a></span>getUnitDefinition() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::getUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> object in this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the object to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> of this <a class="el" href="class_model.html">Model</a>. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a43">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a43">printNotes.cpp</a>, <a class="el" href="unset_annotation_8cpp-example.html#a36">unsetAnnotation.cpp</a>, and <a class="el" href="unset_notes_8cpp-example.html#a36">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8e3e54c62bc34c720d96b421c9798dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3e54c62bc34c720d96b421c9798dde">&#9670;&nbsp;</a></span>getURI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getURI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the namespace URI to which this element belongs to. </p>
<p>For example, all elements that belong to SBML Level&#160;3 Version&#160;1 Core must would have the URI <code>"http://www.sbml.org/sbml/level3/version1/core"</code>; all elements that belong to <a class="el" href="class_layout.html">Layout</a> Extension Version 1 for SBML Level&#160;3 Version&#160;1 Core must would have the URI <code>"http://www.sbml.org/sbml/level3/version1/layout/version1"</code>.</p>
<p>This function first returns the URI for this element by looking into the <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object of the document with the its package name. If not found, it will then look for the namespace associated with the element itself.</p>
<dl class="section return"><dt>Returns</dt><dd>the URI of this element, as a text string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance.">getSBMLDocument()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a031d1da6a39bae8afd5201677fb32c02" title="Returns the name of the SBML Level&#160;3 package in which this element is defined.">getPackageName()</a> </dd></dl>

</div>
</div>
<a id="a2da81b22af670c12375835a6f992c5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da81b22af670c12375835a6f992c5db">&#9670;&nbsp;</a></span>getUserData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SBase::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the user data that has been previously set via <a class="el" href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb" title="Sets the user data of this element.">setUserData()</a>. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the user data of this node, or <code>NULL</code> if no user data has been set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node.">ASTNode::setUserData(void *userData)</a> </dd></dl>

</div>
</div>
<a id="aed8f42e0f220bd85af8d01b51d87aeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8f42e0f220bd85af8d01b51d87aeff">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Version within the SBML Level of the <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object containing <em>this</em> object. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the SBML version of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#af0a70ab6f715e912c6431072c4339f2c" title="Returns the SBML Level of the SBMLDocument object containing this object.">getLevel()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb90be26c77f519375553365af009a58" title="Returns a list of the XML Namespaces declared on the SBML document owning this object.">getNamespaces()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_layout_8cpp-example.html#a13">addLayout.cpp</a>, <a class="el" href="convert_s_b_m_l_8cpp-example.html#a7">convertSBML.cpp</a>, and <a class="el" href="print_s_b_m_l_8cpp-example.html#a5">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab4519053fbe17e5639df8ee7aab914c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4519053fbe17e5639df8ee7aab914c2">&#9670;&nbsp;</a></span>getVolumeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Model::getVolumeUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the volumeUnits of this <a class="el" href="class_model.html">Model</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "volumeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a3428a0985f707e08b3221e338f484866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3428a0985f707e08b3221e338f484866">&#9670;&nbsp;</a></span>hasRequiredElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::hasRequiredElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if all the required elements for this <a class="el" href="class_model.html">Model</a> object have been set. </p>
<dl class="section return"><dt>Returns</dt><dd>a boolean value indicating whether all the required elements for this object have been defined. </dd></dl>

</div>
</div>
<a id="a4c78f1941d1d0fc804b6b4a1dd0db54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c78f1941d1d0fc804b6b4a1dd0db54e">&#9670;&nbsp;</a></span>hasValidLevelVersionNamespaceCombination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::hasValidLevelVersionNamespaceCombination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's level/version and namespace values correspond to a valid SBML specification. </p>
<p>The valid combinations of SBML Level, Version and Namespace as of this release of libSBML are the following: </p><ul>
<li>
Level&#160;1 Version&#160;2: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level1</code>&quot; </li>
<li>
Level&#160;2 Version&#160;1: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2</code>&quot; </li>
<li>
Level&#160;2 Version&#160;2: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version2</code>&quot; </li>
<li>
Level&#160;2 Version&#160;3: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version3</code>&quot; </li>
<li>
Level&#160;2 Version&#160;4: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version4</code>&quot; </li>
<li>
Level&#160;2 Version&#160;5: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version5</code>&quot; </li>
<li>
Level&#160;3 Version&#160;1 Core: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level3/version1/core</code>&quot; </li>
<li>
Level&#160;3 Version&#160;2 Core: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level3/version2/core</code>&quot; </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the level, version and namespace values of this SBML object correspond to a valid set of values, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad66c6e186d50df79ce90492eeeb060e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66c6e186d50df79ce90492eeeb060e2">&#9670;&nbsp;</a></span>isPackageEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPackageEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object. </p>
<p>The search ignores the package version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgName</td><td>the name of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a30ac3f72984fb7e41ae5dc88f2a0504d" title="Predicate returning true if an SBML Level&#160;3 package with the given URI is enabled with this object.">isPackageURIEnabled()</a> </dd></dl>

</div>
</div>
<a id="a30ac3f72984fb7e41ae5dc88f2a0504d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ac3f72984fb7e41ae5dc88f2a0504d">&#9670;&nbsp;</a></span>isPackageURIEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPackageURIEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad66c6e186d50df79ce90492eeeb060e2" title="Predicate returning true if the given SBML Level&#160;3 package is enabled with this object.">isPackageEnabled()</a> </dd></dl>

</div>
</div>
<a id="a0df1a731505cbddfcb2c504bd86ba9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df1a731505cbddfcb2c504bd86ba9c0">&#9670;&nbsp;</a></span>isPkgEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPkgEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object. </p>
<p>The search ignores the package version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgName</td><td>the name of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7a9574c886d54be2db67210bbd8fcf18" title="Predicate returning true if an SBML Level&#160;3 package with the given URI is enabled with this object.">isPkgURIEnabled()</a> </dd></dl>

</div>
</div>
<a id="a7a9574c886d54be2db67210bbd8fcf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9574c886d54be2db67210bbd8fcf18">&#9670;&nbsp;</a></span>isPkgURIEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPkgURIEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a0df1a731505cbddfcb2c504bd86ba9c0" title="Predicate returning true if the given SBML Level&#160;3 package is enabled with this object.">isPkgEnabled()</a> </dd></dl>

</div>
</div>
<a id="a7133538f5b6084a755ae7d03bda4a073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7133538f5b6084a755ae7d03bda4a073">&#9670;&nbsp;</a></span>isPopulatedAllElementIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isPopulatedAllElementIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if libSBML has a list of the ids of all components of this model. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the id list has already been populated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab94f35a0a0725d104b545e8b6ae543d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94f35a0a0725d104b545e8b6ae543d6">&#9670;&nbsp;</a></span>isPopulatedAllElementMetaIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isPopulatedAllElementMetaIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if libSBML has a list of the metaids of all components of this model. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the metaid list has already been populated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a935ca96791e9c46a46eef75000134db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935ca96791e9c46a46eef75000134db4">&#9670;&nbsp;</a></span>isPopulatedListFormulaUnitsData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isPopulatedListFormulaUnitsData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if libSBML has derived units for the components of this model. </p>
<p>LibSBML can infer the units of measurement associated with different elements of a model. When libSBML does that, it builds a complex internal structure during a resource-intensive operation. This is done automatically only when callers invoke validation (via <a class="el" href="class_s_b_m_l_document.html#a25684f139b8f5e44ec2089eba3fdfda0" title="Performs consistency checking and validation on this SBML document.">SBMLDocument::checkConsistency()</a>) and have not turned off the unit validation option.</p>
<p>Callers can force units to be recalculated by calling <a class="el" href="class_model.html#af0502de1661e4c15c52852dd4ea7b8e7" title="Populates the internal list of derived units for this Model object.">populateListFormulaUnitsData()</a>. To avoid calling that method unnecessarily, calling programs may first want to invoke this method (<a class="el" href="class_model.html#a935ca96791e9c46a46eef75000134db4" title="Predicate returning true if libSBML has derived units for the components of this model.">isPopulatedListFormulaUnitsData()</a>) to determine whether it is even necessary.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the units have already been computed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5af865a159b3b1c5a16729bce7e4e3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af865a159b3b1c5a16729bce7e4e3c2">&#9670;&nbsp;</a></span>isSetAnnotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "annotation" subelement exists and has content. </p>
<p>Whereas the <a class="el" href="class_s_base.html">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a "annotation" subelement exists, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object.">unsetAnnotation()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_annotation_8cpp-example.html#a1">printAnnotation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a68e54982a56ee89339590175bc9884fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e54982a56ee89339590175bc9884fe">&#9670;&nbsp;</a></span>isSetAreaUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetAreaUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "areaUnits" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "areaUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a29f3f327c7fd0ff19a0203e55bbf5601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f3f327c7fd0ff19a0203e55bbf5601">&#9670;&nbsp;</a></span>isSetConversionFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetConversionFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "conversionFactor" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "conversionFactor" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="aa585552960ae4b7e8d4cec0c301d670e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa585552960ae4b7e8d4cec0c301d670e">&#9670;&nbsp;</a></span>isSetCreatedDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetCreatedDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object has a <a class="el" href="class_model_history.html">ModelHistory</a> object attached to it and the created date is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the CreatedDate of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="acc95334caffb352582e483efc3ef31a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc95334caffb352582e483efc3ef31a9">&#9670;&nbsp;</a></span>isSetExtentUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetExtentUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "extentUnits" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "extentUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="ae9a90c5f7f69760983ed2579b14e68ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a90c5f7f69760983ed2579b14e68ce">&#9670;&nbsp;</a></span>isSetId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "id" attribute is set. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "id" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because of the inconsistent behavior of this function with respect to assignments and rules, it is recommended that callers use <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a78e5ac577ff9cf83d6fc413f5053d705">SBase</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a13">SBMLHttpResolverExample.cpp</a>, and <a class="el" href="print_s_b_m_l_8cpp-example.html#a8">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9fb99b60d2f2f0427e818187cc6f6ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb99b60d2f2f0427e818187cc6f6ad9">&#9670;&nbsp;</a></span>isSetIdAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetIdAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "id" attribute is set. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "id" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd></dl>

</div>
</div>
<a id="a0ec3af3f635d27c1eb1c8759993c8cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec3af3f635d27c1eb1c8759993c8cde">&#9670;&nbsp;</a></span>isSetLengthUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetLengthUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "lengthUnits" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "lengthUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a7b43de27cb29136954af762fa91d4842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b43de27cb29136954af762fa91d4842">&#9670;&nbsp;</a></span>isSetMetaId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "metaid" attribute is set. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "metaid" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4" title="Returns the value of the &quot;metaid&quot; attribute of this SBML object.">getMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55" title="Sets the value of the meta-identifier attribute of this SBML object.">setMetaId(const std::string&amp; metaid)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_1_8cpp-example.html#a8">addingEvidenceCodes_1.cpp</a>, and <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a8">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0a8fa8e4911040c0fdf6cdd03a22f564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8fa8e4911040c0fdf6cdd03a22f564">&#9670;&nbsp;</a></span>isSetModelHistory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object has a <a class="el" href="class_model_history.html">ModelHistory</a> object attached to it. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="class_model_history.html">ModelHistory</a> of this object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a7a260cec1705d70d0fea2259b5665b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a260cec1705d70d0fea2259b5665b92">&#9670;&nbsp;</a></span>isSetModifiedDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetModifiedDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> or <code>false</code> depending on whether the <a class="el" href="class_model_history.html">ModelHistory</a>'s "modified date" of this object is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the modification date value of this <a class="el" href="class_model_history.html">ModelHistory</a> object is set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa0c315424f527945e40d9a48a530b786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c315424f527945e40d9a48a530b786">&#9670;&nbsp;</a></span>isSetName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "name" attribute is set. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;3 Version&#160;2, the "id" and "name" attributes were moved to <a class="el" href="class_s_base.html">SBase</a> directly, instead of being defined individually for many (but not all) objects. LibSBML has for a long time provided functions defined on <a class="el" href="class_s_base.html">SBase</a> itself to get, set, and unset those attributes, which would fail or otherwise return empty strings if executed on any object for which those attributes were not defined. Now that all <a class="el" href="class_s_base.html">SBase</a> objects define those attributes, those functions now succeed for any object with the appropriate level and version.</dd></dl>
<p>The "name" attribute is optional and is not intended to be used for cross-referencing purposes within a model. Its purpose instead is to provide a human-readable label for the component. The data type of "name" is the type <code>string</code> defined in XML Schema. SBML imposes no restrictions as to the content of "name" attributes beyond those restrictions defined by the <code>string</code> type in XML Schema.</p>
<p>The recommended practice for handling "name" is as follows. If a software tool has the capability for displaying the content of "name" attributes, it should display this content to the user as a component's label instead of the component's "id". If the user interface does not have this capability (e.g., because it cannot display or use special characters in symbol names), or if the "name" attribute is missing on a given component, then the user interface should display the value of the "id" attribute instead. (Script language interpreters are especially likely to display "id" instead of "name".)</p>
<p>As a consequence of the above, authors of systems that automatically generate the values of "id" attributes should be aware some systems may display the "id"'s to the user. Authors therefore may wish to take some care to have their software create "id" values that are: (a) reasonably easy for humans to type and read; and (b) likely to be meaningful, for example by making the "id" attribute be an abbreviated form of the name attribute value.</p>
<p>An additional point worth mentioning is although there are restrictions on the uniqueness of "id" values, there are no restrictions on the uniqueness of "name" values in a model. This allows software applications leeway in assigning component identifiers.</p>
<p>Regardless of the level and version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have names). If the object in question does not posess a "name" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the name to be set, nor will it read or write "name" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "name" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ac2792c4eb1d7509af701f555290c3890" title="Returns the value of the &quot;name&quot; attribute of this Model object.">getName()</a> </dd>
<dd>
<a class="el" href="class_model.html#aa9f4b34956328dece618208f1f61f8e8" title="Sets the value of the &quot;name&quot; attribute of this Model.">setName(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_model.html#a1c272e1c5658984d36c2db89a66b0af8" title="Unsets the value of the &quot;name&quot; attribute of this Model.">unsetName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a70abee08c67db2cba0c5ed40af9aa1c0">SBase</a>.</p>

</div>
</div>
<a id="a83909a09abfab77fea3429482c79e867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83909a09abfab77fea3429482c79e867">&#9670;&nbsp;</a></span>isSetNotes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "notes" subelement exists and has content. </p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a "notes" subelement exists, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a15">SBMLHttpResolverExample.cpp</a>, <a class="el" href="get_all_elements_with_notes_8cpp-example.html#a2">getAllElementsWithNotes.cpp</a>, and <a class="el" href="print_notes_8cpp-example.html#a1">printNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5fed1bd6da28c0cc0ec118209f7327a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fed1bd6da28c0cc0ec118209f7327a2">&#9670;&nbsp;</a></span>isSetSBOTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetSBOTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "sboTerm" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "sboTerm" attribute of this SBML object is set, <code>false</code> otherwise. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="print_s_b_m_l_8cpp-example.html#a10">printSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa3e33471b61e94798aa9fb466541580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e33471b61e94798aa9fb466541580c">&#9670;&nbsp;</a></span>isSetSubstanceUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetSubstanceUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "substanceUnits" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "substanceUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="adbaf85f3098c0a308498fd2e96bb9638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaf85f3098c0a308498fd2e96bb9638">&#9670;&nbsp;</a></span>isSetTimeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetTimeUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "timeUnits" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "substanceUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="abbd9e46d49ea191134832353b7b91c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd9e46d49ea191134832353b7b91c6d">&#9670;&nbsp;</a></span>isSetUserData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning true or false depending on whether the user data of this element has been set. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's user data has been set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a944dc0fe625a4d690de0163d250778fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944dc0fe625a4d690de0163d250778fc">&#9670;&nbsp;</a></span>isSetVolumeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::isSetVolumeUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_model.html">Model</a>'s "volumeUnits" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "volumeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a94ead78ebf80118b1027af5438f22516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ead78ebf80118b1027af5438f22516">&#9670;&nbsp;</a></span>matchesRequiredSBMLNamespacesForAddition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesRequiredSBMLNamespacesForAddition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is a subset of <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad17b3447a4eb8ddd9bac16b0fd5bfa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17b3447a4eb8ddd9bac16b0fd5bfa6d">&#9670;&nbsp;</a></span>matchesRequiredSBMLNamespacesForAddition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesRequiredSBMLNamespacesForAddition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is a subset of <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a936f753a9032913c569dafa3642d8252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936f753a9032913c569dafa3642d8252">&#9670;&nbsp;</a></span>matchesSBMLNamespaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesSBMLNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is the same as <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a39e0febad1c149b4a8455662afd845b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0febad1c149b4a8455662afd845b4">&#9670;&nbsp;</a></span>matchesSBMLNamespaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesSBMLNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is the same as <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af5cafbc1f38725eba56acc5f159c9aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cafbc1f38725eba56acc5f159c9aa2">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_model.html">Model</a> &amp; Model::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="class_model.html">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the object whose values are used as the basis of the assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13bc6489994799d81c01a0ac01a1bf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bc6489994799d81c01a0ac01a1bf51">&#9670;&nbsp;</a></span>populateAllElementIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::populateAllElementIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the internal list of the identifiers of all elements within this <a class="el" href="class_model.html">Model</a> object. </p>
<p>This method tells libSBML to retrieve the identifiers of all elements of the enclosing <a class="el" href="class_model.html">Model</a> object. The result is stored in an internal list of ids. Users can access the resulting data by calling the method <a class="el" href="class_model.html#a429026066b1ac0576886268101257122" title="Returns the internal list of the identifiers of all elements within this Model object.">getAllElementIdList()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Retrieving all elements within a model is a time-consuming operation. Callers may want to call <a class="el" href="class_model.html#a7133538f5b6084a755ae7d03bda4a073" title="Predicate returning true if libSBML has a list of the ids of all components of this model.">isPopulatedAllElementIdList()</a> to determine whether the id list may already have been populated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a7133538f5b6084a755ae7d03bda4a073" title="Predicate returning true if libSBML has a list of the ids of all components of this model.">isPopulatedAllElementIdList()</a> </dd></dl>

</div>
</div>
<a id="afac79c0d2481a7099f947faa61732fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac79c0d2481a7099f947faa61732fd9">&#9670;&nbsp;</a></span>populateAllElementMetaIdList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::populateAllElementMetaIdList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the internal list of the metaids of all elements within this <a class="el" href="class_model.html">Model</a> object. </p>
<p>This method tells libSBML to retrieve the identifiers of all elements of the enclosing <a class="el" href="class_model.html">Model</a> object. The result is stored in an internal list of metaids. Users can access the resulting data by calling the method <a class="el" href="class_model.html#a0e278fef0bac04e05929eb1c02fac194" title="Returns the internal list of the metaids of all elements within this Model object.">getAllElementMetaIdList()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Retrieving all elements within a model is a time-consuming operation. Callers may want to call <a class="el" href="class_model.html#ab94f35a0a0725d104b545e8b6ae543d6" title="Predicate returning true if libSBML has a list of the metaids of all components of this model.">isPopulatedAllElementMetaIdList()</a> to determine whether the metaid list may already have been populated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ab94f35a0a0725d104b545e8b6ae543d6" title="Predicate returning true if libSBML has a list of the metaids of all components of this model.">isPopulatedAllElementMetaIdList()</a> </dd></dl>

</div>
</div>
<a id="af0502de1661e4c15c52852dd4ea7b8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0502de1661e4c15c52852dd4ea7b8e7">&#9670;&nbsp;</a></span>populateListFormulaUnitsData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::populateListFormulaUnitsData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the internal list of derived units for this <a class="el" href="class_model.html">Model</a> object. </p>
<p>This method tells libSBML to (re)calculate all units for all components of the enclosing <a class="el" href="class_model.html">Model</a> object. The result is stored in an internal list of unit data. Users can access the resulting data by calling the method SBase::getDerivedUnitDefinition() available on most objects. (The name "formula units data" is drawn from the name of the internal objects libSBML uses to store the data; note that these internal objects are not exposed to callers, because callers can interact with the results using the ordinary SBML unit objects.)</p>
<p>This method is used by libSBML itself in the validator concerned with unit consistency. The unit consistency validator (like all other validators in libSBML) is invoked by using <a class="el" href="class_s_b_m_l_document.html#a25684f139b8f5e44ec2089eba3fdfda0" title="Performs consistency checking and validation on this SBML document.">SBMLDocument::checkConsistency()</a>, with the consistency checks for the category <a class="el" href="_s_b_m_l_error_8h.html#aec82216b5939329921fd2c6f00c62187ab4dd0b6c395c23ddd8772c170f0f924c">LIBSBML_CAT_UNITS_CONSISTENCY</a> turned on. The method <a class="el" href="class_model.html#af0502de1661e4c15c52852dd4ea7b8e7" title="Populates the internal list of derived units for this Model object.">populateListFormulaUnitsData()</a> does not need to be called prior to invoking the validator if unit consistency checking has not been turned off. This method is only provided for cases when callers have a special need to force the unit data to be recalculated. For instance, during construction of a model, a caller may want to interrogate libSBML's inferred units without invoking full-blown model validation; this is a scenario in which calling <a class="el" href="class_model.html#af0502de1661e4c15c52852dd4ea7b8e7" title="Populates the internal list of derived units for this Model object.">populateListFormulaUnitsData()</a> may be useful.</p>
<dl class="section warning"><dt>Warning</dt><dd>Computing and inferring units is a time-consuming operation. Callers may want to call <a class="el" href="class_model.html#a935ca96791e9c46a46eef75000134db4" title="Predicate returning true if libSBML has derived units for the components of this model.">isPopulatedListFormulaUnitsData()</a> to determine whether the units may already have been computed, to save themselves the need of invoking unit inference unnecessarily.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a935ca96791e9c46a46eef75000134db4" title="Predicate returning true if libSBML has derived units for the components of this model.">isPopulatedListFormulaUnitsData()</a> </dd></dl>

</div>
</div>
<a id="a8e455a93329e407b4b1d8ad307c95a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e455a93329e407b4b1d8ad307c95a22">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710">XMLErrorSeverityOverride_t</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710add6235c114a38f4b2b00c4e79761d4c7">LIBSBML_OVERRIDE_DISABLED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads (initializes) this SBML object by reading from the given <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_x_m_l_node.html">XMLNode</a> to read from.</td></tr>
    <tr><td class="paramname">flag</td><td>an optional flag that determines how how errors are logged during the reading process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This method is computationally expensive, because the given node has to be serialized to a string first. Attempting to serialize a large tree structure (e.g., a large <a class="el" href="class_model.html">Model</a>) may consume significant computer memory and time.</span> </dd></dl>

</div>
</div>
<a id="ac4b01adc48251eab36392b8fc4fa209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b01adc48251eab36392b8fc4fa209c">&#9670;&nbsp;</a></span>removeCompartment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment.html">Compartment</a> * Model::removeCompartment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_compartment.html">Compartment</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_compartment.html">Compartment</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment.html">Compartment</a> object removed, or <code>NULL</code> if no <a class="el" href="class_compartment.html">Compartment</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a17495089079cfbf755fb6b8608208fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17495089079cfbf755fb6b8608208fae">&#9670;&nbsp;</a></span>removeCompartment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment.html">Compartment</a> * Model::removeCompartment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_compartment.html">Compartment</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_compartment.html">Compartment</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment.html">Compartment</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="aca63f84ae8db9ebcc4b8e8e29dcab96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca63f84ae8db9ebcc4b8e8e29dcab96c">&#9670;&nbsp;</a></span>removeCompartmentType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::removeCompartmentType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_compartment_type.html">CompartmentType</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_compartment_type.html">CompartmentType</a> object removed, or <code>NULL</code> if no <a class="el" href="class_compartment_type.html">CompartmentType</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a4ec7cdadde2db2810a8681c0b907d993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec7cdadde2db2810a8681c0b907d993">&#9670;&nbsp;</a></span>removeCompartmentType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_compartment_type.html">CompartmentType</a> * Model::removeCompartmentType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_compartment_type.html">CompartmentType</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_compartment_type.html">CompartmentType</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ComapartmentType object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a024f15a16b74e43f3a2beb43a32b81d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024f15a16b74e43f3a2beb43a32b81d8">&#9670;&nbsp;</a></span>removeConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_constraint.html">Constraint</a> * Model::removeConstraint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_constraint.html">Constraint</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_constraint.html">Constraint</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_constraint.html">Constraint</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a5814610f657b6072506d0c7731b581cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5814610f657b6072506d0c7731b581cb">&#9670;&nbsp;</a></span>removeEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_event.html">Event</a> * Model::removeEvent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_event.html">Event</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_event.html">Event</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_event.html">Event</a> object removed, or <code>NULL</code> if no <a class="el" href="class_event.html">Event</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a5cf8e87daa535ffbe44581d6143c255a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf8e87daa535ffbe44581d6143c255a">&#9670;&nbsp;</a></span>removeEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_event.html">Event</a> * Model::removeEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_event.html">Event</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_event.html">Event</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_event.html">Event</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a7d1d8abe17e84f928af67844352c3b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1d8abe17e84f928af67844352c3b5b">&#9670;&nbsp;</a></span>removeFromParentAndDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::removeFromParentAndDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove this <a class="el" href="class_model.html">Model</a> from its parent <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> object. </p>
<p>This works by finding this <a class="el" href="class_model.html">Model</a>'s parent <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> and then calling <code>setModel(NULL)</code> on it, indirectly deleting itself. Overridden from the <a class="el" href="class_s_base.html">SBase</a> function since the parent is not a <a class="el" href="class_list_of.html">ListOf</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#ae431ca4044e40e1fe8e0ff4136dce838">SBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_model_definition.html#a2cdd3a92e416ccfb76b6e77dcb56689e">ModelDefinition</a>.</p>

</div>
</div>
<a id="a0e1ff2fb9637f83938f963fd5092fe63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1ff2fb9637f83938f963fd5092fe63">&#9670;&nbsp;</a></span>removeFunctionDefinition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::removeFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object removed, or <code>NULL</code> if no <a class="el" href="class_function_definition.html">FunctionDefinition</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a21462b9a21d3a8639d5b4ec2f0a56659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21462b9a21d3a8639d5b4ec2f0a56659">&#9670;&nbsp;</a></span>removeFunctionDefinition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_function_definition.html">FunctionDefinition</a> * Model::removeFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_function_definition.html">FunctionDefinition</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_function_definition.html">FunctionDefinition</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a226096a95d5a7e1b0e4a34cc0b5d262a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226096a95d5a7e1b0e4a34cc0b5d262a">&#9670;&nbsp;</a></span>removeInitialAssignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::removeInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object with the given "symbol" attribute from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>Removes the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.</p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the "symbol" attribute of the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object removed, or <code>NULL</code> if no <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object with the "symbol" attribute exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="aaf318fd2ad914c31d942f0210ca228c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf318fd2ad914c31d942f0210ca228c1">&#9670;&nbsp;</a></span>removeInitialAssignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_initial_assignment.html">InitialAssignment</a> * Model::removeInitialAssignment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_initial_assignment.html">InitialAssignment</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="aed90b4ce5032d879063b332f2a191024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed90b4ce5032d879063b332f2a191024">&#9670;&nbsp;</a></span>removeParameter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parameter.html">Parameter</a> * Model::removeParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_parameter.html">Parameter</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_parameter.html">Parameter</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> object removed, or <code>NULL</code> if no <a class="el" href="class_parameter.html">Parameter</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a6f79ad6f6b67b170d5500b9a1d1432fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f79ad6f6b67b170d5500b9a1d1432fd">&#9670;&nbsp;</a></span>removeParameter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parameter.html">Parameter</a> * Model::removeParameter </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_parameter.html">Parameter</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_parameter.html">Parameter</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_parameter.html">Parameter</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a894c81f0ce6be976fb2b22e37b91cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894c81f0ce6be976fb2b22e37b91cdf5">&#9670;&nbsp;</a></span>removeReaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_reaction.html">Reaction</a> * Model::removeReaction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_reaction.html">Reaction</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_reaction.html">Reaction</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_reaction.html">Reaction</a> object removed, or <code>NULL</code> if no <a class="el" href="class_reaction.html">Reaction</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a21ffd7a1d815b15fcc8ed7177e8ed8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ffd7a1d815b15fcc8ed7177e8ed8c2">&#9670;&nbsp;</a></span>removeReaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_reaction.html">Reaction</a> * Model::removeReaction </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_reaction.html">Reaction</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_reaction.html">Reaction</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_reaction.html">Reaction</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a517c692f894d1930eff2c0127bf012e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517c692f894d1930eff2c0127bf012e0">&#9670;&nbsp;</a></span>removeRule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule.html">Rule</a> * Model::removeRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_rule.html">Rule</a> object with the given "variable" attribute from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>Removes the <a class="el" href="class_rule.html">Rule</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.</p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the "variable" attribute of the <a class="el" href="class_rule.html">Rule</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> object removed, or <code>NULL</code> if no <a class="el" href="class_rule.html">Rule</a> object with the "variable" attribute exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="ac6a93206f092becd12ae6af5b8aa6725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a93206f092becd12ae6af5b8aa6725">&#9670;&nbsp;</a></span>removeRule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule.html">Rule</a> * Model::removeRule </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_rule.html">Rule</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_rule.html">Rule</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a52dd6c9882c2caee5b2d9111ebd11fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dd6c9882c2caee5b2d9111ebd11fb6">&#9670;&nbsp;</a></span>removeRuleByVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule.html">Rule</a> * Model::removeRuleByVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_rule.html">Rule</a> object with the given "variable" attribute from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>Removes the <a class="el" href="class_rule.html">Rule</a> object with the given variable from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it.</p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>the "variable" attribute of the <a class="el" href="class_rule.html">Rule</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_rule.html">Rule</a> object removed, or <code>NULL</code> if no <a class="el" href="class_rule.html">Rule</a> object with the "variable" attribute exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a017efd2ed9a2f713ffd02f41a07368b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017efd2ed9a2f713ffd02f41a07368b9">&#9670;&nbsp;</a></span>removeSpecies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species.html">Species</a> * Model::removeSpecies </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_species.html">Species</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_species.html">Species</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species.html">Species</a> object removed, or <code>NULL</code> if no <a class="el" href="class_species.html">Species</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="ac49b94737419c17dd302b2e049e8b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49b94737419c17dd302b2e049e8b564">&#9670;&nbsp;</a></span>removeSpecies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species.html">Species</a> * Model::removeSpecies </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_species.html">Species</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_species.html">Species</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species.html">Species</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a4ccf42b641ee15d27f607ab2da39c1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccf42b641ee15d27f607ab2da39c1d6">&#9670;&nbsp;</a></span>removeSpeciesType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_type.html">SpeciesType</a> * Model::removeSpeciesType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_species_type.html">SpeciesType</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_species_type.html">SpeciesType</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_type.html">SpeciesType</a> object removed, or <code>NULL</code> if no <a class="el" href="class_species_type.html">SpeciesType</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="a3969f7d363f99f87b94d23e200c64203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3969f7d363f99f87b94d23e200c64203">&#9670;&nbsp;</a></span>removeSpeciesType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_species_type.html">SpeciesType</a> * Model::removeSpeciesType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_species_type.html">SpeciesType</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_species_type.html">SpeciesType</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_species_type.html">SpeciesType</a> object removed, or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a40dba8a849dbda05d3f9f42000119dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dba8a849dbda05d3f9f42000119dc5">&#9670;&nbsp;</a></span>removeTopLevelAnnotationElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::removeTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>elementURI</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-level element within the "annotation" subelement of this SBML object with the given name and optional URI. </p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>Calling this method allows a particular annotation element to be removed whilst the remaining annotations remain intact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>a string representing the name of the top level annotation element that is to be removed. </td></tr>
    <tr><td class="paramname">elementURI</td><td>an optional string that is used to check both the name and URI of the top level element to be removed. </td></tr>
    <tr><td class="paramname">removeEmpty</td><td>if after removing of the element, the annotation is empty, and the removeEmpty argument is true, the annotation node will be deleted (default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dae07dbe0754cce77c772d3f19e257101e">LIBSBML_ANNOTATION_NAME_NOT_FOUND</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daa4232e6e18957883269dc412ad7a0479">LIBSBML_ANNOTATION_NS_NOT_FOUND</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const XMLNode *)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a id="a6e9fd5f9e77f064198baaab4ae6f271c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9fd5f9e77f064198baaab4ae6f271c">&#9670;&nbsp;</a></span>removeUnitDefinition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::removeUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object with the given identifier from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object removed, or <code>NULL</code> if no <a class="el" href="class_unit_definition.html">UnitDefinition</a> object with the identifier exists in this <a class="el" href="class_model.html">Model</a> object. </dd></dl>

</div>
</div>
<a id="aa4b3f619f68171eeb1a90948d4cad653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b3f619f68171eeb1a90948d4cad653">&#9670;&nbsp;</a></span>removeUnitDefinition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition.html">UnitDefinition</a> * Model::removeUnitDefinition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the nth <a class="el" href="class_unit_definition.html">UnitDefinition</a> object from this <a class="el" href="class_model.html">Model</a> object and returns a pointer to it. </p>
<p>The caller owns the returned object and is responsible for deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_unit_definition.html">UnitDefinition</a> object removed., or <code>NULL</code> if the given index is out of range. </dd></dl>

</div>
</div>
<a id="a4df4f196b8e11d08013c436c689465a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df4f196b8e11d08013c436c689465a5">&#9670;&nbsp;</a></span>renameMetaIdRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::renameMetaIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section user"><dt></dt><dd>Replaces all uses of a given meta identifier attribute value with another value.</dd></dl>
<dl class="section user"><dt></dt><dd>In SBML, object "meta" identifiers are of the XML data type <code>ID</code>; the SBML object attribute itself is typically named <code>metaid</code>. All attributes that hold values <em>referring</em> to values of type <code>ID</code> are of the XML data type <code>IDREF</code>. They are also sometimes informally referred to as "metaid refs", in analogy to the SBML-defined type <code>SIdRef</code>.</dd></dl>
<p>This method works by looking at all meta-identifier attribute values, comparing the identifiers to the value of <code>oldid</code>. If any matches are found, the matching identifiers are replaced with <code>newid</code>. The method does <em>not</em> descend into child elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_graphical_object.html#ac41980f09dbc1950f6b23c6d3b624692">GraphicalObject</a>, and <a class="el" href="class_port.html#aefdef35fefbf7846d0ba8ad9c3ea4af4">Port</a>.</p>

</div>
</div>
<a id="a6a7a74b199478041720566163c8af8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7a74b199478041720566163c8af8b5">&#9670;&nbsp;</a></span>renameSIdRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::renameSIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section user"><dt></dt><dd>Replaces all uses of a given <code>SIdRef</code> type attribute value with another value.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>In SBML, object identifiers are of a data type called <code>SId</code>. In SBML Level&#160;3, an explicit data type called <code>SIdRef</code> was introduced for attribute values that refer to <code>SId</code> values; in previous Levels of SBML, this data type did not exist and attributes were simply described to as "referring to an identifier", but the effective data type was the same as <code>SIdRef</code> in Level&#160;3. These and other methods of libSBML refer to the type <code>SIdRef</code> for all Levels of SBML, even if the corresponding SBML specification did not explicitly name the data type.</p>
<p>This method works by looking at all attributes and (if appropriate) mathematical formulas in MathML content, comparing the referenced identifiers to the value of <code>oldid</code>. If any matches are found, the matching values are replaced with <code>newid</code>. The method does <em>not</em> descend into child elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a8509f3b2aa4f0298f734d73a5aee09bb">SBase</a>.</p>

</div>
</div>
<a id="aaa729273b3b16be1eb75bff041b149c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa729273b3b16be1eb75bff041b149c5">&#9670;&nbsp;</a></span>renameUnitSIdRefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::renameUnitSIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section user"><dt></dt><dd>Replaces all uses of a given <code>UnitSIdRef</code> type attribute value with another value.</dd></dl>
<dl class="section user"><dt></dt><dd>In SBML, unit definitions have identifiers of type <code>UnitSId</code>. In SBML Level&#160;3, an explicit data type called <code>UnitSIdRef</code> was introduced for attribute values that refer to <code>UnitSId</code> values; in previous Levels of SBML, this data type did not exist and attributes were simply described to as "referring to a unit identifier", but the effective data type was the same as <code>UnitSIdRef</code> in Level&#160;3. These and other methods of libSBML refer to the type <code>UnitSIdRef</code> for all Levels of SBML, even if the corresponding SBML specification did not explicitly name the data type.</dd></dl>
<p>This method works by looking at all unit identifier attribute values (including, if appropriate, inside mathematical formulas), comparing the referenced unit identifiers to the value of <code>oldid</code>. If any matches are found, the matching values are replaced with <code>newid</code>. The method does <em>not</em> descend into child elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#aac93855c11d3e29c120fad461d6cab80">SBase</a>.</p>

</div>
</div>
<a id="a21580da1d75f4782effcc57b45ed37c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21580da1d75f4782effcc57b45ed37c8">&#9670;&nbsp;</a></span>replaceTopLevelAnnotationElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::replaceTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied. </p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>This method determines the name of the element to be replaced from the annotation argument. Functionally it is equivalent to calling <code> removeTopLevelAnnotationElement(name)</code> followed by calling <code>appendAnnotation(annotation_with_name)</code>, with the exception that the placement of the annotation element remains the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>string representing the replacement top level annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>removeTopLevelAnnotationElement(const std::string elementName, const std::string elementURI) </dd>
<dd>
<a class="el" href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const XMLNode*)</a> </dd></dl>

</div>
</div>
<a id="a14876bd1b05a660593ed2cf46aece3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14876bd1b05a660593ed2cf46aece3ee">&#9670;&nbsp;</a></span>replaceTopLevelAnnotationElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::replaceTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied. </p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>This method determines the name of the element to be replaced from the annotation argument. Functionally it is equivalent to calling <code> removeTopLevelAnnotationElement(name)</code> followed by calling <code>appendAnnotation(annotation_with_name)</code>, with the exception that the placement of the annotation element remains the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td><a class="el" href="class_x_m_l_node.html">XMLNode</a> representing the replacement top level annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>removeTopLevelAnnotationElement(const std::string elementName, const std::string elementURI, bool removeEmpty) </dd>
<dd>
<a class="el" href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a id="a99d849cf4973bd4eef2dc69a16c69a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d849cf4973bd4eef2dc69a16c69a75">&#9670;&nbsp;</a></span>setAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "annotation" subelement of this SBML object to a copy of <code>annotation</code>. </p>
<p>Any existing content of the "annotation" subelement is discarded. Unless you have taken steps to first copy and reconstitute any existing annotations into the <code>annotation</code> that is about to be assigned, it is likely that performing such wholesale replacement is unfriendly towards other software applications whose annotations are discarded. An alternative may be to use <a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML string that is to be used as the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f">SBase</a>.</p>

</div>
</div>
<a id="a440da667491f2a78fa305460a63471a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440da667491f2a78fa305460a63471a5">&#9670;&nbsp;</a></span>setAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "annotation" subelement of this SBML object to a copy of <code>annotation</code>. </p>
<p>Any existing content of the "annotation" subelement is discarded. Unless you have taken steps to first copy and reconstitute any existing annotations into the <code>annotation</code> that is about to be assigned, it is likely that performing such wholesale replacement is unfriendly towards other software applications whose annotations are discarded. An alternative may be to use <a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML structure that is to be used as the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125">SBase</a>.</p>

</div>
</div>
<a id="a5879a7f61af9d05faa6d3bdc0ff249a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5879a7f61af9d05faa6d3bdc0ff249a0">&#9670;&nbsp;</a></span>setAreaUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setAreaUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new areaUnits for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "areaUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a61985d3d3299d76b51d044a1d767947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61985d3d3299d76b51d044a1d767947d">&#9670;&nbsp;</a></span>setConversionFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setConversionFactor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new conversionFactor for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "conversionFactor" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a19efde8c152ee942e6d86d591a45ff0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19efde8c152ee942e6d86d591a45ff0d">&#9670;&nbsp;</a></span>setCreatedDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setCreatedDate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_date.html">Date</a> *&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the creation date of the <a class="el" href="class_model_history.html">ModelHistory</a> of this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>a <a class="el" href="class_date.html">Date</a> object representing the date to which the "created
date" portion of this <a class="el" href="class_model_history.html">ModelHistory</a> should be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa78ef1ca7e89aa9be18302622aad221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78ef1ca7e89aa9be18302622aad221f">&#9670;&nbsp;</a></span>setElementText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::setElementText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When overridden allows <a class="el" href="class_s_base.html">SBase</a> elements to use the text included in between the elements tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the text string found between the element tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43382ec1685bdbb9bf06ed496f4e48b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43382ec1685bdbb9bf06ed496f4e48b8">&#9670;&nbsp;</a></span>setExtentUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setExtentUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new extentUnits for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "extentUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a9f5805553e7d385ced27c4065fa190fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5805553e7d385ced27c4065fa190fe">&#9670;&nbsp;</a></span>setId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "id" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section user"><dt></dt><dd>The string <code>sid</code> is copied.</dd></dl>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the string to use as the identifier of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#ac9f9a3703526cd1fb929778df3050692">SBase</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a3">createExampleSBML.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#a5">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#a6">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#a13">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#a10">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#a4">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#a6">example3.cpp</a>, <a class="el" href="groups_example2_8cpp-example.html#a5">groups_example2.cpp</a>, <a class="el" href="spec_example1_8cpp-example.html#a9">spec_example1.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#a14">spec_example3.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a9">spec_example4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8a342a0f8387842fb6700c50c4c43344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a342a0f8387842fb6700c50c4c43344">&#9670;&nbsp;</a></span>setIdAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setIdAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "id" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The string <code>sid</code> is copied.</dd></dl>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the string to use as the identifier of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd></dl>

</div>
</div>
<a id="aabfe991b74504663e0314298a6281fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfe991b74504663e0314298a6281fef">&#9670;&nbsp;</a></span>setLengthUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setLengthUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new lengthUnits for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "lengthUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a050779a94ecdb2d73d7edfef73bc1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050779a94ecdb2d73d7edfef73bc1e55">&#9670;&nbsp;</a></span>setMetaId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the meta-identifier attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<p>The string <code>metaid</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>the identifier string to use as the value of the "metaid" attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4" title="Returns the value of the &quot;metaid&quot; attribute of this SBML object.">getMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a7b43de27cb29136954af762fa91d4842" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set.">isSetMetaId()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adding_evidence_codes_1_8cpp-example.html#a9">addingEvidenceCodes_1.cpp</a>, and <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a9">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aef0ea49f9a3ad67d72edb2c1cf92ad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0ea49f9a3ad67d72edb2c1cf92ad82">&#9670;&nbsp;</a></span>setModelHistory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setModelHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_model_history.html">ModelHistory</a> *&#160;</td>
          <td class="paramname"><em>history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="class_model_history.html">ModelHistory</a> of this object. </p>
<p>The content of <code>history</code> is copied, and this object's existing model history content is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td><a class="el" href="class_model_history.html">ModelHistory</a> of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="add_model_history_8cpp-example.html#a18">addModelHistory.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa9f4b34956328dece618208f1f61f8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f4b34956328dece618208f1f61f8e8">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "name" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>The string in <code>name</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name for the SBML object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a1531f729b16689aba3fb7f3567202a7c">SBase</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="spec_example1_8cpp-example.html#a10">spec_example1.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a10">spec_example4.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7a6dc5a02be520ea43c7cf71c5062c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6dc5a02be520ea43c7cf71c5062c71">&#9670;&nbsp;</a></span>setNamespaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setNamespaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>xmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the namespaces relevant of this SBML object. </p>
<p>The content of <code>xmlns</code> is copied, and this object's existing namespace content is deleted.</p>
<p>The <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmlns</td><td>the namespaces to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a478ad1e0e2bb2dc27a9de6ab9bac4bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478ad1e0e2bb2dc27a9de6ab9bac4bf2">&#9670;&nbsp;</a></span>setNotes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setNotes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>notes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addXHTMLMarkup</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "notes" subelement of this SBML object to a copy of the string <code>notes</code>. </p>
<p>The content of <code>notes</code> is copied, and any existing content of this object's "notes" subelement is deleted.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>The following code illustrates a very simple way of setting the notes using this method. Here, the object being annotated is the whole SBML document, but that is for illustration purposes only; you could of course use this same approach to annotate any other SBML component. </p><div class="fragment"><div class="line"><a class="code" href="class_s_b_m_l_document.html">SBMLDocument</a>* s = <span class="keyword">new</span> <a class="code" href="class_model.html#a878bda56c626c699ffa01db2d09386b1">SBMLDocument</a>(3, 1);</div>
<div class="line">s-&gt;<a class="code" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e">setNotes</a>(<span class="stringliteral">&quot;&lt;body xmlns=&#39;http://www.w3.org/1999/xhtml&#39;&gt;&lt;p&gt;here is my note&lt;/p&gt;&lt;/body&gt;&quot;</span>);</div>
<div class="ttc" id="aclass_s_base_html_a611a4bd98a4e32e3573980b2481ce77e"><div class="ttname"><a href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e">SBase::setNotes</a></div><div class="ttdeci">int setNotes(const XMLNode *notes)</div><div class="ttdoc">Sets the value of the &quot;notes&quot; subelement of this SBML object.</div><div class="ttdef"><b>Definition:</b> SBase.cpp:1775</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML string that is to be used as the content of the "notes" subelement of this object.</td></tr>
    <tr><td class="paramname">addXHTMLMarkup</td><td>a boolean indicating whether to wrap the contents of the <code>notes</code> argument with XHTML paragraph (<code>&lt;p&gt;</code>) tags. This is appropriate when the string in <code>notes</code> does not already containg the appropriate XHTML markup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a id="a611a4bd98a4e32e3573980b2481ce77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a4bd98a4e32e3573980b2481ce77e">&#9670;&nbsp;</a></span>setNotes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setNotes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>notes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "notes" subelement of this SBML object. </p>
<p>The content of <code>notes</code> is copied, and any existing content of this object's "notes" subelement is deleted.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML structure that is to be used as the content of the "notes" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object.">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a52">createExampleSBML.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7b7b199563437a7977cc13cabb21ef63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7b199563437a7977cc13cabb21ef63">&#9670;&nbsp;</a></span>setSBOTerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setSBOTerm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sboid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "sboTerm" attribute by string. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sboid</td><td>the <a class="el" href="class_s_b_o.html">SBO</a> identifier string of the form "SBO:NNNNNNN".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a37287e48bd51353012b74e4d200bb446" title="Sets the value of the &quot;sboTerm&quot; attribute.">setSBOTerm(int value)</a> </dd></dl>

</div>
</div>
<a id="a37287e48bd51353012b74e4d200bb446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37287e48bd51353012b74e4d200bb446">&#9670;&nbsp;</a></span>setSBOTerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setSBOTerm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "sboTerm" attribute. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the NNNNNNN integer portion of the <a class="el" href="class_s_b_o.html">SBO</a> identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7b7b199563437a7977cc13cabb21ef63" title="Sets the value of the &quot;sboTerm&quot; attribute by string.">setSBOTerm(const std::string &amp;sboid)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="groups_example1_8cpp-example.html#a24">groups_example1.cpp</a>, and <a class="el" href="qual_example1_8cpp-example.html#a22">qual_example1.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afe440b6a3a9c0495ca5474d954014814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe440b6a3a9c0495ca5474d954014814">&#9670;&nbsp;</a></span>setSubstanceUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setSubstanceUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new substanceUnits for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "substanceUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a43130571e9b2674460d0b66bdb57492a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43130571e9b2674460d0b66bdb57492a">&#9670;&nbsp;</a></span>setTimeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setTimeUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new timeUnits for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "timeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="ac3b1bbfe22bad0dbc577b61c529f37bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b1bbfe22bad0dbc577b61c529f37bb">&#9670;&nbsp;</a></span>setUserData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the user data of this element. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>specifies the new user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a719794fd221fad50d609307424fee4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719794fd221fad50d609307424fee4db">&#9670;&nbsp;</a></span>setVolumeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::setVolumeUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<p>The string in <code>units</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>the new volumeUnits for the <a class="el" href="class_model.html">Model</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "volumeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="ae8317d5157b70e4f1bc68e33e5c84001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8317d5157b70e4f1bc68e33e5c84001">&#9670;&nbsp;</a></span>toSBML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SBase::toSBML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string consisting of a partial SBML corresponding to just this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the partial SBML that describes this SBML object.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This is primarily provided for testing and debugging purposes. It may be removed in a future version of libSBML.</span> </dd></dl>

</div>
</div>
<a id="a5c949d524aca47b84b18b57b76e6ee0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c949d524aca47b84b18b57b76e6ee0a">&#9670;&nbsp;</a></span>toXMLNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a>* SBase::toXMLNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this element as an <a class="el" href="class_x_m_l_node.html">XMLNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>this element as an <a class="el" href="class_x_m_l_node.html">XMLNode</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This operation is computationally expensive, because the element has to be fully serialized to a string and then parsed into the <a class="el" href="class_x_m_l_node.html">XMLNode</a> structure. Attempting to convert a large tree structure (e.g., a large <a class="el" href="class_model.html">Model</a>) may consume significant computer memory and time.</span> </dd></dl>

</div>
</div>
<a id="a9121d6a4f7401fe957cc75647a1e95ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9121d6a4f7401fe957cc75647a1e95ed">&#9670;&nbsp;</a></span>unsetAnnotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "annotation" subelement of this SBML object. </p>
<p>Whereas the <a class="el" href="class_s_base.html">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a5af865a159b3b1c5a16729bce7e4e3c2" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object to a copy of annotation.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1" title="Appends annotation content to any existing content in the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="unset_annotation_8cpp-example.html#a7">unsetAnnotation.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aab42860039f74658ed3f79090e253ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab42860039f74658ed3f79090e253ae8">&#9670;&nbsp;</a></span>unsetAreaUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetAreaUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "areaUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "areaUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a51c0a07389748680d3ab9e5cf14a2496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c0a07389748680d3ab9e5cf14a2496">&#9670;&nbsp;</a></span>unsetConversionFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetConversionFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "conversionFactor" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "conversionFactor" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="ad3be0bf5891c2b6bf4340cce12b8630f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3be0bf5891c2b6bf4340cce12b8630f">&#9670;&nbsp;</a></span>unsetCreatedDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetCreatedDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the created date of the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a1e89a7890f2fb291f1ba4c38866d1dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e89a7890f2fb291f1ba4c38866d1dcc">&#9670;&nbsp;</a></span>unsetCVTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the list of <a class="el" href="class_c_v_term.html">CVTerm</a> objects attached to this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad5a19664845edfb52701aeb2dc70cf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a19664845edfb52701aeb2dc70cf3c">&#9670;&nbsp;</a></span>unsetExtentUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetExtentUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "extentUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "extentUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a03389e655c02bcd4059098281272ecf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03389e655c02bcd4059098281272ecf3">&#9670;&nbsp;</a></span>unsetId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "id" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html">InitialAssignment</a>, <a class="el" href="class_event_assignment.html">EventAssignment</a>, <a class="el" href="class_assignment_rule.html">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a> would always return an empty string, and <a class="el" href="class_model.html#ae9a90c5f7f69760983ed2579b14e68ce" title="Predicate returning true if this Model&#39;s &quot;id&quot; attribute is set.">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute()</a>, <a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_model.html#af231d01db6a91e25812995f524476b75" title="Returns the value of the &quot;id&quot; attribute of this Model.">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object.">unsetIdAttribute()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a65f77b6aa5f6f5d80b2d01558f7496f5">SBase</a>.</p>

</div>
</div>
<a id="a1bfd93ef72d0f624964fcfd7a8d5cdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfd93ef72d0f624964fcfd7a8d5cdfb">&#9670;&nbsp;</a></span>unsetIdAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetIdAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "id" attribute of this SBML object. </p>
<p>Most (but not all) objects in SBML include two common attributes: "id" and "name". The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad5ffefa4d9901ca0d55f2343c08bb057" title="Returns the value of the &quot;id&quot; attribute of this SBML object.">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object.">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9fb99b60d2f2f0427e818187cc6f6ad9" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set.">isSetIdAttribute()</a> </dd></dl>

</div>
</div>
<a id="a09b73768cae68ef60f560cd2a62ea6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b73768cae68ef60f560cd2a62ea6a1">&#9670;&nbsp;</a></span>unsetLengthUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetLengthUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "lengthUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "lengthUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="a98c955421c92c28351610ea811ecb4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c955421c92c28351610ea811ecb4fe">&#9670;&nbsp;</a></span>unsetMetaId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "metaid" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa197c1c8a34df2cbd05a58f6cbc41841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa197c1c8a34df2cbd05a58f6cbc41841">&#9670;&nbsp;</a></span>unsetModelHistory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a07fe8dd8b43718fbb3d0df8481c72058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fe8dd8b43718fbb3d0df8481c72058">&#9670;&nbsp;</a></span>unsetModifiedDates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetModifiedDates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the modified dates of the <a class="el" href="class_model_history.html">ModelHistory</a> object attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html">SBase</a>. </dd></dl>

</div>
</div>
<a id="a1c272e1c5658984d36c2db89a66b0af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c272e1c5658984d36c2db89a66b0af8">&#9670;&nbsp;</a></span>unsetName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "name" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;3 Version&#160;2, the "id" and "name" attributes were moved to <a class="el" href="class_s_base.html">SBase</a> directly, instead of being defined individually for many (but not all) objects. LibSBML has for a long time provided functions defined on <a class="el" href="class_s_base.html">SBase</a> itself to get, set, and unset those attributes, which would fail or otherwise return empty strings if executed on any object for which those attributes were not defined. Now that all <a class="el" href="class_s_base.html">SBase</a> objects define those attributes, those functions now succeed for any object with the appropriate level and version.</dd></dl>
<p>The "name" attribute is optional and is not intended to be used for cross-referencing purposes within a model. Its purpose instead is to provide a human-readable label for the component. The data type of "name" is the type <code>string</code> defined in XML Schema. SBML imposes no restrictions as to the content of "name" attributes beyond those restrictions defined by the <code>string</code> type in XML Schema.</p>
<p>The recommended practice for handling "name" is as follows. If a software tool has the capability for displaying the content of "name" attributes, it should display this content to the user as a component's label instead of the component's "id". If the user interface does not have this capability (e.g., because it cannot display or use special characters in symbol names), or if the "name" attribute is missing on a given component, then the user interface should display the value of the "id" attribute instead. (Script language interpreters are especially likely to display "id" instead of "name".)</p>
<p>As a consequence of the above, authors of systems that automatically generate the values of "id" attributes should be aware some systems may display the "id"'s to the user. Authors therefore may wish to take some care to have their software create "id" values that are: (a) reasonably easy for humans to type and read; and (b) likely to be meaningful, for example by making the "id" attribute be an abbreviated form of the name attribute value.</p>
<p>An additional point worth mentioning is although there are restrictions on the uniqueness of "id" values, there are no restrictions on the uniqueness of "name" values in a model. This allows software applications leeway in assigning component identifiers.</p>
<p>Regardless of the level and version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have names). If the object in question does not posess a "name" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the name to be set, nor will it read or write "name" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_model.html#ac2792c4eb1d7509af701f555290c3890" title="Returns the value of the &quot;name&quot; attribute of this Model object.">getName()</a> </dd>
<dd>
<a class="el" href="class_model.html#aa9f4b34956328dece618208f1f61f8e8" title="Sets the value of the &quot;name&quot; attribute of this Model.">setName(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_model.html#aa0c315424f527945e40d9a48a530b786" title="Predicate returning true if this Model&#39;s &quot;name&quot; attribute is set.">isSetName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a4cf8825fb83925a508eaac3d7f8fbb8c">SBase</a>.</p>

</div>
</div>
<a id="a89f626f2593df8e83da4cdbfe79142f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f626f2593df8e83da4cdbfe79142f7">&#9670;&nbsp;</a></span>unsetNotes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "notes" subelement of this SBML object. </p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a83909a09abfab77fea3429482c79e867" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object.">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content.">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="unset_notes_8cpp-example.html#a7">unsetNotes.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a317ea060a5c3f97576188a22e670e683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317ea060a5c3f97576188a22e670e683">&#9670;&nbsp;</a></span>unsetSBOTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetSBOTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "sboTerm" attribute of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2d379051ccef5502024d901974d9b98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d379051ccef5502024d901974d9b98f">&#9670;&nbsp;</a></span>unsetSubstanceUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetSubstanceUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "substanceUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "substanceUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="aa9936186fb483098b3eb6060158ab93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9936186fb483098b3eb6060158ab93b">&#9670;&nbsp;</a></span>unsetTimeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetTimeUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "timeUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "timeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<a id="abd78c4290e103245ce49b92b5e229375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd78c4290e103245ce49b92b5e229375">&#9670;&nbsp;</a></span>unsetUserData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the user data of this element. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aadb2a632640d14bb5d40b3db0212822e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb2a632640d14bb5d40b3db0212822e">&#9670;&nbsp;</a></span>unsetVolumeUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::unsetVolumeUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "volumeUnits" attribute of this <a class="el" href="class_model.html">Model</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes.">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "volumeUnits" attribute is available in SBML Level&#160;3 but is not present on <a class="el" href="class_model.html">Model</a> in lower Levels of SBML. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a878bda56c626c699ffa01db2d09386b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878bda56c626c699ffa01db2d09386b1">&#9670;&nbsp;</a></span>SBMLDocument</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
