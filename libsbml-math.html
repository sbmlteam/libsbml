<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>libSBML C++ API: Working with math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.20.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('libsbml-math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Working with math </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#math-overview">Basic concepts</a></li>
<li class="level1"><a href="#math-convert">Converting between ASTs and text strings</a></li>
<li class="level1"><a href="#math-diffs">The text-string formula syntax, and differences with MathML</a><ul><li class="level2"><a href="#math-original">Simpler scheme based on SBML Level&nbsp;1&#39;s syntax</a></li>
<li class="level2"><a href="#math-l3">Advanced, SBML Level 3-oriented formula scheme</a></li>
</ul>
</li>
<li class="level1"><a href="#math-ast">Methods for working directly with libSBML&#39;s Abstract Syntax Trees</a></li>
<li class="level1"><a href="#math-reading">Reading and Writing MathML directly</a></li>
</ul>
</div>
<div class="textblock"><p>This section describes libSBML's facilities for working with SBML representations of mathematical expressions.</p>
<p>Internally, libSBML uses <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">Abstract Syntax Trees</a> (ASTs) to provide a canonical, in-memory representation for all mathematical formulas regardless of their original format (i.e., C-like infix text strings or the XML-based <a href="http://www.w3.org/TR/MathML2/" target="_blank">MathML&#160;2.0</a> format). LibSBML provides an extensive API for working with ASTs; it also provides facilities for translating between ASTs and mathematical formulas writing in a text-string notation, as well as translating between ASTs and MathML.</p>
<h1><a class="anchor" id="math-overview"></a>
Basic concepts</h1>
<dl class="section user"><dt></dt><dd>An AST <em>node</em> in libSBML is a recursive tree structure; each node has a type, a pointer to a value, and a list of children nodes. Each <a class="el" href="class_a_s_t_node.html">ASTNode</a> node may have none, one, two, or more children depending on its type. There are node types to represent numbers (with subtypes to distinguish integer, real, and rational numbers), names (e.g., constants or variables), simple mathematical operators, logical or relational operators and functions. The following diagram illustrates an example of how the mathematical expression <code>"1 + 2"</code> is represented as an AST with one <em>plus</em> node having two <em>integer</em> children nodes for the numbers <code>1</code> and <code>2</code>. The figure also shows the corresponding MathML representation:</dd></dl>
<table border="0" class="centered text-table width80 normal-font" style="padding-bottom: 0.5em">
<caption class="top-caption">Example AST representation of a mathematical expression.</caption>
<tr>
<th width="50px">Infix</th>
<th>AST</th>
<th>MathML</th>
</tr>
<tr>
<td valign="middle" align="center">
<code>1 + 2</code>
</td>
<td valign="middle">
  <object type="image/svg+xml" data="simple-ast.svg" class="centered" width="140px"></object>
</td>
<td valign="middle">
<code>&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;</code><br>
<code>&nbsp;&nbsp;&lt;apply&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;plus/&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 1 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;cn type="integer"&gt; 2 &lt;/cn&gt;</code><br>
<code>&nbsp;&nbsp;&lt;/apply&gt;</code><br>
<code>&lt;/math&gt;</code>
</td>
</tr>
</table>
<p>The following are other noteworthy points about the AST representation in libSBML:</p>
<ul>
<li>A numerical value represented in MathML as a real number with an exponent is preserved as such in the AST node representation, even if the number could be stored in a <code>double</code> data type. This is done so that when an SBML model is read in and then written out again, the amount of change introduced by libSBML to the SBML during the round-trip activity is minimized.</li>
</ul>
<ul>
<li>Rational numbers are represented in an AST node using separate numerator and denominator values. These can be retrieved using the methods <a class="el" href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee" title="Returns the value of the numerator of this node if of type AST_RATIONAL, or the numerical value of th...">ASTNode::getNumerator()</a> and <a class="el" href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6" title="Returns the value of the denominator of this node.">ASTNode::getDenominator()</a>.</li>
</ul>
<ul>
<li>The children of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> are other <a class="el" href="class_a_s_t_node.html">ASTNode</a> objects. The list of children is empty for nodes that are leaf elements, such as numbers. For nodes that are actually roots of expression subtrees, the list of children points to the parsed objects that make up the rest of the expression.</li>
</ul>
<p>For many applications, the details of ASTs are irrelevant because libSBML provides text-string based translation functions such as <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a> and <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a>. If you find the complexity of using the AST representation of expressions too high for your purposes, perhaps the string-based functions will be more suitable.</p>
<h1><a class="anchor" id="math-convert"></a>
Converting between ASTs and text strings</h1>
<p>SBML Levels 2 and 3 represent mathematical expressions using using <a href="http://www.w3.org/Math/">MathML&#160;2.0</a> (more specifically, a subset of the <em>content</em> portion of MathML&#160;2.0), but most applications using libSBML do not use MathML directly. Instead, applications generally interact with mathematics using either the API for Abstract Syntax Trees (described below), or using libSBML's facilities for encoding and decoding mathematical formulas to/from text strings. The latter is simpler to use directly, so we describe it first.</p>
<p>The libSBML formula parser has been carefully engineered so that transformations from MathML to the libSBML infix text notation <em>and back</em> is possible with a minimum of disruption to the structure of the mathematical expression. The example below shows a simple program that, when run, takes a MathML string compiled into the program, converts it to an AST, converts <em>that</em> to an infix representation of the formula, compares it to the expected form of that formula, and finally translates that formula back to MathML and displays it. The output displayed on the terminal should have the same structure as the MathML it started with. The program is a simple example of using libSBML's basic MathML and AST reading and writing methods, and shows that libSBML preserves the ordering and structure of the mathematical expressions.</p>
<p><a class="anchor" id="example-program"></a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_s_b_m_l_types_8h.html">sbml/SBMLTypes.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* expected = <span class="stringliteral">&quot;1 + f(x)&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;&lt;math xmlns=&#39;http://www.w3.org/1998/Math/MathML&#39;&gt;&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  &lt;apply&gt; &lt;plus/&gt; &lt;cn&gt; 1 &lt;/cn&gt;&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;                  &lt;apply&gt; &lt;ci&gt; f &lt;/ci&gt; &lt;ci&gt; x &lt;/ci&gt; &lt;/apply&gt;&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;  &lt;/apply&gt;&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;&lt;/math&gt;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_a_s_t_node.html">ASTNode</a>* ast    = <a class="code" href="_math_m_l_8cpp.html#a0fb4f7430eb05834379253ce3611a00a">readMathMLFromString</a>(s);</div>
<div class="line">  <span class="keywordtype">char</span>*    result = <a class="code" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19">SBML_formulaToL3String</a>(ast);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> ( strcmp(result, expected) == 0 )</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Got expected result&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Mismatch after readMathMLFromString()&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_a_s_t_node.html">ASTNode</a>* new_mathml = <a class="code" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8">SBML_parseL3Formula</a>(result);</div>
<div class="line">  <span class="keywordtype">char</span>*    new_s      = <a class="code" href="_math_m_l_8cpp.html#a539b72bb51b93224ed973436a4add6a4">writeMathMLToString</a>(new_mathml);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Result of writing AST:&quot;</span> &lt;&lt; std::endl &lt;&lt; new_s &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="a_l3_formula_formatter_8h_html_a3ee99a0498b6249f6602b98be6733b19"><div class="ttname"><a href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19">SBML_formulaToL3String</a></div><div class="ttdeci">char * SBML_formulaToL3String(const ASTNode_t *tree)</div><div class="ttdoc">Converts an AST to a string representation of a formula using a syntax derived from SBML Level&amp;#160;1,...</div></div>
<div class="ttc" id="a_l3_parser_8cpp_html_a58e584e7c21801b34d79fed7a7c05ac8"><div class="ttname"><a href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8">SBML_parseL3Formula</a></div><div class="ttdeci">ASTNode_t * SBML_parseL3Formula(const char *formula)</div><div class="ttdoc">Parses a text string as a mathematical formula and returns an AST representation of it.</div><div class="ttdef"><b>Definition:</b> L3Parser.cpp:3235</div></div>
<div class="ttc" id="a_math_m_l_8cpp_html_a0fb4f7430eb05834379253ce3611a00a"><div class="ttname"><a href="_math_m_l_8cpp.html#a0fb4f7430eb05834379253ce3611a00a">readMathMLFromString</a></div><div class="ttdeci">ASTNode_t * readMathMLFromString(const char *xml)</div><div class="ttdoc">Reads the MathML from the given XML string, constructs a corresponding abstract syntax tree,...</div><div class="ttdef"><b>Definition:</b> MathML.cpp:2273</div></div>
<div class="ttc" id="a_math_m_l_8cpp_html_a539b72bb51b93224ed973436a4add6a4"><div class="ttname"><a href="_math_m_l_8cpp.html#a539b72bb51b93224ed973436a4add6a4">writeMathMLToString</a></div><div class="ttdeci">char * writeMathMLToString(const ASTNode *node)</div><div class="ttdef"><b>Definition:</b> MathML.cpp:2428</div></div>
<div class="ttc" id="a_s_b_m_l_types_8h_html"><div class="ttname"><a href="_s_b_m_l_types_8h.html">SBMLTypes.h</a></div><div class="ttdoc">Include all SBML types in a single header file.</div></div>
<div class="ttc" id="aclass_a_s_t_node_html"><div class="ttname"><a href="class_a_s_t_node.html">ASTNode</a></div><div class="ttdef"><b>Definition:</b> ASTNode.h:221</div></div>
</div><!-- fragment --><p>The text-string form of mathematical formulas written by <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a>, and read by <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> and <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a>, use a simple C-inspired infix notation. It is summarized in the next section below. A formula in this text-string form therefore can be handed to a program that understands SBML mathematical expressions, or used as part of a translation system.</p>
<h1><a class="anchor" id="math-diffs"></a>
The text-string formula syntax, and differences with MathML</h1>
<p>There are actually two text-based formula parsing/writing systems in libSBML: one that uses a more limited syntax and was originally designed for translation between SBML Level&#160;1 (which used a text-string format for representing mathematics) and higher levels of SBML, and a more recent, more powerful version that offers features to support SBML Level&#160;3. We describe both below, beginning with the simpler but more limited system.</p>
<h2><a class="anchor" id="math-original"></a>
Simpler scheme based on SBML Level 1's syntax</h2>
<p>The simpler, more limited translation system is read by <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> and written by <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>. It uses an infix notation essentially derived from the syntax of the C programming language and was originally used in SBML Level&#160;1. We summarize the syntax here, but for more complete details, readers should consult the documentation for <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a>.</p>
<p>Formula strings in this infix notation may contain operators, function calls, symbols, and white space characters. The allowable white space characters are tab and space. The following are illustrative examples of formulas expressed in the syntax:</p>
<pre class="fragment">0.10 * k4^2
</pre> <pre class="fragment">(vm * s1)/(km + s1)
</pre><p>The following table shows the precedence rules in this syntax. In the Class column, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the Precedence column show how the order of different types of operation are determined. For example, the expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> because the <code>*</code> operator has higher precedence. The Associates column shows how the order of similar precedence operations is determined; for example, <code>a - b + c</code> is evaluated as <code>(a - b) + c</code> because the <code>+</code> and <code>-</code> operators are left-associative. The precedence and associativity rules are taken from the C programming language, except for the symbol <code>^</code>, which is used in C for a different purpose. (Exponentiation can be invoked using either <code>^</code> or the function <code>power</code>.)</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors" style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Precedence</th>
     <th align="left">Associates</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">6</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">6</td><td>left</td></tr>
<tr><td><code>-</code></td><td>negation</td><td>unary</td><td align="center">5</td><td>right</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>/</code></td><td>divison</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>+</code></td><td>addition</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>
<caption class="top-caption">A table of the expression operators and their precedence in the
text-string format for mathematical expressions used by SBML_parseFormula().
</caption>
</table>

<p>A program parsing a formula in an SBML model should assume that names appearing in the formula are the identifiers of <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_function_definition.html">FunctionDefinition</a>, (in Level&#160;2) <a class="el" href="class_reaction.html">Reaction</a>, or (in Level&#160;3) <a class="el" href="class_species_reference.html">SpeciesReference</a> objects defined in a model. When a function call is involved, the syntax consists of a function identifier, followed by optional white space, followed by an opening parenthesis, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis. There is an almost one-to-one mapping between the list of predefined functions available, and those defined in MathML. All of the MathML functions are recognized; this set is larger than the functions defined in SBML Level&#160;1. In the subset of functions that overlap between MathML and SBML Level&#160;1, there exist a few differences. The following table summarizes the differences between the predefined functions in SBML Level&#160;1 and the MathML equivalents in SBML Levels&#160;2 and&#160;3:</p>
<table border="0" class="centered text-table width80 normal-font alt-row-colors">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Text string formula functions</th>
     <th align="left">MathML equivalents in SBML Levels&nbsp;2 and&nbsp;3</th>
 </tr>
 <tr><td><code>acos</code></td><td><code>arccos</code></td></tr>
 <tr><td><code>asin</code></td><td><code>arcsin</code></td></tr>
 <tr><td><code>atan</code></td><td><code>arctan</code></td></tr>
 <tr><td><code>ceil</code></td><td><code>ceiling</code></td></tr>
 <tr><td><code>log</code></td><td><code>ln</code></td></tr>
 <tr><td><code>log10(x)</code></td><td><code>log(x)</code> or <code>log(10, x)</code></td></tr>
 <tr><td><code>pow(x, y)</code></td><td><code>power(x, y)</code></td></tr>
 <tr><td><code>sqr(x)</code></td><td><code>power(x, 2)</code></td></tr>
 <tr><td><code>sqrt(x)</code></td><td><code>root(x)</code> or <code>root(2, x)</code></td></tr>
<caption class="top-caption">Table comparing the names of certain
functions in the SBML text-string formula syntax and MathML.  The left
column shows the names of functions recognized by SBML_parseFormula(); the
right column shows their equivalent function names in MathML&nbsp;2.0, used
in SBML Levels&nbsp;2 and&nbsp;3.</caption>
</table>

<p>Note that <b>there are differences between the symbols used to represent the common mathematical functions and the corresponding MathML token names</b>. This is a potential source of incompatibilities. Note in particular that in this text-string syntax, <code>log(x)</code> always represents the natural logarithm, whereas in MathML, the natural logarithm is <code>&lt;ln/&gt;</code>. Application writers are urged to be careful when translating between text forms and MathML forms, especially if they provide a direct text-string input facility to users of their software systems. The more advanced mathematical formula system, described below, offers the ability to control how <code>log</code> is interpreted as well as other parsing behaviors.</p>
<h2><a class="anchor" id="math-l3"></a>
Advanced, SBML Level 3-oriented formula scheme</h2>
<dl class="section user"><dt></dt><dd>The text-string form of mathematical formulas read by the function <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> and written by the function <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a> uses an expanded version of the syntax read and written by <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> and <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>, respectively. The latter two libSBML functions were originally developed to support conversion between SBML Levels&#160;1 and&#160;2, and were focused on the syntax of mathematical formulas used in SBML Level&#160;1. With time, and the use of MathML in SBML Levels&#160;2 and&#160;3, it became clear that supporting Level&#160;2 and&#160;3's expanded mathematical syntax would be useful for software developers. To maintain backwards compatibility for libSBML users, the original <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a> and <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> have been left untouched, and instead, the new functionality is provided in the form of <a class="el" href="_l3_parser_8cpp.html#a58e584e7c21801b34d79fed7a7c05ac8" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseL3Formula()</a> and <a class="el" href="_l3_formula_formatter_8h.html#a3ee99a0498b6249f6602b98be6733b19" title="Converts an AST to a string representation of a formula using a syntax derived from SBML Level&#160;1,...">SBML_formulaToL3String()</a>.</dd></dl>
<p>The following lists the main differences in the formula syntax supported by the Level 3 ("L3") versions of the formula parsers and formatters, compared to what is supported by the Level&#160;1-oriented <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> and <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>:</p>
<ul>
<li>Units may be asociated with bare numbers, using the following syntax: <div style="margin: 10px auto 10px 25px; display: block"> <span class="code" style="background-color: #d0d0ee">number</span> <span class="code" style="background-color: #edd">unit</span> </div> The <span class="code" style="background-color: #d0d0ee">number</span> may be in any form (an integer, real, or rational number), and the <span class="code" style="background-color: #edd">unit</span> must conform to the syntax of an SBML identifier (technically, the type defined as <code>SId</code> in the SBML specifications). The whitespace between <span class="code" style="background-color: #d0d0ee">number</span> and <span class="code" style="background-color: #edd">unit</span> is optional.</li>
</ul>
<ul>
<li>The Boolean function symbols <code>&amp;&amp;</code> (<em>and</em>), <code>||</code> (<em>or</em>), <code>!</code> (<em>not</em>), and <code>!=</code> (<em>not</em> <em>equals</em>) may be used.</li>
</ul>
<ul>
<li>The <em>modulo</em> operation is allowed as the symbol <code>%</code> and will produce a <code>&lt;piecewise&gt;</code> function in the corresponding MathML output by default, or can produce the MathML function <code>rem</code>, depending on the <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object (see L3ParserSettings_setParseModuloL3v2() ).</li>
</ul>
<ul>
<li>All inverse trigonometric functions may be defined in the infix either using <code>arc</code> as a prefix or simply <code>a</code>; in other words, both <code>arccsc</code> and <code>acsc</code> are interpreted as the operator <em>arccosecant</em> as defined in MathML&#160;2.0. (Many functions in the simpler SBML Level&#160;1 oriented parser implemented by <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a> are defined this way as well, but not all.)</li>
</ul>
<ul>
<li>The following expression is parsed as a rational number instead of as a numerical division: <pre style="display: block; margin-left: 25px">
   (<span class="code" style="background-color: #d0d0ee">integer</span>/<span class="code" style="background-color: #d0d0ee">integer</span>)</pre> <b>Spaces are not allowed</b> in this construct; in other words, &quot;<code>(3 / 4)</code>&quot; (with whitespace between the numbers and the operator) will be parsed into the MathML <code>&lt;divide&gt;</code> construct rather than a rational number. You can, however, assign units to a rational number as a whole; here is an example: &quot;<code>(3/4) ml</code>&quot;. (In the case of division rather than a rational number, units are not interpreted in this way.)</li>
</ul>
<ul>
<li>Various parser and formatter behaviors may be altered through the use of a <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object in conjunction with the functions <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and <a class="el" href="_l3_formula_formatter_8h.html#af840d48b31961fd33c8f00a7740e49f0" title="Converts an AST to a text string representation of a formula, using specific formatter settings.">SBML_formulaToL3StringWithSettings()</a> The settings available include the following: <ul style="list-style-type: circle">
<li style="margin-bottom: 0.5em">
<p class="startli">The function <code>log</code> with a single argument (&quot;<code>log(x)</code>&quot;) can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated as an error, as desired.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Unary minus signs can be collapsed or preserved; that is, sequential pairs of unary minuses (e.g., &quot;<code>- -3</code>&quot;) can be removed from the input entirely and single unary minuses can be incorporated into the number node, or all minuses can be preserved in the AST node structure.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">Parsing of units embedded in the input string can be turned on and off.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string <code>avogadro</code> can be parsed as a MathML <em>csymbol</em> or as an identifier.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">The string % can be parsed either as a piecewise function or as the 'rem' function: <code>a % b</code> will either become</p>
<p class="interli"><code>piecewise(a - b*ceil(a/b), xor((a &lt; 0), (b &lt; 0)), a - b*floor(a/b))</code></p>
<p class="interli">or</p>
<p class="interli"><code>rem(a, b)</code>.</p>
<p class="interli">The latter is simpler, but the <code>rem</code> MathML is only allowed as of SBML Level&#160;3 Version&#160;2.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<p class="startli">A <a class="el" href="class_model.html">Model</a> object may optionally be provided to the parser using the variant function call <a class="el" href="_l3_parser_8cpp.html#abb4e76b36ef84300c2901302ca5542f4" title="Parses a text string as a mathematical formula using a Model to resolve symbols, and returns an AST r...">SBML_parseL3FormulaWithModel()</a> or stored in a <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object passed to the variant function <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>. When a <a class="el" href="class_model.html">Model</a> object is provided, identifiers (values of type <code>SId</code> ) from that model are used in preference to pre-defined MathML definitions for both symbols and functions. More precisely: </p><ul style="list-style-type: square">
<li style="margin-bottom: 0.5em">
<p class="startli"><em>In the case of symbols</em>: the <a class="el" href="class_model.html">Model</a> entities whose identifiers will shadow identical symbols in the mathematical formula are: <a class="el" href="class_species.html">Species</a>, <a class="el" href="class_compartment.html">Compartment</a>, <a class="el" href="class_parameter.html">Parameter</a>, <a class="el" href="class_reaction.html">Reaction</a>, and <a class="el" href="class_species_reference.html">SpeciesReference</a>. For instance, if the parser is given a <a class="el" href="class_model.html">Model</a> containing a <a class="el" href="class_species.html">Species</a> with the identifier &quot;<code>pi</code>&quot;, and the formula to be parsed is &quot;<code>3*pi</code>&quot;, the MathML produced will contain the construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the construct <code>&lt;pi/&gt;</code>.</p>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
<em>In the case of user-defined functions</em>: when a <a class="el" href="class_model.html">Model</a> object is provided, <code>SId</code> values of user-defined functions present in the model will be used preferentially over pre-defined MathML functions. For example, if the passed-in <a class="el" href="class_model.html">Model</a> contains a <a class="el" href="class_function_definition.html">FunctionDefinition</a> object with the identifier &quot;<code>sin</code>&quot;, that function will be used instead of the predefined MathML function <code>&lt;sin/&gt;</code>. </li>
</ul>
<p class="endli"></p>
</li>
<li style="margin-bottom: 0.5em">
An <a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> object may optionally be provided to identify SBML Level&#160;3 packages that extend the syntax understood by the formula parser. When the namespaces are provided, the parser will interpret possible additional syntax defined by the libSBML plug-ins implementing the SBML Level&#160;3 packages; for example, it may understand vector/array extensions introduced by the SBML Level&#160;3 <em>Arrays</em> package. </li>
</ul>
</li>
</ul>
<p>These configuration settings cannot be changed directly using the basic parser and formatter functions, but <em>can</em> be changed on a per-call basis by using the alternative functions <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and <a class="el" href="_l3_formula_formatter_8h.html#af840d48b31961fd33c8f00a7740e49f0" title="Converts an AST to a text string representation of a formula, using specific formatter settings.">SBML_formulaToL3StringWithSettings()</a>.</p>
<p>Neither SBML nor the MathML standard define a "string-form" equivalent to MathML expressions. The approach taken by libSBML is to start with the formula syntax defined by SBML Level&#160;1 (which in fact used a custom text-string representation of formulas, and not MathML), and expand it to include the functionality described above. This formula syntax is based mostly on C programming syntax, and may contain operators, function calls, symbols, and white space characters. The following table provides the precedence rules for the different entities that may appear in formula strings.</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors"
       style="padding-bottom: 0.5em">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Token</th>
     <th align="left">Operation</th>
     <th align="left">Class</th>
     <th>Preced.</th>
     <th align="left">Assoc.</th>
 </tr>
<tr><td><em>name</em></td><td>symbol reference</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>(</code><em>expression</em><code>)</code></td><td>expression grouping</td><td>operand</td><td align="center">8</td><td>n/a</td></tr>
<tr><td><code>f(</code><em>...</em><code>)</code></td><td>function call</td><td>prefix</td><td align="center">8</td><td>left</td></tr>
<tr><td><code>^</code></td><td>power</td><td>binary</td><td align="center">7</td><td>left</td></tr>
<tr><td><code>-, !</code></td><td>negation, Boolean 'not'</td><td>unary</td><td align="center">6</td><td>right</td></tr>
<tr><td><code>*, /, %</code></td><td>multip., div., modulo</td><td>binary</td><td align="center">5</td><td>left</td></tr>
<tr><td><code>+, -</code></td><td>addition and subtraction</td><td>binary</td><td align="center">4</td><td>left</td></tr>
<tr><td><code>==, &lt;, &gt;, &lt;=, &gt;=, !=</code></td><td>Boolean comparisons</td><td>binary</td><td align="center">3</td><td>left</td></tr>
<tr><td><code>&&, ||</code></td><td>Boolean 'and' and 'or'</td><td>binary</td><td align="center">2</td><td>left</td></tr>
<tr><td><code>,</code></td><td>argument delimiter</td><td>binary</td><td align="center">1</td><td>left</td></tr>

<caption class="top-caption">Expression operators and their precedence in the
"Level&nbsp;3" text-string format for mathematical expressions.
</caption>
</table>

<p>In the table above, <em>operand</em> implies the construct is an operand, <em>prefix</em> implies the operation is applied to the following arguments, <em>unary</em> implies there is one argument, and <em>binary</em> implies there are two arguments. The values in the <b>Precedence</b> column show how the order of different types of operation are determined. For example, the expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> because the <code>*</code> operator has higher precedence. The <b>Associates</b> column shows how the order of similar precedence operations is determined; for example, <code>a &amp;&amp; b || c</code> is evaluated as <code>(a &amp;&amp; b) || c</code> because the <code>&amp;&amp;</code> and <code>||</code> operators are left-associative and have the same precedence.</p>
<p>The function call syntax consists of a function name, followed by optional white space, followed by an opening parenthesis token, followed by a sequence of zero or more arguments separated by commas (with each comma optionally preceded and/or followed by zero or more white space characters), followed by a closing parenthesis token. The function name must be chosen from one of the pre-defined functions in SBML or a user-defined function in the model. The following table lists the names of certain common mathematical functions; this table corresponds to Table&#160;6 in the <a href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2" target="_blank">SBML Level&#160;1 Version&#160;2 specification</a> with additions based on the functions added in SBML Level 2 and Level 3:</p>
<table border="0" width="95%" 
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="75">Argument(s)</th>
     <th align="left">Formula or meaning</th>
     <th align="left" width="90">Argument Constraints</th>
     <th align="left" width="90">Result constraints</th>
 </tr>
<tr><td><code>abs</code></td>   
    <td><em>x</em></td> 
    <td>Absolute value of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acos</code>, <code>arccos</code></td>
    <td><em>x</em></td>
    <td>Arccosine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>acos(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>acosh</code>, <code>arccosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosine of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acot</code>, <code>arccot</code></td>
    <td><em>x</em></td>
    <td>Arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acoth</code>, <code>arccoth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccotangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsc</code>, <code>arccsc</code></td>
    <td><em>x</em></td>
    <td>Arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>acsch</code>, <code>arccsch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arccosecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asec</code>, <code>arcsec</code></td>
    <td><em>x</em></td>
    <td>Arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asech</code>, <code>arcsech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arcsecant of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>asin</code>, <code>arcsin</code></td>
    <td><em>x</em></td><td>Arcsine of <em>x</em> in radians.</td>
    <td>&ndash;1.0 &le; <em>x</em> &le; 1.0</td>
    <td>0 &le; <em>asin(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atan</code>, <code>arctan</code></td>
    <td><em>x</em></td>
    <td>Arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td>0 &le; <em>atan(x)</em> &le; &pi;</td>
</tr>
<tr><td><code>atanh</code>, <code>arctanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic arctangent of <em>x</em> in radians.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ceil</code>, <code>ceiling</code></td>
    <td><em>x</em></td>
    <td>Smallest number not less than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cos</code></td>
    <td><em>x</em></td>
    <td>Cosine of <em>x</em></td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cosh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>cot</code></td>
    <td><em>x</em></td>
    <td>Cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>coth</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cotangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csc</code></td>
    <td><em>x</em></td>
    <td>Cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>csch</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic cosecant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>delay</code></td>
    <td><em>x, y</em></td>
    <td>The value of <em>x</em> at <em>y</em> time units in the past.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>factorial</code></td>
    <td><em>n</em></td>
    <td>The factorial of <em>n</em>. Factorials are defined by <em>n! = n*(n&ndash;1)* ... * 1</em>.</td>
    <td><em>n</em> must be an integer.</td>
    <td></td>
</tr>
<tr><td><code>exp</code></td>
    <td><em>x</em></td>
    <td><em>e</em><sup><em> x</em></sup>, where <em>e</em> is the base of the natural logarithm.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>floor</code></td>
    <td><em>x</em></td>
    <td>The largest number not greater than <em>x</em> whose value is an exact integer.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>ln</code></td>
    <td><em>x</em></td>
    <td>Natural logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x</em></td>
    <td>By default, the base 10 logarithm of <em>x</em>, but can be set to be the natural logarithm of <em>x</em>, or to be an illegal construct.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log</code></td>
    <td><em>x, y</em></td>
    <td>The base <em>x</em> logarithm of <em>y</em>.</td>
    <td><em>y</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>log10</code></td>
    <td><em>x</em></td>
    <td>Base 10 logarithm of <em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td></td>
</tr>
<tr><td><code>piecewise</code></td>
    <td><em>x1, y1, [x2, y2,] [...] [z]</em></td>
    <td>A piecewise function: if (<em>y1</em>), <em>x1</em>.  Otherwise, if (<em>y2</em>), <em>x2</em>, etc.  Otherwise, z. </td>
    <td><em>y1, y2, y3 [etc]</em> must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>pow</code>, <code>power</code> </td>
    <td><em>x, y</em></td>
    <td><em>x</em><sup><em> y</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>root</code></td>
    <td><em>b, x</em></td>
    <td>The root base <em>b</em> of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sec</code></td>
    <td><em>x</em></td>
    <td>Secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sech</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic secant of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqr</code></td>
    <td><em>x</em></td>
    <td><em>x</em><sup><em>2</em></sup>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sqrt</code></td>
    <td><em>x</em></td>
    <td>&radic;<em>x</em>.</td>
    <td><em>x</em> &gt; 0</td>
    <td><em>sqrt(x)</em> &ge; 0</td>
</tr>
<tr><td><code>sin</code></td>
    <td><em>x</em></td>
    <td>Sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>sinh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic sine of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>tan</code></td>
    <td><em>x</em></td>
    <td>Tangent of <em>x</em>.</td>
    <td>x &ne; n*&pi;/2, for odd integer <em>n</em></td>
    <td></td>
</tr>
<tr><td><code>tanh</code></td>
    <td><em>x</em></td>
    <td>Hyperbolic tangent of <em>x</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>and</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>and(x, y, z...)</em>: returns <code>true</code> if all of its arguments are true.  Note that <code>and</code> is an n-ary function, taking 0 or more arguments, and that <code>and()</code> returns <code>true</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>not</code></td>
    <td><em>x</em></td>
    <td>Boolean <em>not(x)</em></td>
    <td><em>x</em> must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>or</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>or(x, y, z...)</em>: returns <code>true</code> if at least one of its arguments is true.  Note that <code>or</code> is an n-ary function, taking 0 or more arguments, and that <code>or()</code> returns <code>false</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>xor</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>xor(x, y, z...)</em>: returns <code>true</code> if an odd number of its arguments is true.  Note that <code>xor</code> is an n-ary function, taking 0 or more arguments, and that <code>xor()</code> returns <code>false</code>.</td>
    <td>All arguments must be Boolean</td>
    <td></td>
</tr>
<tr><td><code>eq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>eq(x, y, z...)</em>: returns <code>true</code> if all arguments are equal.  Note that <code>eq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>geq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>geq(x, y, z...)</em>: returns <code>true</code> if each argument is greater than or equal to the argument following it.  Note that <code>geq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>gt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>gt(x, y, z...)</em>: returns <code>true</code> if each argument is greater than the argument following it.  Note that <code>gt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>leq</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>leq(x, y, z...)</em>: returns <code>true</code> if each argument is less than or equal to the argument following it.  Note that <code>leq</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>lt</code></td>
    <td><em>x, y, z...</em></td>
    <td>Boolean <em>lt(x, y, z...)</em>: returns <code>true</code> if each argument is less than the argument following it.  Note that <code>lt</code> is an n-ary function, but must take 2 or more arguments.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>neq</code></td>
    <td><em>x, y</em></td>
    <td>Boolean <em>x</em> != <em>y</em>: returns <code>true</code> unless x and y are equal.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>plus</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> + <em>y</em> + <em>z</em> + <em>...</em>: The sum of the arguments of the function.  Note that <code>plus</code> is an n-ary function taking 0 or more arguments, and that <code>plus()</code> returns <code>0</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>times</code></td>
    <td><em>x, y, z...</em></td>
    <td><em>x</em> * <em>y</em> * <em>z</em> * <em>...</em>: The product of the arguments of the function.  Note that <code>times</code> is an n-ary function taking 0 or more arguments, and that <code>times()</code> returns <code>1</code>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>minus</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> &ndash; <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>
<tr><td><code>divide</code></td>
    <td><em>x, y</em></td>
    <td><em>x</em> / <em>y</em>.</td>
    <td></td>
    <td></td>
</tr>

<caption class="top-caption">Mathematical functions defined
in the "Level&nbsp;3" text-string formula syntax.</caption>

</table>

<p>Parsing of the various MathML functions and constants are all case-insensitive by default: function names such as <code>cos</code>, <code>Cos</code> and <code>COS</code> are all parsed as the MathML cosine operator, <code>&lt;cos&gt;</code>. However, <em>when a <a class="el" href="class_model.html">Model</a> object is used</em> in conjunction with either <a class="el" href="_l3_parser_8cpp.html#abb4e76b36ef84300c2901302ca5542f4" title="Parses a text string as a mathematical formula using a Model to resolve symbols, and returns an AST r...">SBML_parseL3FormulaWithModel()</a> or <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>, any identifiers found in that model will be parsed in a case-<em>sensitive</em> way. For example, if a model contains a <a class="el" href="class_species.html">Species</a> having the identifier <code>Pi</code>, the parser will parse &quot;<code>Pi</code>&quot; in the input as &quot;<code>&lt;ci&gt; Pi &lt;/ci&gt;</code>&quot; but will continue to parse the symbols &quot;<code>pi</code>&quot; and &quot;<code>PI</code>&quot; as &quot;<code>&lt;pi&gt;</code>&quot;.</p>
<p>As mentioned above, the manner in which the "L3" versions of the formula parser and formatter interpret the function &quot;<code>log</code>&quot; can be changed. To do so, callers should use the function <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a> and pass it an appropriate <a class="el" href="class_l3_parser_settings.html">L3ParserSettings</a> object. By default, unlike the SBML Level&#160;1 parser implemented by <a class="el" href="_formula_parser_8cpp.html#ac0f6e91ce03b9dd1070011499050eedc" title="Parses a text string as a mathematical formula and returns an AST representation of it.">SBML_parseFormula()</a>, the string &quot;<code>log</code>&quot; is interpreted as the base&#160;10 logarithm, and <em>not</em> as the natural logarithm. However, you can change the interpretation to be base-10 log, natural log, or as an error; since the name "log" by itself is ambiguous, you require that the parser uses <code>log10</code> or <code>ln</code> instead, which are more clear. Please refer to <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>.</p>
<p>In addition, the following symbols will be translated to their MathML equivalents, if no symbol with the same <code>SId</code> identifier string exists in the <a class="el" href="class_model.html">Model</a> object provided:</p>
<table border="0" width="95%"
       class="centered text-table normal-font alt-row-colors">
 <tr>
     <th align="left" width="60">Name</th>
     <th align="left" width="250">Meaning</th>
     <th align="left">MathML</th>
 </tr>
<tr><td><code>true</code></td>   
    <td>Boolean value <code>true</code></td>
    <td><code>&lt;true/&gt;</code></td>
</tr>
<tr><td><code>false</code></td>   
    <td>Boolean value <code>false</code></td>
    <td><code>&lt;false/&gt;</code></td>
</tr>
<tr><td><code>pi</code></td>   
    <td>Mathematical constant pi</td>
    <td><code>&lt;pi/&gt;</code></td>
</tr>
<tr><td><code>avogadro</code></td>   
    <td>Value of Avogadro's constant stipulated by SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/avogadro"&gt; avogadro &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>time</code></td>   
    <td>Simulation time as defined in SBML</td>
    <td><code style="letter-spacing: -1px">&lt;csymbol encoding="text" definitionURL="http://www.sbml.org/sbml/symbols/time"&gt; time &lt;/csymbol/&gt;</code></td>
</tr>
<tr><td><code>inf</code>, <code>infinity</code></td>   
    <td>Mathematical constant "infinity"</td>
    <td><code>&lt;infinity/&gt;</code></td>
</tr>
<tr><td><code>nan</code>, <code>notanumber</code></td>   
    <td>Mathematical concept "not a number"</td>
    <td><code>&lt;notanumber/&gt;</code></td>
</tr>

<caption class="top-caption">Mathematical symbols defined
in the "Level&nbsp;3" text-string formula syntax.
</caption>
</table>
<p>Again, as mentioned above, whether the string &quot;<code>avogadro</code>&quot; is parsed as an AST node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4fab2a5f966e56f6062f9f9505921d0d">AST_NAME</a> is configurable; use the version of the parser function called <a class="el" href="_l3_parser_8cpp.html#a77c72a78afff728a6c569790338f2085" title="Parses a text string as a mathematical formula using specific parser settings and returns an AST repr...">SBML_parseL3FormulaWithSettings()</a>. This Avogadro-related functionality is provided because SBML Level&#160;2 models may not use <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a> AST nodes.</p>
<h1><a class="anchor" id="math-ast"></a>
Methods for working directly with libSBML's Abstract Syntax Trees</h1>
<p>While it is convenient to read and write mathematical expressions in the form of text strings, advanced applications usually need more powerful ways of creating, traversing, and modifying mathematical formulas. For this reason, libSBML provides a rich API for interacting with ASTs directly. This section summarizes these facilities; for more information, readers should consult the documentation for the <a class="el" href="class_a_s_t_node.html">ASTNode</a> class.</p>
<dl class="section user"><dt></dt><dd>Every <a class="el" href="class_a_s_t_node.html">ASTNode</a> has an associated type code to indicate whether, for example, it holds a number or stands for an arithmetic operator. The type is recorded as a value drawn from the enumeration <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode types.">ASTNodeType_t</a>. The list of possible types is quite long, because it covers all the mathematical functions that are permitted in SBML. The values are shown in the following table:</dd></dl>
<table border="0" class="centered text-table align-bottom borderless code">
<tr><td>AST_CONSTANT_E</td><td>         AST_FUNCTION_CSC</td><td>                       AST_LOGICAL_AND</td></tr>
<tr><td>AST_CONSTANT_FALSE</td><td>     AST_FUNCTION_CSCH</td><td>                      AST_LOGICAL_IMPLIES<sup>2</sup></td></tr>
<tr><td>AST_CONSTANT_PI</td><td>        AST_FUNCTION_DELAY</td><td>                     AST_LOGICAL_NOT</td></tr>
<tr><td>AST_CONSTANT_TRUE</td><td>      AST_FUNCTION_EXP</td><td>                       AST_LOGICAL_OR</td></tr>
<tr><td>AST_DIVIDE</td><td>             AST_FUNCTION_FACTORIAL</td><td>                 AST_LOGICAL_XOR</td></tr>
<tr><td>AST_FUNCTION</td><td>           AST_FUNCTION_FLOOR</td><td>                     AST_MINUS</td></tr>
<tr><td>AST_FUNCTION_ABS</td><td>       AST_FUNCTION_LN</td><td>                        AST_NAME</td></tr>
<tr><td>AST_FUNCTION_ARCCOS</td><td>    AST_FUNCTION_LOG</td><td>                       AST_NAME_AVOGADRO<sup>1</sup></td></tr>
<tr><td>AST_FUNCTION_ARCCOSH</td><td>   AST_FUNCTION_MAX<sup>2</sup></td><td>           AST_NAME_TIME</td></tr>
<tr><td>AST_FUNCTION_ARCCOT</td><td>    AST_FUNCTION_MIN<sup>2</sup></td><td>           AST_ORIGINATES_IN_PACKAGE<sup>2</sup></tr>
<tr><td>AST_FUNCTION_ARCCOTH</td><td>   AST_FUNCTION_PIECEWISE</td><td>                 AST_PLUS</td></tr>
<tr><td>AST_FUNCTION_ARCCSC</td><td>    AST_FUNCTION_POWER</td><td>                     AST_POWER</td></tr>
<tr><td>AST_FUNCTION_ARCCSCH</td><td>   AST_FUNCTION_QUOTIENT<sup>2</sup></td><td>      AST_RATIONAL</td></tr>
<tr><td>AST_FUNCTION_ARCSEC</td><td>    AST_FUNCTION_RATE_OF<sup>2</sup></td><td>       AST_REAL</td></tr>
<tr><td>AST_FUNCTION_ARCSECH</td><td>   AST_FUNCTION_REM<sup>2</sup></td><td>           AST_REAL_E</td></tr>
<tr><td>AST_FUNCTION_ARCSIN</td><td>    AST_FUNCTION_ROOT</td><td>                      AST_RELATIONAL_EQ</td></tr>
<tr><td>AST_FUNCTION_ARCSINH</td><td>   AST_FUNCTION_SEC</td><td>                       AST_RELATIONAL_GEQ</td></tr>
<tr><td>AST_FUNCTION_ARCTAN</td><td>    AST_FUNCTION_SECH</td><td>                      AST_RELATIONAL_GT</td></tr>
<tr><td>AST_FUNCTION_ARCTANH</td><td>   AST_FUNCTION_SIN</td><td>                       AST_RELATIONAL_LEQ</td></tr>
<tr><td>AST_FUNCTION_CEILING</td><td>   AST_FUNCTION_SINH</td><td>                      AST_RELATIONAL_LT</td></tr>
<tr><td>AST_FUNCTION_COS</td><td>       AST_FUNCTION_TAN</td><td>                       AST_RELATIONAL_NEQ</td></tr>
<tr><td>AST_FUNCTION_COSH</td><td>      AST_FUNCTION_TANH</td><td>                      AST_TIMES</td></tr>
<tr><td>AST_FUNCTION_COT</td><td>       AST_INTEGER</td><td>                            AST_UNKNOWN</td></tr>
<tr><td>AST_FUNCTION_COTH</td><td>      AST_LAMBDA</td></tr>
<tr><td><sup>1</sup> <span class='warning'><em>(Level&nbsp;3 only)</em></span><br/></td></tr>
<tr><td><sup>2</sup> <span class='warning'><em>(Level&nbsp;3 Version&nbsp;2+ only)</em></span></td></tr>
</table>


<p>The types have the following meanings:</p>
<ul>
<li>If the node is basic mathematical operator (e.g., <code>"+"</code>), then the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203acd4fa16c348e2bf7ab24120eff0f0063">AST_PLUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a04afe78f8ca0f64c4d49f3cd1a8b41ec">AST_MINUS</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a3b5febe16514530ccf97536c0a26244d">AST_TIMES</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a11408698b7be79184ba65779128ef654">AST_DIVIDE</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203abfa0a5d49f1a260bab7663cf688e76a9">AST_POWER</a>, as appropriate.</li>
</ul>
<ul>
<li>If the node is a predefined function or operator from SBML Level&#160;1 (in the string-based formula syntax used in Level&#160;1) or SBML Level&#160;2 and&#160;3 (in the subset of MathML used in SBML Levels&#160;2 and&#160;3), then the node's type will be either <code style="margin-right: 0">AST_FUNCTION_</code><span class="placeholder-nospace">X</span>, <code style="margin-right: 0">AST_LOGICAL_</code><span class="placeholder-nospace">X</span>, or <code style="margin-right: 0">AST_RELATIONAL_</code><span class="placeholder-nospace">X</span>, as appropriate. (Examples: <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aee5ce31deca83c9d96a5888474bc0e4d">AST_FUNCTION_LOG</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aaa8b4b6cb64685254887b5a6fe81678f">AST_RELATIONAL_LEQ</a>.)</li>
</ul>
<ul>
<li>If the node refers to a user-defined function, the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aca72ec3f021680346ad5d4f7f396c342">AST_FUNCTION</a> (because it holds the name of the function).</li>
</ul>
<ul>
<li>If the node is a lambda expression, its type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4703ee0d883714d334ee0d7b534f0ac9">AST_LAMBDA</a>.</li>
</ul>
<ul>
<li>If the node is a predefined constant (<code>"ExponentialE"</code>, <code>"Pi"</code>, <code>"True"</code> or <code>"False"</code>), then the node's type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adb591fa008acf014bc037d95a6a89a69">AST_CONSTANT_E</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa94de3fb689270170a756ed428b253f6">AST_CONSTANT_PI</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ad571d2b80f4dcc08fc489960efdb2ab3">AST_CONSTANT_TRUE</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203adc46a568eb6b891f72738b67da24347a">AST_CONSTANT_FALSE</a>.</li>
</ul>
<ul>
<li>(Levels&#160;2 and&#160;3 only) If the node is the special MathML csymbol <code>time</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a0358231b02f7964269ebb2e580defdf2">AST_NAME_TIME</a>. (Note, however, that the MathML csymbol <code>delay</code> is translated into a node of type <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a1e338a4da69ff5894213bd14a3b46b91">AST_FUNCTION_DELAY</a>. The difference is due to the fact that <code>time</code> is a single variable, whereas <code>delay</code> is actually a function taking arguments.)</li>
</ul>
<ul>
<li>(Level&#160;3 only) If the node is the special MathML csymbol <code>avogadro</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aa9754e70ec0089366d031fecedc8d04e">AST_NAME_AVOGADRO</a>.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is the special MathML csymbol <code>rateOf</code>, the value of the node will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203aedbf4bf10b748da0f71f05c1ea99080f">AST_FUNCTION_RATE_OF</a>.</li>
</ul>
<ul>
<li>(Level&#160;3 Version&#160;2+ only) If the node is a MathML operator that originates in a package, it is included in the ASTNodeType_t list, but may not be legally used in an SBML document that does not include that package. This includes the node types from the 'Distributions' package (<a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a1fc325768aee9f59a93ef090eb7dc4c9">AST_DISTRIB_FUNCTION_NORMAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a4ecce7aa854c8573fa6a4d5dc1a4701c">AST_DISTRIB_FUNCTION_UNIFORM</a>, etc.), and elements from MathML that were not included in core.</li>
</ul>
<ul>
<li>If the node contains a numerical value, its type will be <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a7aa940aba7b587a525c4df1d01766967">AST_INTEGER</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a634db469deca7c255a3694c5cb3a4863">AST_REAL</a>, <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a69ecd50bf295b71067bc9499f2d305d1">AST_REAL_E</a>, or <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203a117b5a5afc8b127b138622ad07dc8d54">AST_RATIONAL</a>, as appropriate.</li>
</ul>
<dl class="section user"><dt></dt><dd>There are a number of methods for interrogating the type of an <a class="el" href="class_a_s_t_node.html">ASTNode</a> and for testing whether a node belongs to a general category of constructs. The methods on <a class="el" href="class_a_s_t_node.html">ASTNode</a> for this purpose are the following:</dd></dl>
<ul>
<li><code>ASTNodeType_t <a class="el" href="class_a_s_t_node.html#aaa934fcde1d07f0f1c061b9dd06f6afb">getType()</a></code> returns the type of this AST node. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a8b42abf93fc6056c53c31d77bfe05583">isConstant()</a></code> returns <code>true</code> if this AST node is a MathML constant (<code>true</code>, <code>false</code>, <code>pi</code>, <code>exponentiale</code>), <code>false</code> otherwise. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a53001b84f9ea746a3caa12e4346c5e07">isBoolean()</a></code> returns <code>true</code> if this AST node returns a Boolean value (by being either a logical operator, a relational operator, or the constant <code>true</code> or <code>false</code>). </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a55a3758a3436b2a65fc366db36f877b7">isFunction()</a></code> returns <code>true</code> if this AST node is a function (i.e., a MathML defined function such as <code>exp</code> or else a function defined by a <a class="el" href="class_function_definition.html">FunctionDefinition</a> in the <a class="el" href="class_model.html">Model</a>). </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#ae990bb9bc7c1ee85435ea631c32fd090">isInfinity()</a></code> returns <code>true</code> if this AST node is the special IEEE 754 value infinity. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a0dc100c11710945c43c8c90f6cd95a3a">isInteger()</a></code> returns <code>true</code> if this AST node is holding an integer value. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#aefb9fc75b2bd81663512ebce1886e4da">isNumber()</a></code> returns <code>true</code> if this AST node is holding any number. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a985209cb471d6ab7de66e490b3951557">isLambda()</a></code> returns <code>true</code> if this AST node is a MathML <code>lambda</code> construct. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a16fc55100fe51edc783350bc748606aa">isLog10()</a></code> returns <code>true</code> if this AST node represents the <code>log10</code> function, specifically, that its type is <code>AST_FUNCTION_LOG</code> and it has two children, the first of which is an integer equal to 10. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a57abffc95ec4be0b303b2b7f35aa320f">isLogical()</a></code> returns <code>true</code> if this AST node is a logical operator (<code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>). </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a5e1b8ddefb172315469f56761c0555bc">isName()</a></code> returns <code>true</code> if this AST node is a user-defined name or (in SBML Levels&#160;2 and&#160;3) one of the two special <code>csymbol</code> constructs "delay" or "time". </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#afa2d44197245921e23ddb263c1050b96">isNaN()</a></code> returns <code>true</code> if this AST node has the special IEEE 754 value "not a number" (NaN). </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#ac750afc0c08e4bfc94c20de095ba909b">isNegInfinity() </a></code> returns <code>true</code> if this AST node has the special IEEE 754 value of negative infinity. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a7d167168f1e9d062fd3f8f5f8cad951e">isOperator()</a></code> returns <code>true</code> if this AST node is an operator (e.g., <code>+</code>, <code>-</code>, etc.) </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a82ea7bf8180435b1a3fdd260a3b0d886">isPiecewise()</a></code> returns <code>true</code> if this AST node is the MathML <code>piecewise</code> function. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#ab08e12a04ae2c49ee0c107121dea136a">isRational()</a></code> returns <code>true</code> if this AST node is a rational number having a numerator and a denominator. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#af089ab6a15a5749545471c57c717c5a3">isReal()</a></code> returns <code>true</code> if this AST node is a real number (specifically, <code>AST_REAL_E</code> or <code>AST_RATIONAL</code>). </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a75e3de3540380c4f9af73bb8ccf7c79d">isRelational()</a></code> returns <code>true</code> if this AST node is a relational operator. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a38b4f4926633a26a8a028cd1b0715be9">isSqrt()</a></code> returns <code>true</code> if this AST node is the square-root operator </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a2b3324f1e9873236c540bc1f930881db">isUMinus()</a></code> returns <code>true</code> if this AST node is a unary minus. </li>
<li><code>bool <a class="el" href="class_a_s_t_node.html#a7868d8333ea7a206e128e5a928d8477e">isUnknown()</a></code> returns <code>true</code> if this AST node's type is unknown.</li>
</ul>
<p>Programs manipulating AST node structures should check the type of a given node before calling methods that return a value from the node. The following are the <a class="el" href="class_a_s_t_node.html">ASTNode</a> object methods available for returning values from nodes:</p>
<ul>
<li><code>long <a class="el" href="class_a_s_t_node.html#a85b0d75569f92141c9675b4791873785">getInteger()</a></code> </li>
<li><code>char <a class="el" href="class_a_s_t_node.html#af119ca46b99dec97a70ae233172eb78e">getCharacter()</a></code> </li>
<li><code>const char* <a class="el" href="class_a_s_t_node.html#a1bd99fd7074a2ed6e50ded3c406bfb14">getName()</a></code> </li>
<li><code>long <a class="el" href="class_a_s_t_node.html#a17a4868804e7e10a6cf79430723a4aee">getNumerator()</a></code> </li>
<li><code>long <a class="el" href="class_a_s_t_node.html#a620072b6b11a6c83943ecdfa4385f6d6">getDenominator()</a></code> </li>
<li><code>double <a class="el" href="class_a_s_t_node.html#a9d737e799a7c6b9757fd03abed50b580">getReal()</a></code> </li>
<li><code>double <a class="el" href="class_a_s_t_node.html#a8da51fb905d7460d7531893906a21a1f">getMantissa()</a></code> </li>
<li><code>long <a class="el" href="class_a_s_t_node.html#ac0466ef0434e4044c09bad81238c0f8b">getExponent()</a></code></li>
</ul>
<p>Of course, all of this would be of little use if libSBML didn't also provide methods for <em>setting</em> the values of AST node objects! And it does. The methods are the following:</p>
<ul>
<li><code>void <a class="el" href="class_a_s_t_node.html#a5494556fb0158d211598dd94d12ec05d">setCharacter(char value)</a></code> sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given character <code>value</code>. If character is one of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> or <code>^</code>, the node type will be to the appropriate operator type. For all other characters, the node type will be set to <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a>. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#a8b45c89bbe89ac83d7139653609c30ba">setName(const char *name)</a></code> sets the value of this AST node to the given <code>name</code>. The node type will be set (to <code>AST_NAME</code>) <em>only if</em> the AST node was previously an operator (<code>isOperator(node) != 0</code>) or number (<code>isNumber(node) != 0</code>). This allows names to be set for <code>AST_FUNCTIONs</code> and the like. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#a69097fbcbc9e0771573472049e249784">setValue(int value) </a></code> sets the value of the node to the given integer <code>value</code>. Equivalent to the next method. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#a38d4ced59cd23b76e0c332afe20ab0f3">setValue(long value) </a></code> sets the value of the node to the given integer <code>value</code>. Equivalent to the previous method. No, this is not a G&ouml;delian self-referential loop. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#af450115d10253bc42acaf39801c5a173">setValue(long numerator, long denominator)</a></code> sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given rational <code>value</code> in two parts: the numerator and denominator. The node type is set to <code>AST_RATIONAL</code>. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#a49dad5ffb929e5f42955b57357902557">setValue(double value) </a></code> sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given real (double) <code>value</code> and sets the node type to <code>AST_REAL</code>. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#ad672b2de729eaf8aa813234d15e15efa">setValue(double mantissa, long exponent)</a></code> sets the value of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to a real (double) using the two parts given: the mantissa and the exponent. The node type is set to <code>AST_REAL_E</code>.</li>
</ul>
<p>Finally, <a class="el" href="class_a_s_t_node.html">ASTNode</a> also defines some miscellaneous methods for manipulating ASTs:</p>
<ul>
<li><code>ASTNode* <a class="el" href="class_a_s_t_node.html#a367fe0566fc1a2483221424f4101ad06">ASTNode(ASTNodeType_t type)</a></code> creates a new <a class="el" href="class_a_s_t_node.html">ASTNode</a> object and returns a pointer to it. The returned node will have the given <code>type</code>, or a type of <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203ab845bbc0e0fdade1d53c4104e7888a8f">AST_UNKNOWN</a> if no argument <code>type</code> is explicitly given or the type code is unrecognized. </li>
<li><code>unsigned int <a class="el" href="class_a_s_t_node.html#a9c1e708a632ae00f528106d413ad1cb2">getNumChildren() </a></code> returns the number of children of this AST node or <code>0</code> is this node has no children. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#ad699b88d62f54bce4edf94d6ffd110f1">addChild(ASTNode* child, bool inRead)</a></code> adds the given node as a child of this AST node. Child nodes are added in left-to-right order. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#a27fec7e37689b7119846815c7f9108a8">prependChild(ASTNode* child)</a></code> adds the given node as a child of this AST node. This method adds child nodes in right-to-left order. </li>
<li><code>ASTNode* <a class="el" href="class_a_s_t_node.html#afe8b40f63d8afb85bbe5f21b0108f53a">getChild(unsigned int n) </a></code> returns the <code>n</code>th child of this AST node or <code>NULL</code> if this node has no <code>n</code>th child [i.e., if <code>n &gt; (node-&gt;getNumChildren() - 1)</code>, where <code>node</code> is a pointer to a node]. </li>
<li><code>ASTNode* <a class="el" href="class_a_s_t_node.html#a564b600c952dce716797c1bd3c808211">getLeftChild() </a></code> returns the left child of this AST node. This is equivalent to <code>getChild(0)</code>. </li>
<li><code>ASTNode* <a class="el" href="class_a_s_t_node.html#ac5ece8fdb8c21f299c61f6c9f537b2e1">getRightChild() </a></code> returns the right child of this AST node or <code>NULL</code> if this node has no right child. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#aa15b06fa2fc77b84b05b26b5fdbebf23">swapChildren(ASTNode *that)</a></code> swaps the children of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> with the children of <code>that</code> <a class="el" href="class_a_s_t_node.html">ASTNode</a>. </li>
<li><code>void <a class="el" href="class_a_s_t_node.html#a08bad16b57e7c27da4f3110cffdc06ff">setType(ASTNodeType_t type)</a></code> sets the type of this <a class="el" href="class_a_s_t_node.html">ASTNode</a> to the given <a class="el" href="_a_s_t_node_type_8h.html#a67bf7933ff8461eb28819ed744bf3203" title="ASTNodeType_t is the enumeration of possible ASTNode types.">ASTNodeType_t</a> enumeration value.</li>
</ul>
<h1><a class="anchor" id="math-reading"></a>
Reading and Writing MathML directly</h1>
<dl class="section user"><dt></dt><dd>As mentioned above, applications often can avoid working with raw MathML by using either libSBML's text-string interface or the AST API. However, when needed, reading MathML content directly and creating ASTs is easily done in libSBML using a method designed for this purpose:</dd></dl>
<ul>
<li><code>ASTNode_t* <a class="el" href="_math_m_l_8cpp.html#a0fb4f7430eb05834379253ce3611a00a" title="Reads the MathML from the given XML string, constructs a corresponding abstract syntax tree,...">readMathMLFromString()</a> </code> reads raw MathML from a text string, constructs an AST from it, then returns the root <a class="el" href="class_a_s_t_node.html">ASTNode</a> of the resulting expression tree.</li>
</ul>
<p>Similarly, writing out Abstract Syntax Tree structures is easily done using the following method:</p>
<ul>
<li><code>char* <a class="el" href="_math_m_l_8cpp.html#a539b72bb51b93224ed973436a4add6a4">writeMathMLToString()</a> </code> writes an AST to a string. The caller owns the character string returned and should free it after it is no longer needed.</li>
</ul>
<p>The <a href="#example-program">example program</a> given above demonstrate the use of these methods. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
